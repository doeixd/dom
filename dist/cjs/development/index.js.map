{
  "version": 3,
  "sources": ["../../../src/index.ts"],
  "sourcesContent": ["/**\r\n * @doeixd/dom \r\n * ==========================================\r\n * A production-grade, target-first, type-safe DOM library.\r\n *\r\n * -----------------------------------------------------------------------------\r\n * ðŸ§  DESIGN PHILOSOPHY\r\n * -----------------------------------------------------------------------------\r\n * 1. Target-First: `Action(Element)(Config)` pattern for intuitive chaining.\r\n * 2. Curried: Functions return closures for composition/piping.\r\n * 3. Null-Safe: All functions fail gracefully on `null`/`undefined` targets.\r\n * 4. Type-Safe: Full Generics for HTML Elements, Events, and Return types.\r\n *\r\n * -----------------------------------------------------------------------------\r\n * ðŸ“š API DIRECTORY (27 MODULES)\r\n * -----------------------------------------------------------------------------\r\n *\r\n * ðŸŸ¢ DOM CORE\r\n  *    1. Querying ......... find, findAll, closest\r\n  *    2. Events ........... on, onDelegated, dispatch\r\n  *    3. Manipulation ..... modify, css, tempStyle\r\n  *    4. Structure ........ append, prepend, after, before, remove, wrap, mount\r\n  *    5. Creation ......... el, html, htmlMany, clone\r\n *\r\n * ðŸ”µ STATE & ATTRIBUTES\r\n *    6. Classes .......... cls (add/remove/toggle), watchClass\r\n *    7. Attributes ....... Data (get/set/read/bind), watchAttr, watchText\r\n *    12. Objects ......... Obj (clone, isEqual, pick, omit)\r\n *    14. Refs ............ refs, groupRefs (data-ref handling)\r\n *    16. Cycling ......... cycleClass (State machines)\r\n *\r\n * ðŸŸ¡ LIFECYCLE & OBSERVATION\r\n *    8. Lifecycle ........ onReady, onMount, waitFor\r\n *    17. Cleanup ......... stripListeners, instantiate, cloneMany\r\n *    20. Timing .......... debounce, throttle\r\n *    25. Groups .......... createListenerGroup (Batch cleanup)\r\n *    26. Signals ......... Signal (AbortController wrappers)\r\n *\r\n * ðŸŸ£ LAYOUT & NAVIGATION\r\n *    10. Navigation ...... Traverse (parent, children, siblings, next, prev, parents, nextAll, prevAll, closestAll)\r\n *    11. CSS Utils ....... CssVar, computed, injectStyles, waitTransition\r\n *    15. Color ........... toColorSpace (Color mix utils)\r\n *    18. Geometry ........ rect, offset, isVisible\r\n *    19. Scroll/Focus .... scrollInto, focus, blur\r\n *\r\n * ðŸŸ  DATA & NETWORK\r\n *    9. URL/Form ......... Params, Form (serialize/populate)\r\n *    13. Collections ..... batch, groupBy\r\n *    21. Storage ......... Local, Session (Typed wrappers)\r\n *    22. Cookies ......... Cookie (get/set/remove)\r\n *    23. Network ......... Http (get/post/put/delete)\r\n *    24. PWA ............. SW (Service Worker reg/post)\r\n *    27. Pub/Sub ......... createBus (Typed Event Emitter)\r\n *\r\n * @module fdom\r\n * @author Patrick Glenn\r\n * @license MIT\r\n */\r\n\r\n// =============================================================================\r\n// 0. TYPES & HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Infers a DOM element type from a CSS selector string.\r\n * \r\n * Supports:\r\n * - Tag names: `'div'` â†’ `HTMLDivElement`\r\n * - SVG tags: `'svg'` â†’ `SVGSVGElement`\r\n * - ID selectors: `'#app'` â†’ `HTMLElement`\r\n * - Class selectors: `'.card'` â†’ `HTMLElement`\r\n * - Complex selectors: `'div.card'` â†’ `HTMLElement`\r\n * \r\n * @template S - The selector string literal type\r\n * \r\n * @example\r\n * ```typescript\r\n * type ButtonEl = ParseSelector<'button'>; // HTMLButtonElement\r\n * type AnchorEl = ParseSelector<'a'>; // HTMLAnchorElement\r\n * type SvgEl = ParseSelector<'svg'>; // SVGSVGElement\r\n * ```\r\n */\r\nexport type ParseSelector<S extends string> =\r\n  S extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[S]\r\n  : S extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[S]\r\n  : S extends `#${string}` ? HTMLElement\r\n  : S extends `.${string}` ? HTMLElement\r\n  : HTMLElement;\r\n\r\n/**\r\n * Input that can be an element, selector string, function returning element, or null.\r\n * Used by selector-enabled utilities to accept flexible input types.\r\n */\r\nexport type ElementInput<S extends string = string> =\r\n  | ParseSelector<S>                    // Direct element\r\n  | S                                    // String selector\r\n  | (() => ParseSelector<S> | null)     // Function returning element\r\n  | null;                                // Null\r\n\r\n/**\r\n * Function signature for selector-enabled utilities with dual-mode support.\r\n * Supports both immediate execution and curried application.\r\n */\r\nexport type SelectorFunction<_T extends HTMLElement, A extends any[], R> = {\r\n  /** Immediate mode: all arguments provided at once */\r\n  <S extends string>(input: ElementInput<S>, ...args: A): R;\r\n  /** Curried mode: input provided first, returns function accepting remaining args */\r\n  <S extends string>(input: ElementInput<S>): (...args: A) => R;\r\n};\r\n\r\n/**\r\n * A cleanup/unsubscribe function returned by event listeners and subscriptions.\r\n * \r\n * Call this function to remove the listener and free resources.\r\n * \r\n * @example\r\n * ```typescript\r\n * const cleanup = on(button)('click', handler);\r\n * // Later...\r\n * cleanup(); // Removes the event listener\r\n * ```\r\n */\r\nexport type Unsubscribe = () => void;\r\n\r\n/**\r\n * Event map for HTML elements, extensible for custom events.\r\n * \r\n * @template T - Additional custom event mappings\r\n * \r\n * @example\r\n * ```typescript\r\n * type MyEvents = EventMap<{\r\n *   'custom:save': CustomEvent<{ id: number }>;\r\n *   'custom:delete': CustomEvent<{ id: number }>;\r\n * }>;\r\n * ```\r\n */\r\nexport type EventMap<T extends Record<string, Event> = {}> = HTMLElementEventMap & T;\r\n\r\n/**\r\n * Extracts the detail type from a CustomEvent.\r\n * \r\n * @template T - The CustomEvent type\r\n * \r\n * @example\r\n * ```typescript\r\n * type SaveEvent = CustomEvent<{ id: number }>;\r\n * type Detail = ExtractEventDetail<SaveEvent>; // { id: number }\r\n * ```\r\n */\r\nexport type ExtractEventDetail<T> = T extends CustomEvent<infer D> ? D : never;\r\n\r\n/**\r\n * Properties for creating/modifying elements.\r\n * \r\n * Supports declarative configuration of:\r\n * - Text content\r\n * - HTML content\r\n * - Inline styles\r\n * - Data attributes\r\n * - CSS classes\r\n * - HTML attributes\r\n * - Form element properties\r\n * \r\n * @example\r\n * ```typescript\r\n * const props: ElementProps = {\r\n *   text: 'Click me',\r\n *   class: { active: true, disabled: false },\r\n *   dataset: { userId: 123, role: 'admin' },\r\n *   style: { color: 'red', fontSize: '16px' },\r\n *   attr: { 'aria-label': 'Submit button' }\r\n * };\r\n * ```\r\n */\r\nexport interface ElementProps {\r\n  /** Sets innerText (safer than html) */\r\n  text?: string;\r\n  /** Sets innerHTML (use with caution - XSS risk) */\r\n  html?: string;\r\n  /** Inline CSS styles */\r\n  style?: Partial<CSSStyleDeclaration>;\r\n  /** Data attributes (data-*) - auto-converts to kebab-case */\r\n  dataset?: Record<string, string | number | boolean | null | undefined>;\r\n  /** CSS classes with boolean toggles */\r\n  class?: Record<string, boolean>;\r\n  /** HTML attributes */\r\n  attr?: Record<string, string | number | boolean | null | undefined>;\r\n  /** Value for form inputs */\r\n  value?: string | number;\r\n  /** Disabled state for form inputs */\r\n  disabled?: boolean;\r\n}\r\n\r\n/**\r\n * Strict element properties with element-specific validation.\r\n * \r\n * Provides better type safety by constraining properties based on element type.\r\n * \r\n * @template T - The HTML element type\r\n * \r\n * @example\r\n * ```typescript\r\n * const inputProps: StrictElementProps<HTMLInputElement> = {\r\n *   value: 'test',\r\n *   disabled: true,\r\n *   attr: { type: 'text', placeholder: 'Enter name' }\r\n * };\r\n * ```\r\n */\r\nexport type StrictElementProps<T extends HTMLElement> = ElementProps & {\r\n  value?: T extends HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement ? string | number : never;\r\n  disabled?: T extends HTMLInputElement | HTMLButtonElement | HTMLSelectElement | HTMLTextAreaElement ? boolean : never;\r\n};\r\n\r\n/**\r\n * Makes all properties in T deeply readonly.\r\n * \r\n * @template T - The type to make readonly\r\n */\r\nexport type DeepReadonly<T> = {\r\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\r\n};\r\n\r\n/**\r\n * Makes all properties in T deeply partial.\r\n * \r\n * @template T - The type to make partial\r\n */\r\nexport type DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n\r\n// =============================================================================\r\n// NEW FEATURE TYPES\r\n// =============================================================================\r\n\r\n/**\r\n * SVG element tag names that require special namespace handling in h() proxy.\r\n */\r\nexport type SVGElementTags =\r\n  | 'svg' | 'g' | 'path' | 'circle' | 'rect' | 'line' | 'polygon'\r\n  | 'polyline' | 'ellipse' | 'text' | 'tspan' | 'defs' | 'clipPath'\r\n  | 'linearGradient' | 'radialGradient' | 'stop' | 'mask' | 'pattern'\r\n  | 'marker' | 'symbol' | 'use' | 'image' | 'foreignObject';\r\n\r\n/**\r\n * Extended ElementProps that includes dataRef support for h() proxy.\r\n *\r\n * @example\r\n * ```typescript\r\n * const props: HElementProps = {\r\n *   class: { active: true },\r\n *   dataRef: 'myElement'  // Will set data-ref=\"myElement\"\r\n * };\r\n * ```\r\n */\r\nexport interface HElementProps extends ElementProps {\r\n  /** Reference name for element extraction via refs() */\r\n  dataRef?: string;\r\n}\r\n\r\n/**\r\n * Options for configuring a List instance.\r\n *\r\n * @template T - The data item type\r\n *\r\n * @example\r\n * ```typescript\r\n * // Simple list (default blow-away mode)\r\n * const options: ListOptions<string> = {\r\n *   render: (item) => h.li({}, [item])\r\n * };\r\n *\r\n * // Keyed list (efficient diffing)\r\n * const options: ListOptions<User> = {\r\n *   key: user => user.id,\r\n *   render: (user) => h.li({}, [user.name]),\r\n *   update: (el, user) => { el.textContent = user.name; }\r\n * };\r\n * ```\r\n */\r\nexport interface ListOptions<T> {\r\n  /** Function to render each item to an element (required) */\r\n  render: (item: T, index: number) => HTMLElement;\r\n\r\n  /** Optional key function - if provided, enables keyed reconciliation */\r\n  key?: (item: T) => string | number;\r\n\r\n  /** Optional update function for efficient keyed updates */\r\n  update?: (element: HTMLElement, item: T, index: number) => void;\r\n\r\n  /** Optional lifecycle hooks */\r\n  onRemove?: (element: HTMLElement, item: T) => void;\r\n  onAdd?: (element: HTMLElement, item: T) => void;\r\n\r\n  /**\r\n   * Optional custom reconciliation function for full control.\r\n   * When provided, this function is responsible for all DOM updates.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Use morphdom for custom reconciliation\r\n   * reconcile: (oldItems, newItems, container, renderFn) => {\r\n   *   const newHtml = newItems.map(renderFn).map(el => el.outerHTML).join('');\r\n   *   morphdom(container, '<div>' + newHtml + '</div>');\r\n   * }\r\n   * ```\r\n   */\r\n  reconcile?: (\r\n    oldItems: T[],\r\n    newItems: T[],\r\n    container: HTMLElement,\r\n    renderFn: (item: T, index: number) => HTMLElement\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Bound list instance with reactive update methods.\r\n *\r\n * @template T - The data item type\r\n */\r\nexport interface BoundList<T> {\r\n  /** Replace entire list with new items */\r\n  set(items: T[]): void;\r\n\r\n  /** Append items to end of list */\r\n  append(items: T[]): void;\r\n\r\n  /** Prepend items to start of list */\r\n  prepend(items: T[]): void;\r\n\r\n  /** Insert items at specific index */\r\n  insert(index: number, items: T[]): void;\r\n\r\n  /** Remove items matching predicate */\r\n  remove(predicate: (item: T) => boolean): void;\r\n\r\n  /** Update items matching predicate */\r\n  update(predicate: (item: T) => boolean, updater: (item: T) => T): void;\r\n\r\n  /** Clear all items */\r\n  clear(): void;\r\n\r\n  /** Get current items array (readonly) */\r\n  items(): readonly T[];\r\n\r\n  /** Get current elements array (readonly) */\r\n  elements(): readonly HTMLElement[];\r\n\r\n  /** Destroy the list and cleanup */\r\n  destroy(): void;\r\n}\r\n\r\n/**\r\n * Options for configuring a viewRefs template instance.\r\n */\r\nexport interface ViewRefsOptions {\r\n  /** Optional root element class names */\r\n  className?: string | string[];\r\n\r\n  /** Optional root element ID */\r\n  id?: string;\r\n\r\n  /** Optional initial properties for root element */\r\n  props?: ElementProps;\r\n}\r\n\r\n/**\r\n * Context passed to viewRefs template factory.\r\n *\r\n * @template R - The refs shape\r\n */\r\nexport interface ViewRefsContext<R extends Record<string, HTMLElement>> {\r\n  /** Extracted refs object (populated after template execution) */\r\n  refs: R;\r\n}\r\n\r\n/**\r\n * Instance returned by viewRefs factory.\r\n *\r\n * @template R - The refs shape\r\n */\r\nexport interface ViewRefsInstance<R extends Record<string, HTMLElement>> {\r\n  /** The root element */\r\n  element: HTMLElement;\r\n\r\n  /** Typed refs object */\r\n  refs: R;\r\n\r\n  /** Update root element properties */\r\n  update(props: ElementProps): void;\r\n\r\n  /** Update individual refs with smart value handling */\r\n  updateRefs(updates: Partial<{[K in keyof R]: any}>): void;\r\n\r\n  /** Get a setter function for a specific ref */\r\n  bind<K extends keyof R>(key: K): (value: any) => void;\r\n\r\n  /** Destroy element and cleanup */\r\n  destroy(): void;\r\n}\r\n\r\n/**\r\n * Schema defining how refs map to setters.\r\n *\r\n * @template R - The refs shape\r\n */\r\nexport type BinderSchema<R extends Record<string, HTMLElement>> = {\r\n  [K in keyof R]: Setter<any>;\r\n};\r\n\r\n/**\r\n * Infers the data shape from a binder schema.\r\n *\r\n * @template S - The binder schema type\r\n */\r\nexport type InferBinderData<S extends Record<string, Setter<any>>> = {\r\n  [K in keyof S]: S[K] extends Setter<infer T> ? T : never;\r\n};\r\n\r\n/**\r\n * Enhanced binder with batch updates and type-safe setters.\r\n *\r\n * @template R - The refs shape\r\n */\r\nexport interface EnhancedBinder<R extends Record<string, HTMLElement>> {\r\n  /** Call with data object to update multiple refs */\r\n  (data: Partial<InferBinderData<BinderSchema<R>>>): void;\r\n\r\n  /** Individual setter functions */\r\n  set: BinderSchema<R>;\r\n\r\n  /** Batch multiple updates into single operation */\r\n  batch(fn: () => void): void;\r\n\r\n  /** Get current refs object */\r\n  refs(): R;\r\n}\r\n\r\n/**\r\n * Primitive binding functions for common DOM operations.\r\n */\r\nexport interface BindPrimitives {\r\n  /** Bind to textContent */\r\n  text(el: HTMLElement | null): Setter<string>;\r\n\r\n  /** Bind to innerHTML */\r\n  html(el: HTMLElement | null): Setter<string>;\r\n\r\n  /** Bind to attribute */\r\n  attr(name: string): (el: HTMLElement | null) => Setter<string | null>;\r\n\r\n  /** Bind to property */\r\n  prop<K extends keyof HTMLElement>(name: K): (el: HTMLElement | null) => Setter<HTMLElement[K]>;\r\n\r\n  /** Bind to CSS class toggle */\r\n  toggle(className: string): (el: HTMLElement | null) => Setter<boolean>;\r\n\r\n  /** Bind to multiple CSS classes */\r\n  classes(el: HTMLElement | null): Setter<Record<string, boolean>>;\r\n\r\n  /** Bind to style properties */\r\n  style(el: HTMLElement | null): Setter<Partial<CSSStyleDeclaration>>;\r\n\r\n  /** Bind to form input value */\r\n  value(el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null): Setter<string | number>;\r\n\r\n  /** Bind to element visibility */\r\n  show(el: HTMLElement | null): Setter<boolean>;\r\n}\r\n\r\n/**\r\n * Internal: Normalizes content into an array of Nodes.\r\n * \r\n * Handles:\r\n * - Flattening nested arrays\r\n * - Filtering out null/undefined/false\r\n * - Converting strings to text nodes\r\n * - Preserving existing Node instances\r\n * \r\n * @internal\r\n */\r\nconst _nodes = (args: any[]): Node[] =>\r\n  args.flat()\r\n    .filter(x => x != null && x !== false)\r\n    .map(x => x instanceof Node ? x : document.createTextNode(String(x)));\r\n\r\n/**\r\n * Hybrid Function Builder.\r\n * Creates a function that supports both Curried and Imperative usage.\r\n * \r\n * @template T - The Target type (Element, string, etc)\r\n * @template A - The Arguments tuple type\r\n * @template R - The Return type\r\n * \r\n * @example\r\n * const add = def((el: HTMLElement, cls: string) => el.classList.add(cls));\r\n * \r\n * // Usage 1: Imperative (Cleaner DX)\r\n * add(div, 'active');\r\n * \r\n * // Usage 2: Curried (Pipeline friendly)\r\n * pipe(\r\n *   find('.btn'),\r\n *   el => add(el)('active')\r\n * );\r\n */\r\nexport const def = <T, A extends any[], R>(\r\n  // The implementation function takes target + args all at once\r\n  fn: (target: T | null, ...args: A) => R\r\n) => {\r\n  // Overload 1: Called with arguments -> Execute immediately\r\n  function wrapper(target: T | null, ...args: A): R;\r\n\r\n  // Overload 2: Called with just target -> Return curried function\r\n  function wrapper(target: T | null): (...args: A) => R;\r\n\r\n  // Implementation\r\n  function wrapper(target: T | null, ...args: any[]) {\r\n    // If we have extra args, run immediately\r\n    if (args.length > 0) {\r\n      // @ts-ignore - spread is safe here due to generics\r\n      return fn(target, ...args);\r\n    }\r\n    // Otherwise return the closure\r\n    return (...lateArgs: A) => fn(target, ...lateArgs);\r\n  }\r\n\r\n  return wrapper;\r\n};\r\n\r\n// =============================================================================\r\n// 1. QUERYING\r\n// =============================================================================\r\n\r\n\r\n\r\n/**\r\n * Finds the first element matching the selector.\r\n *\r\n * Overloads allow calling in two ways:\r\n * 1. `find(root)(selector)` â€” search within a specific root (default: document)\r\n * 2. `find(selector)` â€” root is implicitly `document`\r\n *\r\n * @template S - CSS selector (literal string for best inference)\r\n *\r\n * @overload\r\n * @param selector - The selector to search for within `document`\r\n * @returns The matched element or `null`, inferred from selector\r\n *\r\n * @example\r\n * // String-first API\r\n * const btn = find(\"button\");   // HTMLButtonElement | null\r\n * const app = find(\"#app\");     // HTMLElement | null\r\n *\r\n * @overload\r\n * @param root - The root to search within (defaults to document)\r\n * @returns A function that accepts a selector and returns the matched element\r\n *\r\n * @example\r\n * // Curried API\r\n * const findIn = find(document.querySelector(\".card\")!);\r\n * const title = findIn(\"h1\");   // HTMLHeadingElement | null\r\n */\r\nexport function find<S extends string>(\r\n  selector: S\r\n): ParseSelector<S> | null;\r\n\r\nexport function find(root?: ParentNode):\r\n  <S extends string>(selector: S) => ParseSelector<S> | null;\r\n\r\nexport function find(arg: any) {\r\n  // Case 1: string passed â€” treat as selector with implicit document root\r\n  if (typeof arg === \"string\") {\r\n    const selector = arg;\r\n    return document.querySelector(selector) as any;\r\n  }\r\n\r\n  // Case 2: root passed â€” return curried selector function\r\n  const root: ParentNode = arg ?? document;\r\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\r\n    return root.querySelector(selector) as ParseSelector<S> | null;\r\n  };\r\n}\r\n\r\n/**\r\n * Finds an element or throws if not found.\r\n * \r\n * @template S - CSS selector\r\n * @param selector - The selector to search for\r\n * @param root - The root to search within (default: document)\r\n * @returns The matched element\r\n * @throws Error if element not found\r\n */\r\nexport function require<S extends string>(selector: S, root: ParentNode = document): ParseSelector<S> {\r\n  const el = root.querySelector(selector);\r\n  if (!el) throw new Error(`Element not found: ${selector}`);\r\n  return el as ParseSelector<S>;\r\n}\r\n\r\n\r\n/**\r\n * Finds all elements matching the selector.\r\n *\r\n * Supports two call styles:\r\n * 1. `findAll(selector)` â€” searches `document`\r\n * 2. `findAll(root)(selector)` â€” searches a specific root\r\n *\r\n * @template S - CSS selector (literal string for best inference)\r\n *\r\n * @overload\r\n * @param selector - Selector to search for within `document`\r\n * @returns Array of matched elements (empty if none)\r\n *\r\n * @example\r\n * const items = findAll(\"li\");   // HTMLLIElement[]\r\n *\r\n * @overload\r\n * @param root - The root to search within (defaults to document)\r\n * @returns Function that accepts a selector and returns an array of elements\r\n *\r\n * @example\r\n * const findInside = findAll(container);\r\n * const inputs = findInside(\"input\");  // HTMLInputElement[]\r\n */\r\nexport function findAll<S extends string>(\r\n  selector: S\r\n): ParseSelector<S>[];\r\n\r\nexport function findAll(root?: ParentNode):\r\n  <S extends string>(selector: S) => ParseSelector<S>[];\r\n\r\nexport function findAll(arg: any) {\r\n  if (typeof arg === \"string\") {\r\n    const selector = arg;\r\n    return Array.from(document.querySelectorAll(selector)) as any[];\r\n  }\r\n\r\n  const root: ParentNode = arg ?? document;\r\n  return <S extends string>(selector: S): ParseSelector<S>[] => {\r\n    return Array.from(root.querySelectorAll(selector)) as ParseSelector<S>[];\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Finds the closest ancestor (including self) matching the selector.\r\n *\r\n * Supports:\r\n * 1. `closest(selector)` â€” uses `document.documentElement` as the starting point\r\n * 2. `closest(element)(selector)` â€” starts from a specific element\r\n *\r\n * Note: Using `closest(selector)` alone is rarely useful unless you\r\n * intentionally want to search from the root element.\r\n *\r\n * @template S - CSS selector (literal type for best inference)\r\n *\r\n * @overload\r\n * @param selector - Selector to match when starting at `document.documentElement`\r\n * @returns The matched ancestor or `null`\r\n *\r\n * @example\r\n * const htmlOrNull = closest(\"html\");\r\n *\r\n * @overload\r\n * @param element - Starting element (null-safe)\r\n * @returns Function accepting a selector that returns the matched ancestor\r\n *\r\n * @example\r\n * const card = closest(button)(\".card\"); // HTMLElement | null\r\n */\r\nexport function closest<S extends string>(\r\n  selector: S\r\n): ParseSelector<S> | null;\r\n\r\nexport function closest(element: Element | null):\r\n  <S extends string>(selector: S) => ParseSelector<S> | null;\r\n\r\nexport function closest(arg: any) {\r\n  if (typeof arg === \"string\") {\r\n    const selector = arg;\r\n    return document.documentElement.closest(selector) as any;\r\n  }\r\n\r\n  const element: Element | null = arg;\r\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\r\n    return element?.closest(selector) as ParseSelector<S> | null;\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Checks whether an element matching the selector exists.\r\n *\r\n * Overloads:\r\n * 1. `exists(selector)` â€” searches `document`\r\n * 2. `exists(root)(selector)` â€” searches within a specific root\r\n *\r\n * @template S - CSS selector (literal for best inference)\r\n *\r\n * @overload\r\n * @param selector - Selector to test within `document`\r\n * @returns `true` if a matching element exists, otherwise `false`\r\n *\r\n * @example\r\n * exists(\"button\");    // boolean\r\n * exists(\"#app\");      // boolean\r\n */\r\nexport function exists<S extends string>(\r\n  selector: S\r\n): boolean;\r\n\r\nexport function exists(root?: ParentNode):\r\n  <S extends string>(selector: S) => boolean;\r\n\r\nexport function exists(arg: any) {\r\n  if (typeof arg === \"string\") {\r\n    return document.querySelector(arg) !== null;\r\n  }\r\n\r\n  const root: ParentNode = arg ?? document;\r\n  return <S extends string>(selector: S): boolean => {\r\n    return root.querySelector(selector) !== null;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns all siblings of an element (excluding the element itself).\r\n *\r\n * Overloads:\r\n * 1. `siblings(node)` â€” returns its siblings\r\n * 2. `siblings(root)(node)` â€” sibling list relative to a specific parent\r\n *\r\n * Null-safe: returns an empty array if `node` or parent is null.\r\n *\r\n * @example\r\n * const btn = document.querySelector(\"button\");\r\n * const sibs = siblings(btn);   // Element[]\r\n *\r\n * @example\r\n * const list = document.querySelector(\"ul\");\r\n * const sibsOf = siblings(list);\r\n * sibsOf(list.querySelector(\"li\"));\r\n */\r\nexport function siblings(node: Element | null): Element[];\r\n\r\nexport function siblings(root: ParentNode | null):\r\n  (node: Element | null) => Element[];\r\n\r\nexport function siblings(arg: any): any {\r\n  if (!(arg instanceof Element) && arg !== null) {\r\n    const root: ParentNode | null = arg;\r\n    return (node: Element | null): Element[] => {\r\n      if (!root || !node) return [];\r\n      return Array.from(root.children).filter(el => el !== node);\r\n    };\r\n  }\r\n\r\n  const node: Element | null = arg;\r\n  if (!node || !node.parentElement) return [];\r\n  return Array.from(node.parentElement.children).filter(el => el !== node);\r\n}\r\n\r\n\r\n/**\r\n * Checks whether a given element contains a descendant matching the selector.\r\n *\r\n * Overloads:\r\n * 1. `has(selector)` â€” checks within `document`\r\n * 2. `has(element)(selector)` â€” checks within a given element\r\n *\r\n * Null-safe: Passing `null` returns a function that always returns false.\r\n *\r\n * @template S - CSS selector string\r\n *\r\n * @overload\r\n * @param selector - Selector checked inside `document`\r\n * @returns `true` if a match exists, otherwise `false`\r\n *\r\n * @example\r\n * has(\".card\");  // boolean\r\n *\r\n * @overload\r\n * @param element - Element to test within (null-safe)\r\n * @returns Function testing a selector inside that element\r\n *\r\n * @example\r\n * const card = document.querySelector(\".card\");\r\n * const result = has(card)(\"button\");\r\n */\r\nexport function has<S extends string>(\r\n  selector: S\r\n): boolean;\r\n\r\nexport function has(element: ParentNode | null):\r\n  <S extends string>(selector: S) => boolean;\r\n\r\nexport function has(arg: any) {\r\n  if (typeof arg === \"string\") {\r\n    return document.querySelector(arg) !== null;\r\n  }\r\n\r\n  const root: ParentNode | null = arg;\r\n  return <S extends string>(selector: S): boolean => {\r\n    if (!root) return false;\r\n    return root.querySelector(selector) !== null;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the index of a node among its siblings.\r\n *\r\n * Overloads:\r\n * 1. `index(node)` â€” returns the node's index or -1\r\n * 2. `index(root)(node)` â€” curries the \"list parent\" (rare but consistent)\r\n *\r\n * Note: When called as `index(node)`, the parent is automatically the node's\r\n * actual parent element.\r\n *\r\n * @example\r\n * const item = document.querySelector(\"li\");\r\n * index(item);  // 0, 1, 2, ...\r\n *\r\n * @example\r\n * // Curried\r\n * const list = document.querySelector(\"ul\");\r\n * index(list)(someLi);\r\n */\r\nexport function index(node: Element | null): number;\r\n\r\nexport function index(root: ParentNode | null):\r\n  (node: Element | null) => number;\r\n\r\nexport function index(arg: any): any {\r\n  // Case: Direct index(node)\r\n  if (!(arg instanceof Element) && arg !== null) {\r\n    // Treat as curried root\r\n    const root: ParentNode | null = arg;\r\n    return (node: Element | null): number => {\r\n      if (!root || !node) return -1;\r\n      const children = Array.from(root.children);\r\n      return children.indexOf(node);\r\n    };\r\n  }\r\n\r\n  // Direct element case\r\n  const node: Element | null = arg;\r\n  if (!node || !node.parentElement) return -1;\r\n  return Array.from(node.parentElement.children).indexOf(node);\r\n}\r\n\r\n\r\n\r\n// =============================================================================\r\n// 2. EVENTS\r\n// =============================================================================\r\n\r\n/**\r\n * Handler type for events\r\n */\r\ntype EventHandler<T extends EventTarget, K extends keyof HTMLElementEventMap> = (\r\n  event: HTMLElementEventMap[K],\r\n  target: T\r\n) => void;\r\n\r\n/**\r\n * Event setup stage: attach listener with event type and handler\r\n */\r\ntype EventSetup<T extends EventTarget> = {\r\n  <K extends keyof HTMLElementEventMap>(\r\n    eventType: K,\r\n    handler: EventHandler<T, K>,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): Unsubscribe;\r\n};\r\n\r\n/**\r\n * Attaches an event listener to the target element.\r\n *\r\n * Returns a cleanup function to remove the listener. Supports all standard\r\n * DOM events with full type inference. The handler receives both the event\r\n * and the target element for convenience.\r\n *\r\n * Supports multiple calling styles:\r\n * ```typescript\r\n * // Curried\r\n * on(button)('click', handler);\r\n *\r\n * // Imperative\r\n * on(button, 'click', handler);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * const button = find('button');\r\n *\r\n * // Curried - great for reuse\r\n * const onButton = on(button);\r\n * onButton('click', (e, target) => console.log('Clicked!', target));\r\n * onButton('mouseenter', (e, target) => cls.add(target)('hovered'));\r\n *\r\n * // Imperative - concise one-offs\r\n * on(button, 'click', (e, target) => {\r\n *   e.preventDefault();\r\n *   submit();\r\n * });\r\n *\r\n * // With options\r\n * on(window, 'scroll', handler, { passive: true });\r\n * on(button)('click', handler, { once: true });\r\n *\r\n * // Null-safe: returns no-op cleanup if target is null\r\n * const missing = find('.missing');\r\n * on(missing, 'click', handler); // Safe, returns () => {}\r\n *\r\n * // Type inference works throughout:\r\n * on(input, 'input', (e) => {\r\n *   console.log(e.data);  // e is InputEvent\r\n * });\r\n *\r\n * on(document, 'keydown', (e) => {\r\n *   if (e.key === 'Escape') close();  // e is KeyboardEvent\r\n * });\r\n * ```\r\n */\r\n// Overload: just target -> returns event setup\r\nexport function on<T extends EventTarget>(\r\n  target: T | null\r\n): EventSetup<T>;\r\n\r\n// Overload: all args -> returns Unsubscribe\r\nexport function on<T extends EventTarget, K extends keyof HTMLElementEventMap>(\r\n  target: T | null,\r\n  eventType: K,\r\n  handler: EventHandler<T, K>,\r\n  options?: boolean | AddEventListenerOptions\r\n): Unsubscribe;\r\n\r\n// Implementation\r\nexport function on<T extends EventTarget, K extends keyof HTMLElementEventMap>(\r\n  target: T | null,\r\n  eventType?: K,\r\n  handler?: EventHandler<T, K>,\r\n  options?: boolean | AddEventListenerOptions\r\n): EventSetup<T> | Unsubscribe {\r\n\r\n  // Core listener factory\r\n  const createListener = <Evt extends keyof HTMLElementEventMap>(\r\n    evt: Evt,\r\n    fn: EventHandler<T, Evt>,\r\n    opts: boolean | AddEventListenerOptions = false\r\n  ): Unsubscribe => {\r\n    if (!target) return () => { };\r\n\r\n    const listener = (e: Event) => fn(e as HTMLElementEventMap[Evt], target);\r\n    target.addEventListener(evt, listener, opts);\r\n    return () => target.removeEventListener(evt, listener, opts);\r\n  };\r\n\r\n  // Event setup stage\r\n  const eventSetup: EventSetup<T> = <Evt extends keyof HTMLElementEventMap>(\r\n    evt: Evt,\r\n    fn: EventHandler<T, Evt>,\r\n    opts?: boolean | AddEventListenerOptions\r\n  ) => createListener(evt, fn, opts);\r\n\r\n  // Route based on provided arguments\r\n  if (eventType === undefined || handler === undefined) {\r\n    // on(target) -> event setup\r\n    return eventSetup;\r\n  }\r\n\r\n  // on(target, event, handler) -> Unsubscribe\r\n  return createListener(eventType, handler, options);\r\n}\r\n\r\n/**\r\n * Handler type for delegated events\r\n */\r\ntype DelegatedHandler<S extends string, K extends keyof HTMLElementEventMap> = (\r\n  event: HTMLElementEventMap[K],\r\n  match: ParseSelector<S>\r\n) => void;\r\n\r\n/**\r\n * Final stage: attach event listener\r\n */\r\ntype DelegatedEventSetup<S extends string> = {\r\n  <K extends keyof HTMLElementEventMap>(\r\n    eventType: K,\r\n    handler: DelegatedHandler<S, K>,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): Unsubscribe;\r\n};\r\n\r\n/**\r\n * Middle stage: select target elements\r\n * Supports both curried and imperative styles\r\n */\r\ntype DelegatedSelectorSetup = {\r\n  // Curried: (selector) => (event, handler) => Unsubscribe\r\n  <S extends string>(selector: S): DelegatedEventSetup<S>;\r\n\r\n  // Imperative: (selector, event, handler) => Unsubscribe\r\n  <S extends string, K extends keyof HTMLElementEventMap>(\r\n    selector: S,\r\n    eventType: K,\r\n    handler: DelegatedHandler<S, K>,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): Unsubscribe;\r\n};\r\n\r\n/**\r\n * Attaches a **Delegated Event Listener** using event bubbling.\r\n *\r\n * Supports multiple calling styles:\r\n * ```typescript\r\n * // Fully curried\r\n * onDelegated(root)('li')('click', handler);\r\n *\r\n * // Partially curried\r\n * onDelegated(root, 'li')('click', handler);\r\n * onDelegated(root)('li', 'click', handler);\r\n *\r\n * // Fully imperative\r\n * onDelegated(root, 'li', 'click', handler);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * const list = find('#user-list');\r\n *\r\n * // Curried - great for reuse\r\n * const onListItem = onDelegated(list)('li');\r\n * onListItem('click', (e, li) => console.log(li.textContent));\r\n * onListItem('mouseenter', (e, li) => cls.add(li)('hovered'));\r\n *\r\n * // Imperative - concise one-offs\r\n * onDelegated(list, 'button.delete', 'click', (e, btn) => {\r\n *   e.stopPropagation();\r\n *   deleteItem(btn.dataset.id);\r\n * });\r\n * ```\r\n */\r\n// Overload: just root -> returns selector setup\r\nexport function onDelegated(\r\n  root: ParentNode | null\r\n): DelegatedSelectorSetup;\r\n\r\n// Overload: root + selector -> returns event setup\r\nexport function onDelegated<S extends string>(\r\n  root: ParentNode | null,\r\n  selector: S\r\n): DelegatedEventSetup<S>;\r\n\r\n// Overload: all args -> returns Unsubscribe\r\nexport function onDelegated<S extends string, K extends keyof HTMLElementEventMap>(\r\n  root: ParentNode | null,\r\n  selector: S,\r\n  eventType: K,\r\n  handler: DelegatedHandler<S, K>,\r\n  options?: boolean | AddEventListenerOptions\r\n): Unsubscribe;\r\n\r\n// Implementation\r\nexport function onDelegated<S extends string, K extends keyof HTMLElementEventMap>(\r\n  root: ParentNode | null,\r\n  selector?: S,\r\n  eventType?: K,\r\n  handler?: DelegatedHandler<S, K>,\r\n  options?: boolean | AddEventListenerOptions\r\n): DelegatedSelectorSetup | DelegatedEventSetup<S> | Unsubscribe {\r\n\r\n  // Core listener factory - the actual work happens here\r\n  const createListener = <Sel extends string, Evt extends keyof HTMLElementEventMap>(\r\n    sel: Sel,\r\n    evt: Evt,\r\n    fn: DelegatedHandler<Sel, Evt>,\r\n    opts: boolean | AddEventListenerOptions = false\r\n  ): Unsubscribe => {\r\n    if (!root) return () => { };\r\n\r\n    const listener = (e: Event) => {\r\n      const target = e.target as Element;\r\n      const match = target.closest?.(sel);\r\n\r\n      if (match && root.contains(match)) {\r\n        fn(e as HTMLElementEventMap[Evt], match as ParseSelector<Sel>);\r\n      }\r\n    };\r\n\r\n    root.addEventListener(evt, listener, opts);\r\n    return () => root.removeEventListener(evt, listener, opts);\r\n  };\r\n\r\n  // Event setup stage: (eventType, handler, options?) => Unsubscribe\r\n  const eventSetup = <Sel extends string>(sel: Sel): DelegatedEventSetup<Sel> => {\r\n    return (<Evt extends keyof HTMLElementEventMap>(\r\n      evt: Evt,\r\n      fn: DelegatedHandler<Sel, Evt>,\r\n      opts?: boolean | AddEventListenerOptions\r\n    ) => createListener(sel, evt, fn, opts)) as DelegatedEventSetup<Sel>;\r\n  };\r\n\r\n  // Selector setup stage: supports both curried and imperative\r\n  const selectorSetup = (<Sel extends string,\r\n    Evt extends keyof HTMLElementEventMap\r\n  >(\r\n    sel: Sel,\r\n    evt?: Evt,\r\n    fn?: DelegatedHandler<Sel, Evt>,\r\n    opts?: boolean | AddEventListenerOptions\r\n  ) => {\r\n    // Imperative: all args provided\r\n    if (evt !== undefined && fn !== undefined) {\r\n      return createListener(sel, evt, fn, opts);\r\n    }\r\n    // Curried: return event setup\r\n    return eventSetup(sel);\r\n  }) as DelegatedSelectorSetup;\r\n\r\n  // Route based on provided arguments\r\n  if (selector === undefined) {\r\n    // onDelegated(root) -> selector setup\r\n    return selectorSetup;\r\n  }\r\n\r\n  if (eventType === undefined || handler === undefined) {\r\n    // onDelegated(root, selector) -> event setup\r\n    return eventSetup(selector);\r\n  }\r\n\r\n  // onDelegated(root, selector, event, handler) -> Unsubscribe\r\n  return createListener(selector, eventType, handler, options);\r\n}\r\n\r\n/**\r\n * Dispatches a CustomEvent from the target element.\r\n * \r\n * Creates and dispatches a CustomEvent with optional detail data. The detail\r\n * type is inferred from the provided data. By default, events bubble up the\r\n * DOM tree.\r\n * \r\n * @template T - The type of the detail data\r\n * @param target - The element to dispatch the event from (null-safe)\r\n * @returns A curried function that accepts event name, detail, and options\r\n * \r\n * @example\r\n * ```typescript\r\n * // Simple custom event\r\n * const button = document.querySelector('button');\r\n * dispatch(button)('clicked', { timestamp: Date.now() });\r\n * \r\n * // Typed custom events\r\n * interface SaveEvent {\r\n *   id: number;\r\n *   data: { name: string; email: string };\r\n * }\r\n * dispatch(form)('save', { id: 123, data: formData } as SaveEvent);\r\n * \r\n * // Listen for custom events\r\n * on(button)('clicked' as any, (e: CustomEvent) => {\r\n *   console.log('Detail:', e.detail); // { timestamp: ... }\r\n * });\r\n * \r\n * // Non-bubbling event\r\n * dispatch(element)('custom', data, { bubbles: false });\r\n * \r\n * // Cancelable event\r\n * dispatch(element)('beforeSave', data, { cancelable: true });\r\n * \r\n * // Component communication pattern\r\n * const modal = document.querySelector('.modal');\r\n * dispatch(modal)('modal:close', { reason: 'user-action' });\r\n * \r\n * // Null-safe: does nothing if target is null\r\n * const missing = document.querySelector('.missing');\r\n * dispatch(missing)('event', data); // Safe, no error\r\n * ```\r\n */\r\nexport const dispatch = (target: EventTarget | null) => {\r\n  return <T = any>(eventName: string, detail?: T, options: EventInit = { bubbles: true }) => {\r\n    if (target) {\r\n      target.dispatchEvent(new CustomEvent(eventName, { detail, ...options }));\r\n    }\r\n    return target;\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 3. MANIPULATION (MODIFY & STYLE)\r\n// =============================================================================\r\n\r\n// =============================================================================\r\n// 3. MANIPULATION (MODIFY & STYLE)\r\n// =============================================================================\r\n\r\n/**\r\n * The core logic for applying properties to an element. Kept private.\r\n * @internal\r\n */\r\nconst _applyProps = <T extends HTMLElement>(element: T | null, props: ElementProps): T | null => {\r\n  if (!element) return null;\r\n\r\n  if (props.text !== undefined) element.innerText = props.text;\r\n  if (props.html !== undefined) element.innerHTML = props.html;\r\n  if (props.value !== undefined) (element as any).value = props.value;\r\n  if (props.disabled !== undefined) (element as any).disabled = props.disabled;\r\n\r\n  if (props.style) Object.assign(element.style, props.style);\r\n\r\n  if (props.dataset) {\r\n    Object.entries(props.dataset).forEach(([k, v]) => {\r\n      // Allow null/undefined to remove data attributes\r\n      if (v === null || v === undefined) {\r\n        delete element.dataset[k];\r\n      } else {\r\n        element.dataset[k] = String(v);\r\n      }\r\n    });\r\n  }\r\n\r\n  if (props.class) {\r\n    Object.entries(props.class).forEach(([k, v]) => element.classList.toggle(k, !!v));\r\n  }\r\n\r\n  if (props.attr) {\r\n    Object.entries(props.attr).forEach(([k, v]) => {\r\n      if (v === false || v === null || v === undefined) element.removeAttribute(k);\r\n      else element.setAttribute(k, String(v));\r\n    });\r\n  }\r\n\r\n  return element;\r\n};\r\n\r\n/**\r\n * Declaratively modifies an element's properties with full type safety.\r\n *\r\n * Provides a unified API for setting text, styles, classes, attributes, and more.\r\n * Supports three calling styles for maximum flexibility.\r\n *\r\n * @template T - The HTML element type, which is preserved.\r\n *\r\n * @overload\r\n * <caption>**1. Config-First (Curried):** `modify(props)(element)`</caption>\r\n * Best for creating reusable modifiers in functional pipelines.\r\n * @param props - The properties to apply.\r\n * @returns A function that accepts an element and returns it.\r\n * @example\r\n * ```typescript\r\n * import { Fn, find } from '@doeixd/dom';\r\n * \r\n * const makePrimary = modify({\r\n *   class: { 'btn-primary': true },\r\n *   attr: { 'aria-disabled': false }\r\n * });\r\n * \r\n * Fn.pipe(\r\n *   find('#submit-btn'),\r\n *   makePrimary\r\n * );\r\n * ```\r\n *\r\n * @overload\r\n * <caption>**2. Element-First (Curried):** `modify(element)(props)`</caption>\r\n * Best for applying multiple, separate modifications to the same element.\r\n * @param element - The element to modify (null-safe).\r\n * @returns A function that accepts properties and returns the element.\r\n * @example\r\n * ```typescript\r\n * const btn = find('button');\r\n * const modifyBtn = modify(btn);\r\n * \r\n * modifyBtn({ text: 'Step 1' });\r\n * // ... later\r\n * modifyBtn({ class: { success: true }, text: 'Complete' });\r\n * ```\r\n *\r\n * @overload\r\n * <caption>**3. Imperative:** `modify(element, props)`</caption>\r\n * Best for simple, one-off modifications. Cleanest syntax.\r\n * @param element - The element to modify (null-safe).\r\n * @param props - The properties to apply.\r\n * @returns The modified element.\r\n * @example\r\n * ```typescript\r\n * const btn = find('button');\r\n * modify(btn, { text: 'Click Me' });\r\n * ```\r\n */\r\nexport function modify<T extends HTMLElement>(props: ElementProps): (element: T | null) => T | null;\r\nexport function modify<T extends HTMLElement>(element: T | null, props: ElementProps): T | null;\r\nexport function modify<T extends HTMLElement>(element: T | null): (props: ElementProps) => T | null;\r\n\r\nexport function modify(\r\n  arg1: any,\r\n  arg2?: any\r\n): any {\r\n  const isElementFirst = arg1 instanceof HTMLElement || arg1 === null;\r\n\r\n  // Case 1: Config-First -> modify(props)\r\n  if (!isElementFirst) {\r\n    const props = arg1;\r\n    return (element: HTMLElement | null) => _applyProps(element, props);\r\n  }\r\n\r\n  // Case 2: Imperative -> modify(el, props)\r\n  if (arg2 !== undefined) {\r\n    const element = arg1;\r\n    const props = arg2;\r\n    return _applyProps(element, props);\r\n  }\r\n\r\n  // Case 3: Element-First Curried -> modify(el)\r\n  const element = arg1;\r\n  return (props: ElementProps) => _applyProps(element, props);\r\n}\r\n\r\n/** \r\n * Sets properties on an element.\r\n *  @alias modify \r\n */\r\nexport const set = modify;\r\n\r\n/**\r\n * Applies inline CSS styles to an element. Supports multiple calling styles.\r\n *\r\n * @overload <caption>**1. Config-First:** `css(styles)(element)`</caption>\r\n * @param styles - The CSS styles to apply.\r\n * @returns A function that accepts an element.\r\n *\r\n * @overload <caption>**2. Element-First:** `css(element)(styles)`</caption>\r\n * @param element - The element to style.\r\n * @returns A function that accepts styles.\r\n *\r\n * @overload <caption>**3. Imperative:** `css(element, styles)`</caption>\r\n * @param element - The element to style.\r\n * @param styles - The CSS styles to apply.\r\n */\r\nexport function css(\r\n  styles: Partial<CSSStyleDeclaration>\r\n): <T extends HTMLElement>(element: T | null) => T | null;\r\n\r\nexport function css<T extends HTMLElement>(\r\n  element: T | null,\r\n  styles: Partial<CSSStyleDeclaration>\r\n): T | null;\r\n\r\nexport function css<T extends HTMLElement>(\r\n  element: T | null\r\n): (styles: Partial<CSSStyleDeclaration>) => T | null;\r\n\r\nexport function css(\r\n  arg1: any,\r\n  arg2?: any\r\n): any {\r\n  const isElementFirst = arg1 instanceof HTMLElement || arg1 === null;\r\n\r\n  const applyCss = <T extends HTMLElement>(element: T | null, styles: Partial<CSSStyleDeclaration>) => {\r\n    if (element) Object.assign(element.style, styles);\r\n    return element;\r\n  };\r\n\r\n  if (!isElementFirst) {\r\n    const styles = arg1;\r\n    return (element: HTMLElement | null) => applyCss(element, styles);\r\n  }\r\n\r\n  if (arg2 !== undefined) {\r\n    const element = arg1;\r\n    const styles = arg2;\r\n    return applyCss(element, styles);\r\n  }\r\n\r\n  const element = arg1;\r\n  return (styles: Partial<CSSStyleDeclaration>) => applyCss(element, styles);\r\n}\r\n\r\n/**\r\n * Applies styles temporarily and returns a revert function.\r\n * \r\n * Saves the original style values and applies new ones. The returned function\r\n * restores the original values. Useful for temporary visual states like hover\r\n * effects or loading states.\r\n * \r\n * @param element - The element to style (null-safe)\r\n * @returns A curried function that accepts styles and returns a cleanup function\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Temporarily change opacity\r\n * const revert = tempStyle(div)({ opacity: '0.5' });\r\n * // Later...\r\n * revert(); // Restores original opacity\r\n * \r\n * // Loading state pattern\r\n * const showLoading = () => {\r\n *   const revert = tempStyle(button)({\r\n *     opacity: '0.6',\r\n *     pointerEvents: 'none',\r\n *     cursor: 'wait'\r\n *   });\r\n *   \r\n *   fetchData().finally(() => {\r\n *     revert(); // Restore original styles\r\n *   });\r\n * };\r\n * \r\n * // Animation workflow\r\n * const element = document.querySelector('.box');\r\n * const cleanup = tempStyle(element)({\r\n *   transform: 'scale(1.2)',\r\n *   transition: 'transform 0.3s'\r\n * });\r\n * setTimeout(cleanup, 300); // Revert after animation\r\n * \r\n * // Null-safe: returns no-op if element is null\r\n * const noop = tempStyle(null)({ color: 'red' }); // () => {}\r\n * ```\r\n */\r\nexport const tempStyle = (element: HTMLElement | null) => {\r\n  return (styles: Partial<CSSStyleDeclaration>): Unsubscribe => {\r\n    if (!element) return () => { };\r\n    const original: Record<string, string> = {};\r\n\r\n    // Save original values\r\n    Object.keys(styles).forEach((key) => {\r\n      original[key] = element.style[key as keyof CSSStyleDeclaration] as string;\r\n    });\r\n\r\n    Object.assign(element.style, styles);\r\n\r\n    return () => Object.assign(element.style, original);\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 4. STRUCTURE & TRAVERSAL\r\n// =============================================================================\r\n\r\n/**\r\n * Appends content to the end of the target element.\r\n *\r\n * Accepts multiple arguments of mixed types (strings, Nodes, null, undefined).\r\n * Strings are automatically converted to text nodes. Null/undefined values are\r\n * filtered out. Returns the parent for chaining.\r\n *\r\n * @param parent - The parent element to append to (null-safe)\r\n * @returns A curried function that accepts content and returns the parent\r\n *\r\n * @example\r\n * ```typescript\r\n * const list = document.querySelector('ul');\r\n *\r\n * // Imperative (cleaner DX)\r\n * append(list, item1, item2, item3);\r\n *\r\n * // Curried (pipeline friendly)\r\n * append(list)(item1, item2, item3);\r\n *\r\n * // Append a single element\r\n * const item = document.createElement('li');\r\n * append(list)(item);\r\n *\r\n * // Mix elements and text\r\n * append(container)(heading, 'Some text', paragraph);\r\n *\r\n * // Append text nodes\r\n * append(div)('Hello', ' ', 'World');\r\n *\r\n * // Null values are safely ignored\r\n * append(list)(item1, null, item2, undefined); // Only appends item1 and item2\r\n *\r\n * // Chaining\r\n * const parent = append(container)(child1);\r\n * append(parent)(child2);\r\n * ```\r\n */\r\nexport const append = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\r\n  parent?.append(..._nodes(content));\r\n  return parent;\r\n});\r\n\r\n/**\r\n * Prepends content to the start of the target element.\r\n *\r\n * Inserts content at the beginning, before any existing children. Accepts\r\n * multiple arguments of mixed types. Returns the parent for chaining.\r\n *\r\n * @param parent - The parent element to prepend to (null-safe)\r\n * @returns A curried function that accepts content and returns the parent\r\n *\r\n * @example\r\n * ```typescript\r\n * const list = document.querySelector('ul');\r\n *\r\n * // Imperative (cleaner DX)\r\n * prepend(list, firstItem);\r\n *\r\n * // Curried (pipeline friendly)\r\n * prepend(list)(firstItem);\r\n *\r\n * // Add header before content\r\n * const container = document.querySelector('.container');\r\n * const header = document.createElement('h1');\r\n * prepend(container)(header);\r\n * ```\r\n */\r\nexport const prepend = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\r\n  parent?.prepend(..._nodes(content));\r\n  return parent;\r\n});\r\n\r\n/**\r\n * Inserts content AFTER the target element as siblings.\r\n *\r\n * The content is inserted after the target in the DOM tree, at the same level.\r\n * Useful for inserting elements without modifying the target's children.\r\n *\r\n * @param target - The reference element (null-safe)\r\n * @returns A curried function that accepts content and returns the target\r\n *\r\n * @example\r\n * ```typescript\r\n * const header = document.querySelector('h1');\r\n * const banner = document.createElement('div');\r\n *\r\n * // Imperative (cleaner DX)\r\n * after(header, banner, notice, alert);\r\n *\r\n * // Curried (pipeline friendly)\r\n * after(header)(banner);\r\n *\r\n * // Insert multiple elements\r\n * after(header)(banner, notice, alert);\r\n * ```\r\n */\r\nexport const after = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\r\n  target?.after(..._nodes(content));\r\n  return target;\r\n});\r\n\r\n/**\r\n * Inserts content BEFORE the target element as siblings.\r\n *\r\n * The content is inserted before the target in the DOM tree, at the same level.\r\n *\r\n * @param target - The reference element (null-safe)\r\n * @returns A curried function that accepts content and returns the target\r\n *\r\n * @example\r\n * ```typescript\r\n * const footer = document.querySelector('footer');\r\n * const disclaimer = document.createElement('p');\r\n *\r\n * // Imperative (cleaner DX)\r\n * before(footer, disclaimer);\r\n *\r\n * // Curried (pipeline friendly)\r\n * before(footer)(disclaimer);\r\n * ```\r\n */\r\nexport const before = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\r\n  target?.before(..._nodes(content));\r\n  return target;\r\n});\r\n\r\n/**\r\n * Removes the target element from the DOM.\r\n * \r\n * Detaches the element from its parent. Event listeners attached via\r\n * addEventListener will be garbage collected. Always returns `null` for\r\n * type safety (prevents accidental reuse of removed elements).\r\n * \r\n * @param target - The element to remove (null-safe)\r\n * @returns Always returns `null`\r\n * \r\n * @example\r\n * ```typescript\r\n * const modal = document.querySelector('.modal');\r\n * remove(modal); // Modal is removed from DOM\r\n * \r\n * // Conditional removal\r\n * if (shouldRemove) {\r\n *   remove(element);\r\n * }\r\n * ```\r\n */\r\nexport const remove = (target: Element | null) => {\r\n  target?.remove();\r\n  return null;\r\n};\r\n\r\n/**\r\n * Removes all children from the target element.\r\n * \r\n * More efficient than `innerHTML = ''` and safer (doesn't parse HTML).\r\n * Returns the target for chaining.\r\n * \r\n * @param target - The element to empty (null-safe)\r\n * @returns The target element\r\n * \r\n * @example\r\n * ```typescript\r\n * const container = document.querySelector('.container');\r\n * \r\n * // Clear all content\r\n * empty(container);\r\n * \r\n * // Then add new content\r\n * append(empty(container))(newContent);\r\n * ```\r\n */\r\nexport const empty = (target: Element | null) => {\r\n  if (target) target.replaceChildren();\r\n  return target;\r\n};\r\n\r\n/**\r\n * Wraps the target element with a wrapper element.\r\n *\r\n * Inserts the wrapper before the target in the DOM, then moves the target\r\n * inside the wrapper. Useful for adding container elements around existing\r\n * content.\r\n *\r\n * @param target - The element to wrap (null-safe)\r\n * @returns A curried function that accepts a wrapper and returns it\r\n *\r\n * @example\r\n * ```typescript\r\n * const img = document.querySelector('img');\r\n * const figure = document.createElement('figure');\r\n *\r\n * // Imperative (cleaner DX)\r\n * wrap(img, figure);\r\n *\r\n * // Curried (pipeline friendly)\r\n * wrap(img)(figure);\r\n * // DOM: <figure><img /></figure>\r\n *\r\n * // Using el() helper\r\n * wrap(img)(el('figure')({})([]));\r\n *\r\n * // Add caption to wrapper\r\n * const wrapper = wrap(img)(figure);\r\n * append(wrapper)(el('figcaption')({})(['Image caption']));\r\n * ```\r\n */\r\nexport const wrap = def((target: HTMLElement | null, wrapper: HTMLElement) => {\r\n  if (target && wrapper && target.parentNode) {\r\n    target.parentNode.insertBefore(wrapper, target);\r\n    wrapper.appendChild(target);\r\n  }\r\n  return wrapper;\r\n});\r\n\r\n/**\r\n * Mounts a child element into a parent container.\r\n *\r\n * Appends the child to the parent and returns a cleanup function to remove it.\r\n * Useful for dynamic DOM updates, modals, popovers, and temporary UI elements.\r\n *\r\n * Supports two call styles:\r\n * 1. `mount(parent, child)` â€” Imperative (cleaner DX)\r\n * 2. `mount(parent)(child)` â€” Curried (pipeline friendly)\r\n *\r\n * @overload\r\n * @param parent - Parent element or selector (null-safe)\r\n * @param child - Child element to mount (or null for curried)\r\n * @returns Cleanup function to unmount the child, or no-op if parent not found\r\n *\r\n * @example\r\n * ```typescript\r\n * // Imperative style\r\n * const modal = document.createElement('div');\r\n * modal.textContent = 'Hello World';\r\n * const cleanup = mount(document.body, modal);\r\n *\r\n * // Later: remove the element\r\n * cleanup();\r\n *\r\n * // Using selector-first API\r\n * const popup = el('div')({ class: { popup: true } })(['Content']);\r\n * const remove = mount(\".container\")(popup);\r\n *\r\n * // Mounting multiple elements\r\n * const list = document.querySelector('ul');\r\n * const items = [el('li')({})(['Item 1']), el('li')({})(['Item 2'])];\r\n * const cleanups = items.map(item => mount(list)(item));\r\n *\r\n * // With temporary modal\r\n * const showModal = (content: string) => {\r\n *   const modal = el('div')({\r\n *     class: { modal: true },\r\n *     attr: { role: 'dialog' }\r\n *   })([content]);\r\n *\r\n *   const cleanup = mount(document.body)(modal);\r\n *\r\n *   // Auto-cleanup on button click\r\n *   modal.addEventListener('click', () => cleanup());\r\n *   return cleanup;\r\n * };\r\n * ```\r\n */\r\nexport const mount = def((parent: Element | string | null, child: Element | null): Unsubscribe => {\r\n  if (!child) return () => { };\r\n\r\n  const parentEl = typeof parent === 'string' ? document.querySelector(parent) : parent;\r\n  if (!parentEl) return () => { };\r\n\r\n  parentEl.appendChild(child);\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    if (child.parentNode === parentEl) {\r\n      parentEl.removeChild(child);\r\n    }\r\n  };\r\n});\r\n\r\n// =============================================================================\r\n// 5. CREATION & TEMPLATES\r\n// =============================================================================\r\n\r\nexport interface CreateWebComponentOptions {\r\n  /** Optional custom element name (overrides class name). */\r\n  name?: string;\r\n  /** Auto-define the component (default: true). */\r\n  define?: boolean;\r\n  /** Options passed to `customElements.define`. */\r\n  defineOptions?: ElementDefinitionOptions;\r\n}\r\n\r\n/**\r\n * Registers a custom element with smart defaults and flexible call styles.\r\n *\r\n * Defaults to a kebab-case name derived from the class name. If the derived\r\n * name lacks a hyphen, `-el` is appended to make it valid.\r\n *\r\n * Supports both call styles:\r\n * - `createWebComponent(MyElement, options?)`\r\n * - `createWebComponent(options?)(MyElement)`\r\n *\r\n * @template T - Custom element constructor\r\n * @param ctor - Custom element class\r\n * @param options - Optional registration configuration\r\n * @returns Metadata about the registration\r\n *\r\n * @example\r\n * ```typescript\r\n * class MyButton extends HTMLElement {}\r\n * const { name } = createWebComponent(MyButton);\r\n * // name === 'my-button'\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * class FancyInput extends HTMLInputElement {}\r\n * createWebComponent(FancyInput, {\r\n *   name: 'fancy-input',\r\n *   defineOptions: { extends: 'input' }\r\n * });\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * class ModalDialog extends HTMLElement {}\r\n * const register = createWebComponent({ define: false, name: 'modal-dialog' });\r\n * const info = register(ModalDialog);\r\n * // info.defined === false\r\n * ```\r\n */\r\nexport function createWebComponent<T extends CustomElementConstructor>(\r\n  ctor: T,\r\n  options?: CreateWebComponentOptions\r\n): { name: string; ctor: T; defined: boolean };\r\n\r\nexport function createWebComponent(\r\n  options?: CreateWebComponentOptions\r\n): <T extends CustomElementConstructor>(ctor: T) => { name: string; ctor: T; defined: boolean };\r\n\r\nexport function createWebComponent(\r\n  arg1?: CreateWebComponentOptions | CustomElementConstructor,\r\n  arg2?: CreateWebComponentOptions\r\n) {\r\n  const toKebab = (value: string) =>\r\n    value\r\n      .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\r\n      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')\r\n      .replace(/[_\\s]+/g, '-')\r\n      .toLowerCase();\r\n\r\n  const build = <T extends CustomElementConstructor>(\r\n    ctor: T,\r\n    options: CreateWebComponentOptions = {}\r\n  ) => {\r\n    const rawName = options.name ?? toKebab(ctor.name ?? '');\r\n    if (!rawName) {\r\n      throw new Error('createWebComponent: name is required for anonymous classes.');\r\n    }\r\n\r\n    const name = rawName.includes('-') ? rawName : `${rawName}-el`;\r\n    const shouldDefine = options.define !== false;\r\n    const registry = typeof customElements === 'undefined' ? undefined : customElements;\r\n    const alreadyDefined = registry?.get(name);\r\n\r\n    if (shouldDefine) {\r\n      if (!registry) {\r\n        throw new Error('createWebComponent: customElements is not available in this environment.');\r\n      }\r\n      if (!alreadyDefined) {\r\n        registry.define(name, ctor, options.defineOptions);\r\n      }\r\n    }\r\n\r\n    return {\r\n      name,\r\n      ctor,\r\n      defined: shouldDefine ? true : !!alreadyDefined\r\n    };\r\n  };\r\n\r\n  if (typeof arg1 === 'function') {\r\n    return build(arg1, arg2);\r\n  }\r\n\r\n  const options = arg1 ?? {};\r\n  return (ctor: CustomElementConstructor) => build(ctor, options);\r\n}\r\n\r\n/**\r\n * Creates a DOM element with full type inference.\r\n * \r\n * Supports two syntaxes:\r\n * 1. **Hyperscript-style**: `el(tag, props, children)` â€” cleaner, more readable\r\n * 2. **Curried**: `el(tag)(props)(children)` â€” composable, pipeline-friendly\r\n * \r\n * The return type is automatically inferred from the tag name.\r\n * \r\n * @template K - The HTML tag name (keyof HTMLElementTagNameMap)\r\n * @param tag - The HTML tag name (e.g., 'div', 'button', 'a')\r\n * @param props - Optional properties (text, classes, attributes, etc.)\r\n * @param children - Optional children (elements or text)\r\n * @returns The created element (Hyperscript) or curried function (Curried)\r\n * \r\n * @example\r\n * ```typescript\r\n * // Hyperscript-style (new, cleaner)\r\n * const btn = el('button', { class: { primary: true } }, ['Click me']);\r\n * // btn is typed as HTMLButtonElement\r\n * \r\n * // Nested elements (much more readable)\r\n * const card = el('div', { class: { card: true } }, [\r\n *   el('h2', {}, ['Title']),\r\n *   el('p', {}, ['Description'])\r\n * ]);\r\n * \r\n * // Curried syntax (still supported for backward compatibility)\r\n * const link = el('a')({\r\n *   attr: { href: '/home' },\r\n *   class: { active: true },\r\n *   text: 'Home'\r\n * })([]);\r\n * // link is typed as HTMLAnchorElement\r\n * \r\n * // Form input with type inference\r\n * const input = el('input', {\r\n *   attr: { type: 'text', placeholder: 'Enter name' },\r\n *   value: 'John'\r\n * }, []);\r\n * // input is typed as HTMLInputElement\r\n * \r\n * // Partial application for reuse (curried)\r\n * const createButton = el('button');\r\n * const primaryBtn = createButton({ class: { primary: true } })(['Save']);\r\n * const secondaryBtn = createButton({ class: { secondary: true } })(['Cancel']);\r\n * ```\r\n */\r\nexport function el<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  props: ElementProps,\r\n  children: (string | Node)[]\r\n): HTMLElementTagNameMap[K];\r\n\r\nexport function el<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K\r\n): (props?: ElementProps) => (children?: (string | Node)[]) => HTMLElementTagNameMap[K];\r\n\r\nexport function el<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  props?: ElementProps,\r\n  children?: (string | Node)[]\r\n): any {\r\n  // Hyperscript-style: el(tag, props, children)\r\n  if (props !== undefined && children !== undefined) {\r\n    const node = document.createElement(tag);\r\n    modify(node)(props);\r\n    node.append(..._nodes(children));\r\n    return node;\r\n  }\r\n\r\n  // Curried syntax: el(tag)(props)(children)\r\n  return (propsArg: ElementProps = {}) => {\r\n    return (childrenArg: (string | Node)[] = []): HTMLElementTagNameMap[K] => {\r\n      const node = document.createElement(tag);\r\n      modify(node)(propsArg);\r\n      node.append(..._nodes(childrenArg));\r\n      return node;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Creates an element from an HTML template string.\r\n * \r\n * Uses tagged template literals for convenient HTML creation. Interpolated\r\n * values are automatically escaped. Returns the first element in the template.\r\n * \r\n * âš ï¸ **XSS Warning**: Only use with trusted content. Do not interpolate\r\n * user input directly without sanitization.\r\n * \r\n * @param strings - Template string parts\r\n * @param values - Interpolated values\r\n * @returns The created HTMLElement\r\n * @throws Error if template doesn't produce an element\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const div = html`<div class=\"container\">Hello</div>`;\r\n * \r\n * // With interpolation\r\n * const name = 'World';\r\n * const greeting = html`<h1>Hello ${name}!</h1>`;\r\n * \r\n * // Complex structure\r\n * const card = html`\r\n *   <div class=\"card\">\r\n *     <h2>${title}</h2>\r\n *     <p>${description}</p>\r\n *   </div>\r\n * `;\r\n * \r\n * // âš ï¸ UNSAFE - Don't do this with user input!\r\n * // const unsafe = html`<div>${userInput}</div>`;\r\n * \r\n * // âœ… SAFE - Sanitize user input first\r\n * const safe = html`<div>${sanitize(userInput)}</div>`;\r\n * ```\r\n */\r\nexport const html = (strings: TemplateStringsArray, ...values: any[]): HTMLElement => {\r\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = str.trim();\r\n  const el = tpl.content.firstElementChild;\r\n  if (!el) throw new Error('html: Template did not result in an element');\r\n  return el as HTMLElement;\r\n};\r\n\r\n/**\r\n * Creates a DocumentFragment from an HTML template string.\r\n * \r\n * Like `html()` but returns a DocumentFragment containing all elements\r\n * from the template. Useful for creating multiple sibling elements at once.\r\n * \r\n * âš ï¸ **XSS Warning**: Only use with trusted content.\r\n * \r\n * @param strings - Template string parts\r\n * @param values - Interpolated values\r\n * @returns A DocumentFragment containing the created elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // Create multiple list items\r\n * const items = htmlMany`\r\n *   <li>Item 1</li>\r\n *   <li>Item 2</li>\r\n *   <li>Item 3</li>\r\n * `;\r\n * \r\n * const list = document.querySelector('ul');\r\n * list.appendChild(items);\r\n * \r\n * // With interpolation\r\n * const rows = htmlMany`\r\n *   <tr><td>${col1}</td><td>${col2}</td></tr>\r\n *   <tr><td>${col3}</td><td>${col4}</td></tr>\r\n * `;\r\n * ```\r\n */\r\nexport const htmlMany = (strings: TemplateStringsArray, ...values: any[]): DocumentFragment => {\r\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = str.trim();\r\n  return tpl.content;\r\n};\r\n\r\n/**\r\n * Clones a node, preserving its exact type.\r\n * \r\n * Creates a copy of the node and optionally its descendants. The cloned node\r\n * has no parent and is not part of the document. Event listeners are NOT\r\n * copied.\r\n * \r\n * @template T - The node type (preserved in return type)\r\n * @param node - The node to clone (null-safe)\r\n * @returns A curried function that accepts deep flag and returns the clone\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Deep clone (includes children)\r\n * const btnCopy = clone(button)(true);\r\n * // btnCopy is typed as HTMLButtonElement\r\n * \r\n * // Shallow clone (no children)\r\n * const btnShallow = clone(button)(false);\r\n * \r\n * // Template pattern\r\n * const template = el('div')({ class: { card: true } })([\r\n *   el('h2')({})(['Title']),\r\n *   el('p')({})(['Description'])\r\n * ]);\r\n * \r\n * // Create multiple cards from template\r\n * const card1 = clone(template)(true);\r\n * const card2 = clone(template)(true);\r\n * const card3 = clone(template)(true);\r\n * \r\n * // Null-safe\r\n * const missing = document.querySelector('.missing');\r\n * const result = clone(missing)(true); // null\r\n * ```\r\n */\r\nexport const clone = <T extends Node>(node: T | null) => {\r\n  return (deep: boolean = true): T | null => {\r\n    return node ? (node.cloneNode(deep) as T) : null;\r\n  };\r\n};\r\n\r\n/**\r\n * SVG element tags that require special namespace handling.\r\n * All tags are stored in lowercase for case-insensitive matching.\r\n * @internal\r\n */\r\nconst svgElementTags = new Set<string>([\r\n  'svg', 'g', 'path', 'circle', 'rect', 'line', 'polygon',\r\n  'polyline', 'ellipse', 'text', 'tspan', 'defs', 'clippath',\r\n  'lineargradient', 'radialgradient', 'stop', 'mask', 'pattern',\r\n  'marker', 'symbol', 'use', 'image', 'foreignobject'\r\n]);\r\n\r\n/**\r\n * VanJS-style hyperscript proxy for element creation.\r\n *\r\n * Provides a Proxy-based API where property access creates element factories.\r\n * Supports both HTML and SVG elements with automatic namespace detection.\r\n *\r\n * **Performance Note**: The Proxy has minimal overhead (~5% vs direct el() calls).\r\n * For performance-critical loops with 1000s of elements, prefer el() directly.\r\n *\r\n * **Type Safety**: Returns `HTMLElement` rather than specific element types due to\r\n * Proxy limitations. Use type assertions if you need specific element types.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { h } from '@doeixd/dom';\r\n *\r\n * // Basic HTML elements\r\n * const card = h.div({ class: { card: true } }, [\r\n *   h.h2({}, ['Title']),\r\n *   h.p({ text: 'Content' }),\r\n *   h.button({ dataRef: 'submit' }, ['Submit'])\r\n * ]);\r\n *\r\n * // SVG elements (automatically use SVG namespace)\r\n * const icon = h.svg({ attr: { viewBox: '0 0 24 24', width: '24', height: '24' } }, [\r\n *   h.path({ attr: { d: 'M12 2L2 7v10c0 5.5 3.8 10.7 10 12 6.2-1.3 10-6.5 10-12V7l-10-5z' } })\r\n * ]);\r\n *\r\n * // Nested structures\r\n * const list = h.ul({ class: { 'todo-list': true } }, [\r\n *   h.li({}, ['Item 1']),\r\n *   h.li({}, ['Item 2']),\r\n *   h.li({}, ['Item 3'])\r\n * ]);\r\n *\r\n * // With refs for later access\r\n * const form = h.form({}, [\r\n *   h.input({ dataRef: 'name', attr: { type: 'text', placeholder: 'Name' } }),\r\n *   h.input({ dataRef: 'email', attr: { type: 'email', placeholder: 'Email' } }),\r\n *   h.button({ dataRef: 'submit', attr: { type: 'submit' } }, ['Submit'])\r\n * ]);\r\n *\r\n * // Extract refs\r\n * const formRefs = refs(form);\r\n * console.log(formRefs.name, formRefs.email, formRefs.submit);\r\n * ```\r\n */\r\nexport const h = new Proxy({} as Record<string, (props?: HElementProps, children?: (string | Node)[]) => HTMLElement>, {\r\n  get(_target, tag: string) {\r\n    if (typeof tag !== 'string') return undefined;\r\n\r\n    // Validate tag name (alphanumeric, starting with letter)\r\n    if (!/^[a-z][a-z0-9]*$/i.test(tag)) {\r\n      throw new Error(`h: Invalid tag name \"${tag}\". Tag names must start with a letter and contain only letters and numbers.`);\r\n    }\r\n\r\n    return (props: HElementProps = {}, children: (string | Node)[] = []) => {\r\n      // Extract dataRef prop separately to avoid passing it to modify()\r\n      const { dataRef, ...restProps } = props;\r\n\r\n      // Create element with appropriate namespace\r\n      const isSVG = svgElementTags.has(tag.toLowerCase());\r\n      const element = isSVG\r\n        ? document.createElementNS('http://www.w3.org/2000/svg', tag)\r\n        : document.createElement(tag);\r\n\r\n      // Apply properties\r\n      if (Object.keys(restProps).length > 0) {\r\n        // For SVG elements, handle common props directly to ensure proper namespace handling\r\n        if (isSVG) {\r\n          // Handle attributes\r\n          if (restProps.attr) {\r\n            Object.entries(restProps.attr).forEach(([key, value]) => {\r\n              if (value === false || value === null || value === undefined) {\r\n                element.removeAttribute(key);\r\n              } else {\r\n                element.setAttribute(key, String(value));\r\n              }\r\n            });\r\n          }\r\n\r\n          // Handle classes\r\n          if (restProps.class) {\r\n            Object.entries(restProps.class).forEach(([className, isActive]) => {\r\n              if (isActive) {\r\n                element.classList.add(className);\r\n              } else {\r\n                element.classList.remove(className);\r\n              }\r\n            });\r\n          }\r\n\r\n          // Handle style\r\n          if (restProps.style) {\r\n            Object.assign((element as HTMLElement).style, restProps.style);\r\n          }\r\n\r\n          // Handle text and html\r\n          if (restProps.text !== undefined) {\r\n            element.textContent = restProps.text;\r\n          }\r\n          if (restProps.html !== undefined) {\r\n            element.innerHTML = restProps.html;\r\n          }\r\n        } else {\r\n          // For HTML elements, use modify for everything\r\n          modify(element as HTMLElement, restProps);\r\n        }\r\n      }\r\n\r\n      // Set data-ref attribute if provided\r\n      if (dataRef) {\r\n        element.setAttribute('data-ref', dataRef);\r\n      }\r\n\r\n      // Append children if any\r\n      if (children.length > 0) {\r\n        element.append(..._nodes(children));\r\n      }\r\n\r\n      return element as HTMLElement;\r\n    };\r\n  }\r\n});\r\n\r\n/**\r\n * Alias for `h` proxy. Provides alternative naming for hyperscript-style element creation.\r\n *\r\n * Some developers prefer `tags` as it's more explicit about creating HTML tags.\r\n * Functionally identical to `h`.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { tags } from '@doeixd/dom';\r\n *\r\n * const page = tags.div({ class: { container: true } }, [\r\n *   tags.header({}, [tags.h1({}, ['My App'])]),\r\n *   tags.main({}, [tags.p({}, ['Content'])]),\r\n *   tags.footer({}, [tags.small({}, ['Â© 2024'])])\r\n * ]);\r\n * ```\r\n */\r\nexport const tags = h;\r\n\r\n// =============================================================================\r\n// 6. CLASS MANIPULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for manipulating CSS classes on elements.\r\n * \r\n * All methods are null-safe and return the element for chaining (except `has`).\r\n * Provides a functional API for common classList operations.\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Add multiple classes\r\n * cls.add(button)('btn', 'btn-primary', 'active');\r\n * \r\n * // Remove classes\r\n * cls.remove(button)('disabled', 'loading');\r\n * \r\n * // Toggle with optional force\r\n * cls.toggle(button)('active'); // Toggles\r\n * cls.toggle(button)('active', true); // Forces add\r\n * cls.toggle(button)('active', false); // Forces remove\r\n * \r\n * // Replace a class\r\n * cls.replace(button)('btn-primary', 'btn-secondary');\r\n * \r\n * // Check for class\r\n * if (cls.has(button)('active')) {\r\n *   console.log('Button is active');\r\n * }\r\n * \r\n * // Chaining\r\n * cls.add(button)('btn');\r\n * cls.toggle(button)('active');\r\n * ```\r\n */\r\nexport const cls = {\r\n  /**\r\n   * Adds one or more CSS classes to the element.\r\n   *\r\n   * @param el - The element to add classes to (null-safe)\r\n   * @returns A curried function that accepts class names and returns the element\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Imperative (cleaner DX)\r\n   * cls.add(btn, 'active', 'shadow');\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * cls.add(btn)('active', 'shadow');\r\n   *\r\n   * // Add single class\r\n   * cls.add(div)('active');\r\n   *\r\n   * // Add multiple classes\r\n   * cls.add(div)('card', 'shadow', 'rounded');\r\n   *\r\n   * // Null-safe\r\n   * cls.add(null)('active'); // Returns null\r\n   * ```\r\n   */\r\n  add: def((el: Element | null, ...classes: string[]) => {\r\n    el?.classList.add(...classes);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Removes one or more CSS classes from the element.\r\n   *\r\n   * @param el - The element to remove classes from (null-safe)\r\n   * @returns A curried function that accepts class names and returns the element\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Imperative (cleaner DX)\r\n   * cls.remove(btn, 'active', 'shadow');\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * cls.remove(btn)('active', 'shadow');\r\n   *\r\n   * // Remove single class\r\n   * cls.remove(div)('active');\r\n   *\r\n   * // Remove multiple classes\r\n   * cls.remove(div)('loading', 'disabled', 'error');\r\n   *\r\n   * // Safe if class doesn't exist\r\n   * cls.remove(div)('nonexistent'); // No error\r\n   * ```\r\n   */\r\n  remove: def((el: Element | null, ...classes: string[]) => {\r\n    el?.classList.remove(...classes);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Toggles a CSS class on the element.\r\n   *\r\n   * @param el - The element to toggle the class on (null-safe)\r\n   * @returns A curried function that accepts class name and optional force flag\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Imperative (cleaner DX)\r\n   * cls.toggle(btn, 'active');\r\n   * cls.toggle(btn, 'active', true); // Force add\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * cls.toggle(btn)('active'); // Adds if absent, removes if present\r\n   * cls.toggle(btn)('active', true); // Always adds\r\n   * cls.toggle(btn)('active', false); // Always removes\r\n   *\r\n   * // Conditional toggle\r\n   * cls.toggle(button)('disabled', isLoading);\r\n   * ```\r\n   */\r\n  toggle: def((el: Element | null, className: string, force?: boolean) => {\r\n    el?.classList.toggle(className, force);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Replaces an old class with a new class.\r\n   *\r\n   * @param el - The element to modify (null-safe)\r\n   * @returns A curried function that accepts old and new class names\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Imperative (cleaner DX)\r\n   * cls.replace(btn, 'btn-primary', 'btn-secondary');\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * cls.replace(btn)('btn-primary', 'btn-secondary');\r\n   *\r\n   * // Replace theme class\r\n   * cls.replace(div)('theme-light', 'theme-dark');\r\n   *\r\n   * // No effect if old class doesn't exist\r\n   * cls.replace(div)('nonexistent', 'new'); // No change\r\n   * ```\r\n   */\r\n  replace: def((el: Element | null, oldClass: string, newClass: string) => {\r\n    el?.classList.replace(oldClass, newClass);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Checks if the element has a specific class.\r\n   * \r\n   * @param el - The element to check (null-safe)\r\n   * @returns A curried function that accepts a class name and returns boolean\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const button = document.querySelector('button');\r\n   * \r\n   * // Check for class\r\n   * if (cls.has(button)('active')) {\r\n   *   console.log('Button is active');\r\n   * }\r\n   * \r\n   * // Conditional logic\r\n   * const isDisabled = cls.has(button)('disabled');\r\n   * \r\n   * // Null-safe: returns false if element is null\r\n   * cls.has(null)('active'); // false\r\n   * ```\r\n   */\r\n  has: (el: Element | null) => (className: string) => {\r\n    return !!el && el.classList.contains(className);\r\n  }\r\n};\r\n\r\n/**\r\n * Observes changes to a specific class on an element.\r\n *\r\n * Uses MutationObserver to watch for class attribute changes. The callback\r\n * fires only when the specified class is added or removed (not on other class\r\n * changes). Returns a cleanup function to stop observing.\r\n *\r\n * **Performance**: Uses attribute filtering for efficiency. Consider debouncing\r\n * the callback if rapid changes are expected.\r\n *\r\n * @param target - The element to observe (null-safe)\r\n * @returns A curried function that accepts class name and callback, returns cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const modal = document.querySelector('.modal');\r\n *\r\n * // Imperative (cleaner DX)\r\n * const cleanup = watchClass(modal, 'open', (isPresent, el) => {\r\n *   if (isPresent) {\r\n *     console.log('Modal opened');\r\n *     document.body.style.overflow = 'hidden';\r\n *   } else {\r\n *     console.log('Modal closed');\r\n *     document.body.style.overflow = '';\r\n *   }\r\n * });\r\n *\r\n * // Curried (pipeline friendly)\r\n * const cleanup = watchClass(modal)('open', (isPresent, el) => {\r\n *   if (isPresent) {\r\n *     console.log('Modal opened');\r\n *     document.body.style.overflow = 'hidden';\r\n *   } else {\r\n *     console.log('Modal closed');\r\n *     document.body.style.overflow = '';\r\n *   }\r\n * });\r\n *\r\n * // Later: stop watching\r\n * cleanup();\r\n *\r\n * // Watch loading state\r\n * watchClass(button)('loading', (isLoading) => {\r\n *   button.disabled = isLoading;\r\n * });\r\n *\r\n * // Sync state between elements\r\n * watchClass(sidebar)('collapsed', (isCollapsed) => {\r\n *   cls.toggle(mainContent)('expanded', isCollapsed);\r\n * });\r\n *\r\n * // Null-safe: returns no-op cleanup\r\n * const noop = watchClass(null)('active', callback); // () => {}\r\n * ```\r\n */\r\nexport const watchClass = def((target: Element | null, className: string, callback: (isPresent: boolean, el: Element) => void): Unsubscribe => {\r\n  if (!target) return () => { };\r\n  let was = target.classList.contains(className);\r\n  const obs = new MutationObserver(() => {\r\n    const is = target.classList.contains(className);\r\n    if (is !== was) { was = is; callback(is, target); }\r\n  });\r\n  obs.observe(target, { attributes: true, attributeFilter: ['class'] });\r\n  return () => obs.disconnect();\r\n});\r\n\r\n\r\n// =============================================================================\r\n// 7. DATASET & ATTRIBUTES\r\n// =============================================================================\r\n\r\nconst toDataAttr = (str: string) => 'data-' + str.replace(/[A-Z]/g, m => \"-\" + m.toLowerCase());\r\n\r\n/**\r\n * Utilities for working with data attributes (data-*).\r\n * \r\n * Provides a functional API for getting, setting, and observing data attributes.\r\n * Automatically handles type conversion (numbers, booleans, JSON) and camelCase\r\n * to kebab-case conversion.\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Set data attributes\r\n * Data.set(div)('userId', 123);        // data-user-id=\"123\"\r\n * Data.set(div)('isActive', true);     // data-is-active=\"true\"\r\n * Data.set(div)('config', { a: 1 });   // data-config='{\"a\":1}'\r\n * \r\n * // Get raw string value\r\n * const userId = Data.get(div)('userId'); // \"123\"\r\n * \r\n * // Read with type inference\r\n * const id = Data.read(div)('userId');     // 123 (number)\r\n * const active = Data.read(div)('isActive'); // true (boolean)\r\n * const config = Data.read(div)('config');   // { a: 1 } (object)\r\n * \r\n * // React to changes\r\n * Data.bind(div)('count', (value) => {\r\n *   console.log('Count changed:', value);\r\n * });\r\n * ```\r\n */\r\nexport const Data = {\r\n  /**\r\n   * Gets the raw string value of a data attribute.\r\n   * \r\n   * Returns the value as-is from the dataset. For type conversion, use `read()`.\r\n   * \r\n   * @template T - The element type (inferred)\r\n   * @param el - The element to get data from (null-safe)\r\n   * @returns A curried function that accepts a key and returns the value or undefined\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * div.dataset.userId = '123';\r\n   * \r\n   * // Get raw value\r\n   * const userId = Data.get(div)('userId'); // \"123\" (string)\r\n   * \r\n   * // CamelCase key\r\n   * const userName = Data.get(div)('userName'); // Accesses data-user-name\r\n   * \r\n   * // Missing attribute\r\n   * const missing = Data.get(div)('missing'); // undefined\r\n   * \r\n   * // Null-safe\r\n   * Data.get(null)('userId'); // undefined\r\n   * ```\r\n   */\r\n  get: (el: HTMLElement | null) => (key: string) => el?.dataset[key],\r\n\r\n  /**\r\n   * Sets a data attribute value.\r\n   *\r\n   * Automatically converts objects to JSON strings and handles null/undefined\r\n   * by removing the attribute. CamelCase keys are converted to kebab-case.\r\n   *\r\n   * @template T - The element type (inferred)\r\n   * @param el - The element to set data on (null-safe)\r\n   * @returns A curried function that accepts key and value, returns the element\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   *\r\n   * // Imperative (cleaner DX)\r\n   * Data.set(div, 'userId', '123');\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * Data.set(div)('userId', '123');\r\n   *\r\n   * // Set number (converted to string)\r\n   * Data.set(div)('count', 42); // data-count=\"42\"\r\n   *\r\n   * // Set boolean\r\n   * Data.set(div)('isActive', true); // data-is-active=\"true\"\r\n   *\r\n   * // Set object (JSON stringified)\r\n   * Data.set(div)('config', { theme: 'dark', size: 'lg' });\r\n   * // data-config='{\"theme\":\"dark\",\"size\":\"lg\"}'\r\n   *\r\n   * // Remove attribute (null or undefined)\r\n   * Data.set(div)('userId', null); // Removes data-user-id\r\n   *\r\n   * // CamelCase to kebab-case\r\n   * Data.set(div)('userName', 'John'); // Sets data-user-name=\"John\"\r\n   *\r\n   * // Chaining\r\n   * Data.set(div)('id', 1);\r\n   * Data.set(div)('name', 'Item');\r\n   * ```\r\n   */\r\n  set: def((el: HTMLElement | null, key: string, val: any) => {\r\n    if (!el) return el;\r\n    if (val == null) delete el.dataset[key];\r\n    else el.dataset[key] = typeof val === 'object' ? JSON.stringify(val) : String(val);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Reads a data attribute with automatic type inference.\r\n   * \r\n   * Intelligently parses the value:\r\n   * - `\"true\"` â†’ `true` (boolean)\r\n   * - `\"false\"` â†’ `false` (boolean)\r\n   * - `\"null\"` â†’ `null`\r\n   * - `\"123\"` â†’ `123` (number)\r\n   * - `'{\"a\":1}'` â†’ `{a:1}` (parsed JSON)\r\n   * - Other â†’ string\r\n   * \r\n   * @template T - The expected return type\r\n   * @param el - The element to read from (null-safe)\r\n   * @returns A curried function that accepts a key and returns the parsed value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Boolean parsing\r\n   * div.dataset.isActive = 'true';\r\n   * Data.read(div)('isActive'); // true (boolean)\r\n   * \r\n   * // Number parsing\r\n   * div.dataset.count = '42';\r\n   * Data.read(div)('count'); // 42 (number)\r\n   * \r\n   * // JSON parsing\r\n   * div.dataset.config = '{\"theme\":\"dark\"}';\r\n   * Data.read(div)('config'); // { theme: 'dark' }\r\n   * \r\n   * // String fallback\r\n   * div.dataset.name = 'John';\r\n   * Data.read(div)('name'); // \"John\" (string)\r\n   * \r\n   * // Missing attribute\r\n   * Data.read(div)('missing'); // undefined\r\n   * \r\n   * // Type-safe usage\r\n   * interface Config { theme: string; size: string; }\r\n   * const config = Data.read<Config>(div)('config');\r\n   * ```\r\n   */\r\n  read: (el: HTMLElement | null) => (key: string): any => {\r\n    if (!el || !(key in (el.dataset || {}))) return undefined;\r\n    const val = el.dataset[key]!;\r\n    if (val === 'true') return true;\r\n    if (val === 'false') return false;\r\n    if (val === 'null') return null;\r\n    if (!isNaN(Number(val)) && val.trim() !== '') return Number(val);\r\n    if (val.startsWith('{') || val.startsWith('[')) {\r\n      try { return JSON.parse(val); } catch { return val; }\r\n    }\r\n    return val;\r\n  },\r\n\r\n  /**\r\n   * Observes changes to a data attribute and fires a callback.\r\n   *\r\n   * Uses MutationObserver to watch for attribute changes. The callback fires\r\n   * immediately with the current value, then on every change. Values are\r\n   * automatically parsed using `Data.read()`.\r\n   *\r\n   * @template T - The expected value type\r\n   * @param el - The element to observe (null-safe)\r\n   * @returns A curried function that accepts key and callback, returns cleanup function\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   *\r\n   * // Imperative (cleaner DX)\r\n   * const cleanup = Data.bind(div, 'count', (value, el) => {\r\n   *   console.log('Count is now:', value);\r\n   * });\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * const cleanup = Data.bind(div)('count', (value, el) => {\r\n   *   console.log('Count is now:', value);\r\n   *   // Fires immediately with current value\r\n   *   // Then fires on every change\r\n   * });\r\n   *\r\n   * // Later: stop watching\r\n   * cleanup();\r\n   *\r\n   * // Form validation example\r\n   * Data.bind(input)('validationError', (error) => {\r\n   *   if (error) {\r\n   *     errorDisplay.textContent = error;\r\n   *     errorDisplay.style.display = 'block';\r\n   *   } else {\r\n   *     errorDisplay.style.display = 'none';\r\n   *   }\r\n   * });\r\n   *\r\n   * // Sync state between components\r\n   * Data.bind(slider)('value', (value) => {\r\n   *   valueDisplay.textContent = String(value);\r\n   * });\r\n   *\r\n   * // Null-safe: returns no-op cleanup\r\n   * const noop = Data.bind(null)('key', callback); // () => {}\r\n   * ```\r\n   */\r\n  bind: def((el: HTMLElement | null, key: string, callback: (val: any, el: HTMLElement) => void): Unsubscribe => {\r\n    if (!el) return () => { };\r\n    const attr = toDataAttr(key);\r\n    const update = () => callback(Data.read(el)(key), el);\r\n\r\n    update(); // Initial\r\n    const obs = new MutationObserver((m) => {\r\n      if (m.some(x => x.attributeName === attr)) update();\r\n    });\r\n    obs.observe(el, { attributes: true, attributeFilter: [attr] });\r\n    return () => obs.disconnect();\r\n  })\r\n};\r\n\r\n/**\r\n * Observes changes to one or more attributes on an element.\r\n *\r\n * Uses MutationObserver to watch for attribute changes. The callback fires\r\n * whenever any of the specified attributes change, receiving the new value\r\n * and attribute name. Returns a cleanup function to stop observing.\r\n *\r\n * **Performance**: Uses attribute filtering for efficiency. The observer only\r\n * watches the specified attributes, not all attribute changes.\r\n *\r\n * @param target - The element to observe (null-safe)\r\n * @returns A curried function that accepts attributes and callback, returns cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const input = document.querySelector('input');\r\n *\r\n * // Imperative (cleaner DX)\r\n * const cleanup = watchAttr(input, 'disabled', (value, attrName) => {\r\n *   console.log(`${attrName} changed to:`, value);\r\n * });\r\n *\r\n * // Curried (pipeline friendly)\r\n * const cleanup = watchAttr(input)('disabled', (value, attrName) => {\r\n *   console.log(`${attrName} changed to:`, value);\r\n *   // value is the new attribute value (string | null)\r\n * });\r\n *\r\n * // Watch multiple attributes\r\n * watchAttr(input)(['value', 'placeholder', 'type'], (value, attrName) => {\r\n *   console.log(`${attrName} = ${value}`);\r\n * });\r\n *\r\n * // Form validation\r\n * watchAttr(input)('aria-invalid', (value) => {\r\n *   if (value === 'true') {\r\n *     input.classList.add('error');\r\n *   } else {\r\n *     input.classList.remove('error');\r\n *   }\r\n * });\r\n *\r\n * // Sync attributes between elements\r\n * watchAttr(sourceElement)('title', (value) => {\r\n *   if (value) targetElement.setAttribute('title', value);\r\n * });\r\n *\r\n * // Later: stop watching\r\n * cleanup();\r\n *\r\n * // Null-safe: returns no-op cleanup\r\n * const noop = watchAttr(null)('disabled', callback); // () => {}\r\n * ```\r\n */\r\nexport const watchAttr = def((target: Element | null, attrs: string | string[], callback: (val: string | null, attr: string) => void): Unsubscribe => {\r\n  if (!target) return () => { };\r\n  const obs = new MutationObserver((muts) => muts.forEach(m => {\r\n    if (m.attributeName) callback(target.getAttribute(m.attributeName), m.attributeName);\r\n  }));\r\n  obs.observe(target, { attributes: true, attributeFilter: Array.isArray(attrs) ? attrs : [attrs] });\r\n  return () => obs.disconnect();\r\n});\r\n\r\n/**\r\n * Observes changes to the text content of an element.\r\n *\r\n * Uses MutationObserver to watch for text content changes. The callback fires\r\n * whenever the element's textContent changes, receiving the new text value.\r\n * Returns a cleanup function to stop observing.\r\n *\r\n * **Performance**: Watches both characterData (direct text node changes) and\r\n * childList (when text nodes are added/removed) with subtree enabled.\r\n *\r\n * @param target - The element to observe (null-safe)\r\n * @returns A curried function that accepts a callback, returns cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n *\r\n * // Imperative (cleaner DX)\r\n * const cleanup = watchText(div, (newText) => {\r\n *   console.log('Text changed to:', newText);\r\n * });\r\n *\r\n * // Curried (pipeline friendly)\r\n * const cleanup = watchText(div)((newText) => {\r\n *   console.log('Text changed to:', newText);\r\n * });\r\n *\r\n * // Later: stop watching\r\n * cleanup();\r\n *\r\n * // Use in reactive UI\r\n * const counter = document.querySelector('#counter');\r\n * watchText(counter)((text) => {\r\n *   const count = parseInt(text);\r\n *   if (count > 100) alert('Limit exceeded!');\r\n * });\r\n *\r\n * // Null-safe: returns no-op cleanup\r\n * const noop = watchText(null)(callback); // () => {}\r\n * ```\r\n */\r\nexport const watchText = def((target: Element | null, callback: (text: string, el: Element) => void): Unsubscribe => {\r\n  if (!target) return () => { };\r\n  const obs = new MutationObserver(() => {\r\n    callback(target.textContent || '', target);\r\n  });\r\n  obs.observe(target, { characterData: true, childList: true, subtree: true });\r\n  return () => obs.disconnect();\r\n});\r\n\r\nconst resolveWatchElement = <T extends Element>(target: ElementInput | null) => {\r\n  if (typeof target === 'string') return find(document)(target) as T | null;\r\n  if (typeof target === 'function') return target() as T | null;\r\n  return target as T | null;\r\n};\r\n\r\n/**\r\n * Unified watch helpers for classes, attributes, text, and mutations.\r\n *\r\n * Supports both direct calls (`watch.class(el, 'active', cb)`) and\r\n * fluent calls (`watch(el).class('active', cb)`).\r\n *\r\n * @example\r\n * ```typescript\r\n * watch.class(el, 'open', (isOpen) => console.log(isOpen));\r\n * watch(el).attr('disabled', (value) => console.log(value));\r\n * watch.mutations(el, { subtree: true }, (records) => console.log(records.length));\r\n * ```\r\n */\r\nexport const watch = Object.assign(\r\n  <T extends Element>(target: ElementInput | null) => {\r\n    return {\r\n      class: (className: string, callback: (isPresent: boolean, el: T) => void) =>\r\n        watch.class<T>(target, className, callback),\r\n      attr: (attrName: string, callback: (value: string | null, el: T) => void) =>\r\n        watch.attr<T>(target, attrName, callback),\r\n      text: (callback: (text: string, el: T) => void) =>\r\n        watch.text<T>(target, callback),\r\n      mutations: (\r\n        optionsOrCallback?: MutationObserverInit | ((records: MutationRecord[], observer: MutationObserver, el: T) => void),\r\n        maybeCallback?: (records: MutationRecord[], observer: MutationObserver, el: T) => void\r\n      ) => watch.mutations<T>(target, optionsOrCallback as any, maybeCallback)\r\n    };\r\n  },\r\n  {\r\n    /**\r\n     * Observe class changes for a specific class name.\r\n     *\r\n     * @param target - Element, selector, or resolver\r\n     * @param className - Class to watch\r\n     * @param callback - Called when class toggles\r\n     * @returns Cleanup function\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const stop = watch.class(btn, 'active', (isActive) => {\r\n     *   console.log(isActive);\r\n     * });\r\n     * ```\r\n     */\r\n    class: <T extends Element>(\r\n      target: ElementInput | null,\r\n      className: string,\r\n      callback: (isPresent: boolean, el: T) => void\r\n    ): Unsubscribe => {\r\n      const el = resolveWatchElement<T>(target);\r\n      return watchClass(el, className, (isPresent, element) => callback(isPresent, element as T));\r\n    },\r\n\r\n    /**\r\n     * Observe attribute changes for a specific attribute.\r\n     *\r\n     * @param target - Element, selector, or resolver\r\n     * @param attrName - Attribute to watch\r\n     * @param callback - Called when attribute changes\r\n     * @returns Cleanup function\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * watch.attr(input, 'aria-invalid', (value) => {\r\n     *   console.log(value);\r\n     * });\r\n     * ```\r\n     */\r\n    attr: <T extends Element>(\r\n      target: ElementInput | null,\r\n      attrName: string,\r\n      callback: (value: string | null, el: T) => void\r\n    ): Unsubscribe => {\r\n      const el = resolveWatchElement<T>(target);\r\n      return watchAttr(el, attrName, (value, element) => callback(value, element as unknown as T));\r\n    },\r\n\r\n    /**\r\n     * Observe text content changes.\r\n     *\r\n     * @param target - Element, selector, or resolver\r\n     * @param callback - Called when text changes\r\n     * @returns Cleanup function\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * watch.text(status, (text) => console.log(text));\r\n     * ```\r\n     */\r\n    text: <T extends Element>(\r\n      target: ElementInput | null,\r\n      callback: (text: string, el: T) => void\r\n    ): Unsubscribe => {\r\n      const el = resolveWatchElement<T>(target);\r\n      return watchText(el, (text, element) => callback(text, element as T));\r\n    },\r\n\r\n    /**\r\n     * Observe DOM mutations for a target element.\r\n     *\r\n     * Defaults to `{ attributes: true, childList: true, subtree: false }`.\r\n     *\r\n     * @param target - Element, selector, or resolver\r\n     * @param options - Mutation observer options or callback\r\n     * @param callback - Mutation observer callback\r\n     * @returns Cleanup function\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const stop = watch.mutations(el, (records) => {\r\n     *   console.log(records.length);\r\n     * });\r\n     *\r\n     * watch.mutations(el, { subtree: true }, (records) => {\r\n     *   console.log(records);\r\n     * });\r\n     * ```\r\n     */\r\n    mutations: <T extends Element>(\r\n      target: ElementInput | null,\r\n      optionsOrCallback?: MutationObserverInit | ((records: MutationRecord[], observer: MutationObserver, el: T) => void),\r\n      maybeCallback?: (records: MutationRecord[], observer: MutationObserver, el: T) => void\r\n    ): Unsubscribe => {\r\n      const el = resolveWatchElement<T>(target);\r\n      if (!el) return () => { };\r\n\r\n      const defaultOptions: MutationObserverInit = {\r\n        attributes: true,\r\n        childList: true,\r\n        subtree: false\r\n      };\r\n\r\n      const callback =\r\n        typeof optionsOrCallback === 'function' ? optionsOrCallback : maybeCallback;\r\n      if (!callback) return () => { };\r\n\r\n      const options =\r\n        typeof optionsOrCallback === 'function'\r\n          ? defaultOptions\r\n          : { ...defaultOptions, ...optionsOrCallback };\r\n\r\n      const observer = new MutationObserver((records) => callback(records, observer, el));\r\n      observer.observe(el, options);\r\n      return () => observer.disconnect();\r\n    }\r\n  }\r\n);\r\n\r\n\r\n/**\r\n * Gets or sets an attribute on an element.\r\n *\r\n * Overloads:\r\n * 1. attr(\"data-id\") â€” gets attribute from documentElement\r\n * 2. attr(el)(\"data-id\") â€” gets attribute from the element\r\n * 3. attr(el)(\"data-id\", \"123\") â€” sets attribute\r\n *\r\n * Getter returns `string | null`\r\n * Setter returns `void`\r\n */\r\nexport function attr(attribute: string): string | null;\r\nexport function attr(el: Element | null):\r\n  (attribute: string) => string | null;\r\nexport function attr(el: Element | null):\r\n  (attribute: string, value: string) => void;\r\n\r\nexport function attr(a: any): any {\r\n  // Case 1: attr(\"data-id\")\r\n  if (typeof a === \"string\") {\r\n    const attribute = a;\r\n    return document.documentElement.getAttribute(attribute);\r\n  }\r\n\r\n  // Curried case: attr(el)\r\n  const el: Element | null = a;\r\n  return (attribute: string, value?: string): any => {\r\n    if (!el) return value === undefined ? null : undefined;\r\n    if (value === undefined) {\r\n      return el.getAttribute(attribute);\r\n    }\r\n    el.setAttribute(attribute, value);\r\n  };\r\n}\r\n\r\n/**\r\n * Gets or sets a DOM property.\r\n *\r\n * Works like `attr` but for real JS properties.\r\n *\r\n * Overloads:\r\n * 1. prop(\"value\") â€” gets from document.documentElement\r\n * 2. prop(el)(\"value\") â€” getter\r\n * 3. prop(el)(\"value\", newValue) â€” setter\r\n *\r\n * Getter: returns the property type of the element if known.\r\n * Setter: void\r\n */\r\nexport function prop<K extends keyof HTMLElement>(prop: K): HTMLElement[K];\r\nexport function prop<T extends HTMLElement, K extends keyof T>(\r\n  el: T | null\r\n): (prop: K) => T[K];\r\nexport function prop<T extends HTMLElement, K extends keyof T>(\r\n  el: T | null\r\n): (prop: K, value: T[K]) => void;\r\n\r\nexport function prop(a: any): any {\r\n  if (typeof a === \"string\") {\r\n    const key = a;\r\n    const el = document.documentElement as any;\r\n    return el[key];\r\n  }\r\n\r\n  const el = a as HTMLElement | null;\r\n\r\n  return (key: any, value?: any): any => {\r\n    if (!el) return undefined;\r\n    if (value === undefined) return (el as any)[key];\r\n    (el as any)[key] = value;\r\n  };\r\n}\r\n\r\n\r\n// =============================================================================\r\n// 8. LIFECYCLE\r\n// =============================================================================\r\n\r\n/**\r\n * Executes a callback when the DOM is fully loaded and parsed.\r\n * \r\n * If the DOM is already ready, the callback executes immediately (synchronously).\r\n * Otherwise, it waits for the DOMContentLoaded event. This is safer than placing\r\n * scripts at the end of the body, as it guarantees DOM availability.\r\n * \r\n * **Timing Guarantee**: The callback will execute exactly once, either immediately\r\n * or when DOMContentLoaded fires. External resources (images, stylesheets) may\r\n * still be loading.\r\n * \r\n * **SSR Considerations**: In server-side rendering contexts, ensure this code\r\n * only runs in the browser (check for `typeof document !== 'undefined'`).\r\n * \r\n * @param fn - The callback to execute when the DOM is ready\r\n * @returns void\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * onReady(() => {\r\n *   console.log('DOM is ready!');\r\n *   const app = document.querySelector('#app');\r\n *   // Safe to manipulate DOM here\r\n * });\r\n * \r\n * // Initialize app\r\n * onReady(() => {\r\n *   const form = document.querySelector('form');\r\n *   on(form)('submit', handleSubmit);\r\n *   \r\n *   const buttons = findAll(document)('button');\r\n *   buttons.forEach(btn => {\r\n *     on(btn)('click', handleClick);\r\n *   });\r\n * });\r\n * \r\n * // Multiple callbacks (each executes independently)\r\n * onReady(() => console.log('First'));\r\n * onReady(() => console.log('Second'));\r\n * \r\n * // SSR-safe usage\r\n * if (typeof document !== 'undefined') {\r\n *   onReady(() => {\r\n *     // Client-side only code\r\n *   });\r\n * }\r\n * \r\n * // Difference from window.onload:\r\n * // - onReady: Fires when DOM is parsed (faster)\r\n * // - window.onload: Fires when all resources loaded (slower)\r\n * ```\r\n */\r\nexport const onReady = (fn: () => void): void => {\r\n  if (typeof document === 'undefined') return;\r\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\r\n    fn();\r\n  } else {\r\n    document.addEventListener('DOMContentLoaded', fn, { once: true });\r\n  }\r\n};\r\n\r\n/**\r\n * Promise-based DOM lifecycle utilities for different timing needs.\r\n * \r\n * Type-safe, composable methods for waiting on specific lifecycle phases:\r\n * - `dom()` â€” waits until DOM is parsed (DOMContentLoaded)\r\n * - `micro()` â€” waits until microtask queue is empty\r\n * - `raf()` â€” waits until next requestAnimationFrame\r\n * \r\n * @example\r\n * ```typescript\r\n * // Wait for DOM to be parsed\r\n * await ready.dom();\r\n * const app = document.querySelector('#app');\r\n * \r\n * // Wait for microtasks to flush\r\n * await ready.micro();\r\n * \r\n * // Wait for next paint\r\n * await ready.raf();\r\n * \r\n * // Chain multiple lifecycle waits\r\n * await ready.dom();\r\n * await ready.micro();\r\n * await ready.raf();\r\n * // Now safe to interact with layout\r\n * ```\r\n */\r\nexport const ready = {\r\n  /**\r\n   * Waits until the DOM is parsed and interactive (DOMContentLoaded).\r\n   * Resolves immediately if DOM is already loaded.\r\n   * \r\n   * @returns Promise that resolves when DOM is ready\r\n   */\r\n  dom: () => new Promise<void>(resolve => {\r\n    if (typeof document === 'undefined') return resolve();\r\n    if (document.readyState !== \"loading\") resolve();\r\n    else document.addEventListener(\"DOMContentLoaded\", () => resolve(), { once: true });\r\n  }),\r\n\r\n  /**\r\n   * Waits until the microtask queue is flushed (after current JS execution).\r\n   * Useful for ensuring Promise chains and MutationObserver callbacks have run.\r\n   * \r\n   * @returns Promise that resolves on next microtask\r\n   */\r\n  micro: () => new Promise<void>(resolve => queueMicrotask(resolve)),\r\n\r\n  /**\r\n   * Waits until the next requestAnimationFrame (next paint cycle).\r\n   * Useful for deferring layout-dependent code.\r\n   * \r\n   * @returns Promise that resolves on next frame\r\n   */\r\n  raf: () => new Promise<void>(resolve => requestAnimationFrame(() => resolve()))\r\n};\r\n\r\n/**\r\n * Observes when elements matching a selector are added to the DOM.\r\n *\r\n * Uses MutationObserver to watch for new elements. The handler fires for:\r\n * 1. Elements already in the DOM (initial check)\r\n * 2. Elements added dynamically after setup\r\n *\r\n * Each element is tracked using WeakSet to prevent duplicate handler calls.\r\n * Returns a cleanup function to stop observing.\r\n *\r\n * **Performance**: Uses WeakSet for O(1) duplicate checking without memory leaks.\r\n * The observer watches the entire subtree by default.\r\n *\r\n * **SPA Navigation**: Perfect for handling dynamically loaded content in single-page\r\n * applications where elements appear/disappear without full page reloads.\r\n *\r\n * @template S - The CSS selector string\r\n * @param selector - CSS selector to match elements\r\n * @returns A curried function that accepts handler, root, and once flag\r\n *\r\n * @example\r\n * ```typescript\r\n * // Imperative (cleaner DX)\r\n * const cleanup = onMount('.modal', (modal) => {\r\n *   console.log('Modal added:', modal);\r\n *   modal.classList.add('initialized');\r\n * });\r\n *\r\n * // Curried (pipeline friendly)\r\n * const cleanup = onMount('.modal')((modal) => {\r\n *   console.log('Modal added:', modal);\r\n *   modal.classList.add('initialized');\r\n *\r\n *   // Setup modal-specific behavior\r\n *   const closeBtn = modal.querySelector('.close');\r\n *   on(closeBtn)('click', () => modal.remove());\r\n * });\r\n *\r\n * // Later: stop observing\r\n * cleanup();\r\n *\r\n * // Watch within a specific container\r\n * const container = document.querySelector('#app');\r\n * onMount('.dynamic-card')((card) => {\r\n *   console.log('Card added');\r\n * }, container);\r\n *\r\n * // One-time handler (stops after first match)\r\n * onMount('#splash-screen')((splash) => {\r\n *   setTimeout(() => splash.remove(), 3000);\r\n * }, document, true); // once = true\r\n *\r\n * // SPA route handling\r\n * onMount('[data-page]')((page) => {\r\n *   const pageName = page.getAttribute('data-page');\r\n *   console.log('Page loaded:', pageName);\r\n *\r\n *   // Initialize page-specific features\r\n *   initializeAnalytics(pageName);\r\n *   loadPageData(pageName);\r\n * });\r\n *\r\n * // Lazy-load images as they're added\r\n * onMount('img[data-src]')((img) => {\r\n *   const src = img.getAttribute('data-src');\r\n *   if (src) {\r\n *     img.setAttribute('src', src);\r\n *     img.removeAttribute('data-src');\r\n *   }\r\n * });\r\n *\r\n * // Component initialization pattern\r\n * onMount('[data-component=\"tooltip\"]')((el) => {\r\n *   new Tooltip(el); // Initialize tooltip component\r\n * });\r\n * ```\r\n */\r\nexport const onMount = def((selector: string | null, handler: (el: Element) => void, root: ParentNode = document, once = false): Unsubscribe => {\r\n  if (!selector) return () => { };\r\n  const seen = new WeakSet();\r\n  let foundAny = false;\r\n  let obs: MutationObserver | null = null;\r\n\r\n  const check = (node: Element) => {\r\n    if (seen.has(node)) return;\r\n    if (node.matches(selector)) { seen.add(node); handler(node); foundAny = true; }\r\n    node.querySelectorAll(selector).forEach(c => {\r\n      if (!seen.has(c)) { seen.add(c); handler(c); foundAny = true; }\r\n    });\r\n  };\r\n\r\n  const stopIfOnceSatisfied = () => {\r\n    if (once && foundAny && obs) {\r\n      obs.disconnect();\r\n      obs = null;\r\n    }\r\n  };\r\n\r\n  // Initial check\r\n  root.querySelectorAll(selector).forEach(check);\r\n\r\n  if (once && foundAny) return () => { };\r\n\r\n  obs = new MutationObserver(muts => {\r\n    muts.forEach(m => {\r\n      m.addedNodes.forEach(n => { if (n.nodeType === 1) check(n as Element); });\r\n    });\r\n    stopIfOnceSatisfied();\r\n  });\r\n\r\n  obs.observe(root, { childList: true, subtree: true });\r\n  return () => {\r\n    obs?.disconnect();\r\n    obs = null;\r\n  };\r\n});\r\n\r\n/**\r\n * Waits for a condition to become true on an element.\r\n *\r\n * Returns a Promise that resolves when the predicate returns true. Uses\r\n * MutationObserver to watch for changes. The predicate is checked immediately,\r\n * then on every mutation until it returns true.\r\n *\r\n * **Timeout Recommendation**: Consider adding a timeout wrapper to prevent\r\n * infinite waiting:\r\n * ```typescript\r\n * Promise.race([\r\n *   waitFor(el, predicate),\r\n *   wait(5000).then(() => { throw new Error('Timeout'); })\r\n * ]);\r\n * ```\r\n *\r\n * **Memory Leak Prevention**: The observer automatically disconnects when the\r\n * condition is met. If the element is null, the promise rejects (consider\r\n * null-checking before calling).\r\n *\r\n * @param target - The element to observe (null-unsafe: promise rejects if null)\r\n\r\n * @returns A curried function that accepts a predicate and returns a Promise\r\n *\r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n *\r\n * // Imperative (cleaner DX)\r\n * await waitFor(button, (el) => el.classList.contains('ready'));\r\n * console.log('Button is ready!');\r\n *\r\n * // Curried (pipeline friendly)\r\n * await waitFor(button)((el) => el.classList.contains('ready'));\r\n * console.log('Button is ready!');\r\n *\r\n * // Wait for specific attribute value\r\n * await waitFor(input)((el) => el.getAttribute('data-loaded') === 'true');\r\n * console.log('Data loaded!');\r\n *\r\n * // Wait for child count\r\n * const list = document.querySelector('ul');\r\n * await waitFor(list)((el) => el.children.length >= 10);\r\n * console.log('List has at least 10 items');\r\n *\r\n * // Wait for text content\r\n * await waitFor(status)((el) => el.textContent?.includes('Complete'));\r\n * console.log('Status is complete');\r\n *\r\n * // With timeout (recommended)\r\n * try {\r\n *   await Promise.race([\r\n *     waitFor(element)((el) => el.classList.contains('loaded')),\r\n *     wait(5000).then(() => { throw new Error('Timeout waiting for element'); })\r\n *   ]);\r\n *   console.log('Element loaded in time');\r\n * } catch (e) {\r\n *   console.error('Timed out:', e);\r\n * }\r\n *\r\n * // Animation completion\r\n * element.classList.add('animating');\r\n * await waitFor(element)((el) => !el.classList.contains('animating'));\r\n * console.log('Animation complete');\r\n *\r\n * // Form validation\r\n * await waitFor(form)((el) => {\r\n *   const inputs = el.querySelectorAll('input[required]');\r\n *   return Array.from(inputs).every(input => input.value.length > 0);\r\n * });\r\n * console.log('All required fields filled');\r\n * ```\r\n */\r\nexport const waitFor = def((target: Element | null, predicate: (el: Element) => boolean): Promise<Element> => {\r\n  return new Promise((resolve, reject) => {\r\n    if (!target) {\r\n      reject(new Error('waitFor: target is null'));\r\n      return;\r\n    }\r\n    if (predicate(target)) return resolve(target);\r\n    const obs = new MutationObserver(() => {\r\n      if (predicate(target)) { obs.disconnect(); resolve(target); }\r\n    });\r\n    obs.observe(target, { attributes: true, childList: true, subtree: true, characterData: true });\r\n  });\r\n});\r\n\r\n\r\n// =============================================================================\r\n// 9. UTILS (URL, FORM, ETC)\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with URL query parameters.\r\n * \r\n * Provides a functional API for reading and modifying URL search parameters.\r\n * Supports both 'soft' navigation (using pushState) and 'hard' navigation\r\n * (full page reload).\r\n * \r\n * **URL Encoding**: Values are automatically URL-encoded when set.\r\n * \r\n * @example\r\n * ```typescript\r\n * // URL: https://example.com?page=1&sort=name\r\n * \r\n * // Get single parameter\r\n * const page = Params.get('page'); // \"1\"\r\n * const missing = Params.get('missing'); // null\r\n * \r\n * // Get multiple values (for array parameters)\r\n * // URL: ?tags=js&tags=ts&tags=react\r\n * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\r\n * \r\n * // Set parameter (soft navigation - no reload)\r\n * Params.set('page')('2')(); // Updates URL without reload\r\n * // URL becomes: ?page=2&sort=name\r\n * \r\n * // Set parameter (hard navigation - full reload)\r\n * Params.set('page')('2')('hard'); // Reloads page with new URL\r\n * \r\n * // Chaining for multiple updates\r\n * Params.set('page')('1')();\r\n * Params.set('sort')('date')();\r\n * Params.set('filter')('active')();\r\n * ```\r\n */\r\nexport const Params = {\r\n  /**\r\n   * Gets a single query parameter value.\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns The parameter value or null if not found\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // URL: ?id=123&name=John\r\n   * const id = Params.get('id'); // \"123\"\r\n   * const name = Params.get('name'); // \"John\"\r\n   * const missing = Params.get('missing'); // null\r\n   * ```\r\n   */\r\n  get: (key: string) => new URLSearchParams(window.location.search).get(key),\r\n\r\n  /**\r\n   * Gets all values for a query parameter (for array-like parameters).\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns Array of all values for that parameter\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // URL: ?tags=js&tags=ts&tags=react\r\n   * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\r\n   * \r\n   * // URL: ?filter=active\r\n   * const filters = Params.getAll('filter'); // [\"active\"]\r\n   * \r\n   * // Missing parameter\r\n   * const missing = Params.getAll('missing'); // []\r\n   * ```\r\n   */\r\n  getAll: (key: string) => new URLSearchParams(window.location.search).getAll(key),\r\n\r\n  /**\r\n   * Sets a query parameter value.\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns A curried function that accepts value and navigation type\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Soft navigation (no page reload)\r\n   * Params.set('page')('2')(); // Default: soft\r\n   * Params.set('page')('2')('soft');\r\n   * \r\n   * // Hard navigation (full page reload)\r\n   * Params.set('page')('2')('hard');\r\n   * \r\n   * // Pagination example\r\n   * const nextPage = () => {\r\n   *   const current = parseInt(Params.get('page') || '1');\r\n   *   Params.set('page')(String(current + 1))();\r\n   * };\r\n   * \r\n   * // Filter example\r\n   * const applyFilter = (filter: string) => {\r\n   *   Params.set('filter')(filter)();\r\n   *   Params.set('page')('1')(); // Reset to page 1\r\n   *   loadData(); // Fetch filtered data\r\n   * };\r\n   * ```\r\n   */\r\n  set: (key: string) => (val: string) => (type: 'soft' | 'hard' = 'soft') => {\r\n    const u = new URL(window.location.href);\r\n    u.searchParams.set(key, val);\r\n    if (type === 'hard') window.location.href = u.href;\r\n    else window.history.pushState(null, '', u.href);\r\n  }\r\n};\r\n\r\n/**\r\n * Utilities for working with form data.\r\n * \r\n * Provides serialization and population of form fields. Automatically handles\r\n * different input types (text, checkbox, radio, number, select, textarea).\r\n * \r\n * **FormData Compatibility**: For native FormData support, use `new FormData(form)`.\r\n * This utility provides a plain object representation.\r\n * \r\n * @example\r\n * ```typescript\r\n * const form = document.querySelector('form');\r\n * \r\n * // Serialize form to object\r\n * const data = Form.serialize(form);\r\n * // { username: \"john\", email: \"john@example.com\", age: 25, subscribe: true }\r\n * \r\n * // Populate form from object\r\n * Form.populate(form)({\r\n *   username: \"jane\",\r\n *   email: \"jane@example.com\",\r\n *   age: 30,\r\n *   subscribe: false\r\n * });\r\n * \r\n * // Save/load form state\r\n * const saveForm = () => {\r\n *   const data = Form.serialize(form);\r\n *   Local.set('formDraft')(data);\r\n * };\r\n * \r\n * const loadForm = () => {\r\n *   const data = Local.get('formDraft');\r\n *   if (data) Form.populate(form)(data);\r\n * };\r\n * ```\r\n */\r\nexport interface FormSerializeOptions {\r\n  /** Use dot-notation to create nested objects. */\r\n  nested?: boolean;\r\n  /** Include FileList values from file inputs. */\r\n  includeFiles?: boolean;\r\n  /** Include disabled fields (default: false). */\r\n  includeDisabled?: boolean;\r\n}\r\n\r\nexport interface Register {\n  <T extends Unsubscribe>(cleanup: T): T;\n}\n\nexport type AutoCleanup = <T>(fn: (r: Register) => T | Promise<T>) => T | Promise<T>;\n\n\r\nexport const Form = {\r\n  /**\r\n   * Serializes form inputs into a plain object.\r\n   * \r\n   * Handles:\r\n   * - Text inputs â†’ string\r\n   * - Number inputs â†’ number\r\n   * - Checkboxes â†’ boolean\r\n   * - Radio buttons â†’ string (only checked value)\r\n   * - Select â†’ string\r\n   * - Textarea â†’ string\r\n   * \r\n   * Options:\r\n   * - `nested`: Supports dot-notation for nested objects\r\n   * - `includeFiles`: Includes FileList values\r\n   * - `includeDisabled`: Includes disabled inputs\r\n   * \r\n   * Only includes inputs with a `name` attribute.\r\n   * \r\n   * @param root - The form or container element\r\n   * @param options - Serialization options\r\n   * @returns Object with field names as keys and values\r\n\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const form = document.querySelector('form');\r\n   * const data = Form.serialize(form);\r\n   * \r\n   * // Submit to API\r\n   * await Http.post('/api/submit')(data);\r\n   * \r\n   * // Validate before submit\r\n   * on(form)('submit', (e) => {\r\n   *   e.preventDefault();\r\n   *   const data = Form.serialize(form);\r\n   *   if (validate(data)) {\r\n   *     submitForm(data);\r\n   *   }\r\n   * });\r\n   * \r\n   * // Auto-save draft\r\n   * const inputs = form.querySelectorAll('input, textarea');\r\n   * inputs.forEach(input => {\r\n   *   on(input)('input', debounce(() => {\r\n   *     const data = Form.serialize(form);\r\n   *     Local.set('draft')(data);\r\n   *   }, 500));\r\n   * });\r\n   * ```\r\n   */\r\n  serialize: (root: HTMLElement | null, options: FormSerializeOptions = {}) => {\r\n    const data: Record<string, any> = {};\r\n    if (!root) return data;\r\n\r\n    const { nested = false, includeFiles = false, includeDisabled = false } = options;\r\n    const isNumeric = (value: string) => /^\\d+$/.test(value);\r\n\r\n    const setNested = (target: Record<string, any>, path: string[], value: any) => {\r\n      let current: any = target;\r\n      path.forEach((segment, index) => {\r\n        const isLast = index === path.length - 1;\r\n        if (isLast) {\r\n          current[segment] = value;\r\n          return;\r\n        }\r\n\r\n        const nextSegment = path[index + 1];\r\n        const shouldBeArray = typeof nextSegment === 'string' && isNumeric(nextSegment);\r\n\r\n        if (current[segment] === undefined || typeof current[segment] !== 'object') {\r\n          current[segment] = shouldBeArray ? [] : {};\r\n        }\r\n\r\n        current = current[segment];\r\n      });\r\n    };\r\n\r\n    const setValue = (name: string, value: any) => {\r\n      if (nested) {\r\n        setNested(data, name.split('.').filter(Boolean), value);\r\n      } else {\r\n        data[name] = value;\r\n      }\r\n    };\r\n\r\n    root.querySelectorAll<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>('input, select, textarea').forEach(el => {\r\n      if (!el.name) return;\r\n      if (!includeDisabled && el.disabled) return;\r\n\r\n      if (el instanceof HTMLInputElement && el.type === 'file') {\r\n        if (includeFiles) setValue(el.name, el.files);\r\n        return;\r\n      }\r\n\r\n      if (el instanceof HTMLInputElement && el.type === 'checkbox') {\r\n        setValue(el.name, el.checked);\r\n      } else if (el instanceof HTMLInputElement && el.type === 'radio') {\r\n        if (el.checked) setValue(el.name, el.value);\r\n      } else if (el instanceof HTMLInputElement && el.type === 'number') {\r\n        setValue(el.name, Number(el.value));\r\n      } else {\r\n        setValue(el.name, el.value);\r\n      }\r\n    });\r\n\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Populates form inputs from a plain object.\r\n   *\r\n   * Matches object keys to input `name` attributes and sets values accordingly.\r\n   *\r\n   * @param root - The form or container element\r\n   * @returns A curried function that accepts data object and returns the root\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const form = document.querySelector('form');\r\n   *\r\n   * // Imperative (cleaner DX)\r\n   * Form.populate(form, {\r\n   *   username: 'john',\r\n   *   email: 'john@example.com',\r\n   *   notifications: true\r\n   * });\r\n   *\r\n   * // Curried (pipeline friendly)\r\n   * Form.populate(form)({\r\n   *   username: user.username,\r\n   *   email: user.email,\r\n   *   bio: user.bio,\r\n   *   notifications: user.preferences.notifications\r\n   * });\r\n   *\r\n   * // Load saved data\r\n   * const savedData = Local.get('formData');\r\n   * if (savedData) Form.populate(form)(savedData);\r\n   *\r\n   * // Reset form to defaults\r\n   * Form.populate(form)({\r\n   *   theme: 'light',\r\n   *   language: 'en',\r\n   *   notifications: true\r\n   * });\r\n   * ```\r\n   */\r\n  populate: def((root: HTMLElement | null, data: Record<string, any>) => {\r\n    if (!root) return root;\r\n    Object.entries(data).forEach(([k, v]) => {\r\n      const el = root.querySelector(`[name=\"${k}\"]`) as HTMLInputElement;\r\n      if (!el) return;\r\n      if (el.type === 'checkbox' || el.type === 'radio') el.checked = !!v;\r\n      else el.value = String(v);\r\n    });\r\n    return root;\r\n  })\r\n};\r\n\r\n/**\r\n * Waits for a specified number of milliseconds.\r\n * \r\n * Returns a Promise that resolves after the delay. Useful for adding delays\r\n * in async functions or creating timeouts.\r\n * \r\n * @param ms - The number of milliseconds to wait\r\n * @returns A Promise that resolves after the delay\r\n * \r\n * @example\r\n * ```typescript\r\n * // Simple delay\r\n * await wait(1000); // Wait 1 second\r\n * console.log('Done waiting');\r\n * \r\n * // Delay in async function\r\n * async function showMessage() {\r\n *   console.log('Loading...');\r\n *   await wait(2000);\r\n *   console.log('Done!');\r\n * }\r\n * \r\n * // Animation timing\r\n * async function animate() {\r\n *   element.classList.add('fade-in');\r\n *   await wait(300);\r\n *   element.classList.remove('fade-in');\r\n * }\r\n * \r\n * // Retry with delay\r\n * async function retryFetch(url: string, retries = 3) {\r\n *   for (let i = 0; i < retries; i++) {\r\n *     try {\r\n *       return await fetch(url);\r\n *     } catch (e) {\r\n *       if (i < retries - 1) await wait(1000 * (i + 1));\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport const wait = (ms: number) => new Promise(r => setTimeout(r, ms));\r\n\r\n/**\r\n * Waits for the next animation frame.\r\n * \r\n * Returns a Promise that resolves on the next requestAnimationFrame callback.\r\n * Useful for ensuring DOM updates are rendered before proceeding.\r\n * \r\n * @returns A Promise that resolves on the next frame\r\n * \r\n * @example\r\n * ```typescript\r\n * // Ensure DOM update is rendered\r\n * element.style.opacity = '0';\r\n * await nextFrame();\r\n * element.style.transition = 'opacity 0.3s';\r\n * element.style.opacity = '1';\r\n * \r\n * // Batch DOM reads after writes\r\n * element.style.width = '100px';\r\n * await nextFrame();\r\n * const width = element.offsetWidth; // Avoids layout thrashing\r\n * \r\n * // Smooth animation sequence\r\n * async function animateSequence() {\r\n *   element.classList.add('step-1');\r\n *   await nextFrame();\r\n *   element.classList.add('step-2');\r\n *   await nextFrame();\r\n *   element.classList.add('step-3');\r\n * }\r\n * ```\r\n */\r\nexport const nextFrame = () => new Promise(r => requestAnimationFrame(r));\r\n\r\n/** CSS Template Literal for highlighting */\r\nexport const cssTemplate = (strings: TemplateStringsArray, ...values: any[]) =>\r\n  strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n\r\n// =============================================================================\r\n// 10. NAVIGATION (TRAVERSAL)\r\n// =============================================================================\r\n\r\n/**\r\n * Flexible, type-aware DOM traversal utilities.\r\n *\r\n * Each method supports two invocation styles:\r\n *\r\n * 1. **Element-first** (immediate):\r\n *    Traverse.next(el)                     â†’ Element | null\r\n *    Traverse.next(el, \"span.highlight\")   â†’ Element | null\r\n *\r\n * 2. **Selector-first**:\r\n *    Traverse.next(\".item\")                â†’ Element | null\r\n *\r\n * All operations are:\r\n *   - **Null-safe**: All functions gracefully return `null` or `[]`.\r\n *   - **Type-preserving**: Passing `HTMLDivElement` returns `HTMLDivElement | null`.\r\n *   - **Selector-aware**: Passing a selector filters the returned element(s).\r\n */\r\nexport const Traverse = {\r\n  /**\r\n   * Get the parent element, optionally filtered by a selector.\r\n   *\r\n   * @example\r\n   * // Element-first\r\n   * const parent = Traverse.parent(el);       // <div> | null\r\n   *\r\n   * // Selector-first\r\n   * const parent = Traverse.parent(\"#child\"); // parent of #child\r\n   *\r\n   * // Curried\r\n   * const specific = Traverse.parent(el)(\".box\");\r\n   */\r\n  parent(elOrSelector?: Element | string | null, selector?: string) {\r\n    if (typeof elOrSelector === \"string\") {\r\n      const el = document.querySelector(elOrSelector);\r\n      const parent = el?.parentElement || null;\r\n      if (!parent) return null;\r\n      return !selector || parent.matches(selector) ? parent : null;\r\n    }\r\n\r\n    const el = elOrSelector ?? null;\r\n    const parent = el?.parentElement ?? null;\r\n    if (!parent) return null;\r\n    return !selector || parent.matches(selector) ? parent : null;\r\n  },\r\n\r\n  /**\r\n   * Get the next sibling element.\r\n   *\r\n   * @example\r\n   * Traverse.next(el);            // <li> | null\r\n   * Traverse.next(\".active\");     // next of .active\r\n   * Traverse.next(el)(\"button\");  // next button sibling\r\n   */\r\n  next(elOrSelector?: Element | string | null, selector?: string) {\r\n    if (typeof elOrSelector === \"string\") {\r\n      const el = document.querySelector(elOrSelector);\r\n      const next = el?.nextElementSibling || null;\r\n      if (!next) return null;\r\n      return !selector || next.matches(selector) ? next : null;\r\n    }\r\n\r\n    const el = elOrSelector ?? null;\r\n    const next = el?.nextElementSibling ?? null;\r\n    if (!next) return null;\r\n    return !selector || next.matches(selector) ? next : null;\r\n  },\r\n\r\n  /**\r\n   * Get the previous sibling element.\r\n   *\r\n   * @example\r\n   * Traverse.prev(el);\r\n   * Traverse.prev(\".selected\");\r\n   * Traverse.prev(el)(\".item\");\r\n   */\r\n  prev(elOrSelector?: Element | string | null, selector?: string) {\r\n    if (typeof elOrSelector === \"string\") {\r\n      const el = document.querySelector(elOrSelector);\r\n      const prev = el?.previousElementSibling || null;\r\n      if (!prev) return null;\r\n      return !selector || prev.matches(selector) ? prev : null;\r\n    }\r\n\r\n    const el = elOrSelector ?? null;\r\n    const prev = el?.previousElementSibling ?? null;\r\n    if (!prev) return null;\r\n    return !selector || prev.matches(selector) ? prev : null;\r\n  },\r\n\r\n  /**\r\n   * Get child elements, with optional selector filtering.\r\n   *\r\n   * @example\r\n   * Traverse.children(el);         // Element[]\r\n   * Traverse.children(\".list\");    // children of element matching .list\r\n   * Traverse.children(el)(\"li\");   // only <li> children\r\n   */\r\n  children(elOrSelector?: Element | string | null, selector?: string) {\r\n    if (typeof elOrSelector === \"string\") {\r\n      const el = document.querySelector(elOrSelector);\r\n      if (!el) return [];\r\n      const kids = Array.from(el.children);\r\n      return selector ? kids.filter(c => c.matches(selector)) : kids;\r\n    }\r\n\r\n    const el = elOrSelector ?? null;\r\n    if (!el) return [];\r\n    const kids = Array.from(el.children);\r\n    return selector ? kids.filter(c => c.matches(selector)) : kids;\r\n  },\r\n\r\n  /**\r\n    * Get sibling elements (excluding the original element).\r\n    *\r\n    * @example\r\n    * Traverse.siblings(el);\r\n    * Traverse.siblings(\"#active\");\r\n    * Traverse.siblings(el)(\".item\");\r\n    */\r\n  siblings(elOrSelector?: Element | string | null, selector?: string) {\r\n    if (typeof elOrSelector === \"string\") {\r\n      const el = document.querySelector(elOrSelector);\r\n      if (!el?.parentElement) return [];\r\n      const sibs = Array.from(el.parentElement.children).filter(c => c !== el);\r\n      return selector ? sibs.filter(s => s.matches(selector)) : sibs;\r\n    }\r\n\r\n    const el = elOrSelector ?? null;\r\n    if (!el?.parentElement) return [];\r\n    const sibs = Array.from(el.parentElement.children).filter(s => s !== el);\r\n    return selector ? sibs.filter(s => s.matches(selector)) : sibs;\r\n  },\r\n\r\n  /**\r\n   * Get all ancestor elements up to the document root.\r\n   *\r\n   * Optionally stops at an element matching a selector.\r\n   *\r\n   * @example\r\n   * Traverse.parents(el);                  // All ancestors\r\n   * Traverse.parents(\"#child\");            // Ancestors of #child\r\n   * Traverse.parents(el, \".section\");      // Ancestors until .section match\r\n   * Traverse.parents(el)(\".container\");    // Curried: ancestors matching .container\r\n   */\r\n  parents(elOrSelector?: Element | string | null, until?: string | ((el: Element) => boolean)): Element[] {\r\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\r\n    const result: Element[] = [];\r\n    let current = el?.parentElement ?? null;\r\n\r\n    while (current) {\r\n      // If until is a string selector\r\n      if (typeof until === \"string\" && current.matches(until)) {\r\n        break;\r\n      }\r\n      // If until is a function predicate\r\n      if (typeof until === \"function\" && until(current)) {\r\n        break;\r\n      }\r\n      result.push(current);\r\n      current = current.parentElement;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Get all following sibling elements.\r\n   *\r\n   * Optionally filtered by a selector.\r\n   *\r\n   * @example\r\n   * Traverse.nextAll(el);           // All following siblings\r\n   * Traverse.nextAll(\".selected\");  // Following siblings of .selected\r\n   * Traverse.nextAll(el)(\".item\");  // Following siblings matching .item\r\n   */\r\n  nextAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\r\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\r\n    const result: Element[] = [];\r\n    let current = el?.nextElementSibling ?? null;\r\n\r\n    while (current) {\r\n      if (!selector || current.matches(selector)) {\r\n        result.push(current);\r\n      }\r\n      current = current.nextElementSibling;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Get all preceding sibling elements.\r\n   *\r\n   * Optionally filtered by a selector.\r\n   *\r\n   * @example\r\n   * Traverse.prevAll(el);           // All preceding siblings\r\n   * Traverse.prevAll(\".selected\");  // Preceding siblings of .selected\r\n   * Traverse.prevAll(el)(\".item\");  // Preceding siblings matching .item\r\n   */\r\n  prevAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\r\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\r\n    const result: Element[] = [];\r\n    let current = el?.previousElementSibling ?? null;\r\n\r\n    while (current) {\r\n      if (!selector || current.matches(selector)) {\r\n        result.push(current);\r\n      }\r\n      current = current.previousElementSibling;\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Get all ancestors including the element itself, up to document root.\r\n   *\r\n   * Optionally filtered by a selector.\r\n   *\r\n   * @example\r\n   * Traverse.closestAll(el);            // Element + all ancestors\r\n   * Traverse.closestAll(\"#child\");      // Self + ancestors of #child\r\n   * Traverse.closestAll(el)(\".box\");    // Self + ancestors matching .box\r\n   */\r\n  closestAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\r\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\r\n    const result: Element[] = [];\r\n    let current: Element | null = el;\r\n\r\n    while (current) {\r\n      if (!selector || current.matches(selector)) {\r\n        result.push(current);\r\n      }\r\n      current = current.parentElement;\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 11. CSS VARIABLES & ANIMATION\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with CSS custom properties (variables).\r\n * \r\n * Provides a functional API for getting and setting CSS variables on elements.\r\n * Variables can be set at any level (element, :root, etc.) and will cascade\r\n * according to CSS specificity rules.\r\n * \r\n * **Fallback Values**: When getting variables, you can provide fallback values\r\n * using standard CSS syntax: `var(--color, blue)`.\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.card');\r\n * \r\n * // Set CSS variable\r\n * CssVar.set(element)('--primary-color', '#007bff');\r\n * CssVar.set(element)('--spacing', '1rem');\r\n * \r\n * // Get CSS variable\r\n * const color = CssVar.get(element)('--primary-color'); // \"#007bff\"\r\n * \r\n * // Set on :root for global theme\r\n * CssVar.set(document.documentElement)('--theme', 'dark');\r\n * \r\n * // Dynamic theming\r\n * const setTheme = (theme: 'light' | 'dark') => {\r\n *   const root = document.documentElement;\r\n *   if (theme === 'dark') {\r\n *     CssVar.set(root)('--bg', '#1a1a1a');\r\n *     CssVar.set(root)('--text', '#ffffff');\r\n *   } else {\r\n *     CssVar.set(root)('--bg', '#ffffff');\r\n *     CssVar.set(root)('--text', '#000000');\r\n *   }\r\n * };\r\n * ```\r\n */\r\nexport const CssVar = {\r\n  /**\r\n   * Sets a CSS custom property (variable) on an element.\r\n   * \r\n   * @param el - The element to set the variable on (null-safe)\r\n   * @returns A curried function that accepts name and value, returns the element\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Set single variable\r\n   * CssVar.set(div)('--color', 'red');\r\n   * \r\n   * // Set multiple variables\r\n   * CssVar.set(div)('--width', '100px');\r\n   * CssVar.set(div)('--height', '100px');\r\n   * \r\n   * // Global theme variables\r\n   * const root = document.documentElement;\r\n   * CssVar.set(root)('--primary', '#007bff');\r\n   * CssVar.set(root)('--secondary', '#6c757d');\r\n   * \r\n   * // Dynamic values\r\n   * CssVar.set(element)('--progress', `${percentage}%`);\r\n   * \r\n   * // Null-safe\r\n   * CssVar.set(null)('--color', 'red'); // Returns null\r\n   * ```\r\n   */\r\n  set: (el: HTMLElement | null) => (name: string, value: string) => {\r\n    el?.style.setProperty(name, value);\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Gets the computed value of a CSS custom property.\r\n   * \r\n   * Returns the computed value, which may be inherited from a parent element\r\n   * or :root. The value is trimmed of whitespace.\r\n   * \r\n   * @param el - The element to get the variable from (null-safe)\r\n   * @returns A curried function that accepts name and returns the value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Get variable value\r\n   * const color = CssVar.get(div)('--primary-color');\r\n   * \r\n   * // Get inherited variable\r\n   * const spacing = CssVar.get(div)('--spacing'); // May come from parent\r\n   * \r\n   * // Use in calculations\r\n   * const width = parseInt(CssVar.get(element)('--width'));\r\n   * \r\n   * // Check if variable is set\r\n   * const hasTheme = CssVar.get(document.documentElement)('--theme') !== '';\r\n   * \r\n   * // Null-safe\r\n   * CssVar.get(null)('--color'); // \"\"\r\n   * ```\r\n   */\r\n  get: (el: HTMLElement | null) => (name: string) => {\r\n    return el ? getComputedStyle(el).getPropertyValue(name).trim() : '';\r\n  }\r\n};\r\n\r\n/**\r\n * Reads a computed CSS property value from an element.\r\n * \r\n * Gets the final computed value of any CSS property, including inherited values,\r\n * cascaded values, and browser defaults. Useful for reading actual rendered values\r\n * rather than inline styles.\r\n * \r\n * **Unit Parsing**: The returned value includes units (e.g., \"16px\", \"1.5em\").\r\n * Parse with `parseInt()` or `parseFloat()` if you need numeric values.\r\n * \r\n * **Computed vs Inline**: This reads computed styles (what's actually rendered),\r\n * not inline styles. Use `element.style.property` for inline styles only.\r\n * \r\n * @param el - The element to read from (null-safe)\r\n * @returns A curried function that accepts a property name and returns the value\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Get computed width (includes padding, border if box-sizing)\r\n * const width = computed(div)('width'); // \"200px\"\r\n * \r\n * // Get font size\r\n * const fontSize = computed(div)('fontSize'); // \"16px\"\r\n * \r\n * // Get color (returns rgb/rgba)\r\n * const color = computed(div)('color'); // \"rgb(0, 0, 0)\"\r\n * \r\n * // Parse numeric values\r\n * const widthNum = parseInt(computed(div)('width')); // 200\r\n * \r\n * // Check display state\r\n * const isHidden = computed(div)('display') === 'none';\r\n * \r\n * // Get inherited values\r\n * const lineHeight = computed(div)('lineHeight');\r\n * \r\n * // Null-safe\r\n * computed(null)('width'); // \"\"\r\n * ```\r\n */\r\nexport const computed = (el: HTMLElement | null) => (prop: keyof CSSStyleDeclaration): string => {\r\n  if (!el) return '';\r\n  const value = getComputedStyle(el)[prop];\r\n  return typeof value === 'string' ? value : String(value);\r\n};\r\n\r\n/**\r\n * Injects CSS styles into the document.\r\n * \r\n * Creates a <style> element with the provided CSS content and appends it to\r\n * the specified root (defaults to document.head). Returns a cleanup function\r\n * to remove the styles.\r\n * \r\n * **CSP Considerations**: If your site uses Content Security Policy, ensure\r\n * inline styles are allowed or use nonces/hashes.\r\n * \r\n * **Style Precedence**: Injected styles follow normal CSS cascade rules.\r\n * Later injected styles override earlier ones (if same specificity).\r\n * \r\n * **Scoping**: For scoped styles, use a unique class or data attribute as a\r\n * prefix in your CSS selectors.\r\n * \r\n * @param cssContent - The CSS content to inject\r\n * @param root - The node to append the style element to (defaults to document.head)\r\n * @returns A cleanup function that removes the injected styles\r\n * \r\n * @example\r\n * ```typescript\r\n * // Inject global styles\r\n * const cleanup = injectStyles(`\r\n *   body { background: #1a1a1a; color: #fff; }\r\n *   .card { border-radius: 8px; }\r\n * `);\r\n * \r\n * // Later: remove styles\r\n * cleanup();\r\n * \r\n * // Component-specific styles\r\n * const initModal = () => {\r\n *   const cleanup = injectStyles(`\r\n *     .modal { position: fixed; inset: 0; }\r\n *     .modal-backdrop { background: rgba(0,0,0,0.5); }\r\n *   `);\r\n *   \r\n *   return cleanup; // Return for cleanup when modal is destroyed\r\n * };\r\n * \r\n * // Scoped styles\r\n * const cleanup = injectStyles(`\r\n *   [data-theme=\"dark\"] {\r\n *     --bg: #1a1a1a;\r\n *     --text: #ffffff;\r\n *   }\r\n * `);\r\n * \r\n * // Inject into shadow DOM\r\n * const shadow = element.attachShadow({ mode: 'open' });\r\n * injectStyles('.component { color: red; }', shadow);\r\n * \r\n * // Temporary styles (auto-cleanup)\r\n * const showHighlight = async () => {\r\n *   const cleanup = injectStyles('.highlight { background: yellow; }');\r\n *   await wait(3000);\r\n *   cleanup(); // Remove after 3 seconds\r\n * };\r\n * ```\r\n */\r\nexport const injectStyles = (cssContent: string, root: Node = document.head): Unsubscribe => {\r\n  const style = document.createElement('style');\r\n  style.textContent = cssContent;\r\n  root.appendChild(style);\r\n  return () => style.remove();\r\n};\r\n\r\n/**\r\n * Waits for a CSS transition or animation to complete.\r\n * \r\n * Returns a Promise that resolves when the element's transition or animation\r\n * ends. Includes a fallback that resolves immediately if no transition/animation\r\n * is active (duration is 0s or element has display:none).\r\n * \r\n * **Fallback Timeout**: The promise includes a built-in fallback that resolves\r\n * if no transition/animation is detected. For additional safety, wrap in\r\n * `Promise.race()` with a timeout.\r\n * \r\n * **Animation Event Handling**: Listens for both `transitionend` and `animationend`\r\n * events. Automatically cleans up event listeners when resolved.\r\n * \r\n * @param el - The element to wait for (null-safe)\r\n * @returns A Promise that resolves with the element (or null) when complete\r\n * \r\n * @example\r\n * ```typescript\r\n * const modal = document.querySelector('.modal');\r\n * \r\n * // Wait for fade-in animation\r\n * modal.classList.add('fade-in');\r\n * await waitTransition(modal);\r\n * console.log('Animation complete!');\r\n * \r\n * // Smooth hide/remove pattern\r\n * element.classList.add('fade-out');\r\n * await waitTransition(element);\r\n * element.remove(); // Remove after animation\r\n * \r\n * // Sequential animations\r\n * element.classList.add('slide-in');\r\n * await waitTransition(element);\r\n * element.classList.add('pulse');\r\n * await waitTransition(element);\r\n * element.classList.remove('pulse');\r\n * \r\n * // Modal close with animation\r\n * const closeModal = async (modal: HTMLElement) => {\r\n *   modal.classList.remove('show');\r\n *   await waitTransition(modal);\r\n *   modal.style.display = 'none';\r\n * };\r\n * \r\n * // With timeout safety\r\n * try {\r\n *   await Promise.race([\r\n *     waitTransition(element),\r\n *     wait(5000).then(() => { throw new Error('Animation timeout'); })\r\n *   ]);\r\n * } catch (e) {\r\n *   console.error('Animation took too long');\r\n * }\r\n * \r\n * // Null-safe\r\n * await waitTransition(null); // Resolves immediately with null\r\n * ```\r\n */\r\nexport const waitTransition = (el: HTMLElement | null) => new Promise<HTMLElement | null>((resolve) => {\r\n  if (!el) return resolve(null);\r\n\r\n  let resolved = false;\r\n  let timeoutId: number | undefined;\r\n\r\n  const onEnd = () => {\r\n    if (resolved) return;\r\n    resolved = true;\r\n\r\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\r\n    el.removeEventListener('transitionend', onEnd);\r\n    el.removeEventListener('animationend', onEnd);\r\n    resolve(el);\r\n  };\r\n\r\n  el.addEventListener('transitionend', onEnd);\r\n  el.addEventListener('animationend', onEnd);\r\n\r\n  // Fallback: If no transition happens (e.g. display:none or 0s duration), resolve anyway.\r\n  requestAnimationFrame(() => {\r\n    const s = getComputedStyle(el);\r\n    const transitionDuration = parseFloat(s.transitionDuration) * 1000;\r\n    const animationDuration = parseFloat(s.animationDuration) * 1000;\r\n    const maxDuration = Math.max(transitionDuration, animationDuration);\r\n\r\n    if (maxDuration === 0) {\r\n      onEnd();\r\n    } else {\r\n      // Safety timeout: duration + 50ms buffer\r\n      timeoutId = setTimeout(onEnd, maxDuration + 50) as any;\r\n    }\r\n  });\r\n});\r\n\r\n\r\n// =============================================================================\r\n// 12. OBJECTS & STATE\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with plain JavaScript objects.\r\n * \r\n * Provides functional helpers for common object operations like cloning,\r\n * equality checking, and key picking/omitting.\r\n * \r\n * **Immutability**: These utilities create new objects rather than mutating\r\n * existing ones, following functional programming principles.\r\n * \r\n * **Performance**: For large objects or frequent operations, consider using\r\n * specialized libraries like Lodash or Ramda.\r\n * \r\n * @example\r\n * ```typescript\r\n * const user = { id: 1, name: 'John', email: 'john@example.com', role: 'admin' };\r\n * \r\n * // Deep clone\r\n * const userCopy = Obj.clone(user);\r\n * \r\n * // Check equality\r\n * const isSame = Obj.isEqual(user, userCopy); // true\r\n * \r\n * // Pick specific keys\r\n * const publicData = Obj.pick(user, ['id', 'name']); // { id: 1, name: 'John' }\r\n * \r\n * // Omit sensitive keys\r\n * const safeData = Obj.omit(user, ['email', 'role']); // { id: 1, name: 'John' }\r\n * ```\r\n */\r\nexport const Obj = {\r\n  /**\r\n   * Creates a deep clone of an object.\r\n   * \r\n   * Uses `structuredClone()` if available (modern browsers), falls back to\r\n   * JSON parse/stringify. Note: JSON fallback doesn't preserve functions,\r\n   * undefined values, or circular references.\r\n   * \r\n   * @template T - The type of the object to clone\r\n   * @param obj - The object to clone\r\n   * @returns A deep copy of the object\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const original = { a: 1, b: { c: 2 } };\r\n   * const copy = Obj.clone(original);\r\n   * \r\n   * copy.b.c = 3;\r\n   * console.log(original.b.c); // 2 (unchanged)\r\n   * \r\n   * // Clone arrays\r\n   * const arr = [1, [2, 3], { a: 4 }];\r\n   * const arrCopy = Obj.clone(arr);\r\n   * \r\n   * // Clone complex objects\r\n   * const state = {\r\n   *   user: { id: 1, profile: { name: 'John' } },\r\n   *   settings: { theme: 'dark', notifications: true }\r\n   * };\r\n   * const stateCopy = Obj.clone(state);\r\n   * ```\r\n   */\r\n  clone: <T>(obj: T): T => {\r\n    try { return structuredClone(obj); }\r\n    catch { return JSON.parse(JSON.stringify(obj)); }\r\n  },\r\n\r\n  /**\r\n   * Checks deep equality between two values.\r\n   * \r\n   * Compares values recursively. Uses JSON stringification for deep comparison,\r\n   * so objects with different key orders will be considered different.\r\n   * \r\n   * @param a - First value\r\n   * @param b - Second value\r\n   * @returns True if values are deeply equal\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Primitive equality\r\n   * Obj.isEqual(1, 1); // true\r\n   * Obj.isEqual('a', 'b'); // false\r\n   * \r\n   * // Object equality\r\n   * Obj.isEqual({ a: 1 }, { a: 1 }); // true\r\n   * Obj.isEqual({ a: 1, b: 2 }, { b: 2, a: 1 }); // false (different order)\r\n   * \r\n   * // Nested objects\r\n   * Obj.isEqual(\r\n   *   { user: { name: 'John', age: 30 } },\r\n   *   { user: { name: 'John', age: 30 } }\r\n   * ); // true\r\n   * \r\n   * // Arrays\r\n   * Obj.isEqual([1, 2, 3], [1, 2, 3]); // true\r\n   * Obj.isEqual([1, 2], [2, 1]); // false\r\n   * ```\r\n   */\r\n  isEqual: (a: any, b: any) => a === b || JSON.stringify(a) === JSON.stringify(b),\r\n\r\n  /**\r\n   * Creates a new object with only the specified keys.\r\n   * \r\n   * @template T - The object type\r\n   * @template K - The keys to pick\r\n   * @param obj - The source object\r\n   * @param keys - Array of keys to include\r\n   * @returns A new object with only the specified keys\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const user = {\r\n   *   id: 1,\r\n   *   name: 'John',\r\n   *   email: 'john@example.com',\r\n   *   password: 'secret',\r\n   *   role: 'admin'\r\n   * };\r\n   * \r\n   * // Pick public fields\r\n   * const publicUser = Obj.pick(user, ['id', 'name']);\r\n   * // { id: 1, name: 'John' }\r\n   * \r\n   * // Pick for API response\r\n   * const apiResponse = Obj.pick(user, ['id', 'name', 'email']);\r\n   * \r\n   * // Type-safe picking\r\n   * type User = typeof user;\r\n   * const picked: Pick<User, 'id' | 'name'> = Obj.pick(user, ['id', 'name']);\r\n   * ```\r\n   */\r\n  pick: <T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {\r\n    const ret = {} as Pick<T, K>;\r\n    keys.forEach(k => { if (k in obj) ret[k] = obj[k]; });\r\n    return ret;\r\n  },\r\n\r\n  /**\r\n   * Maps an object's entries into a new object.\r\n   *\r\n   * Supports two styles:\r\n   * - Entry mapping: `(entry) => [newKey, newValue]`\r\n   * - Value mapping: `(value, key) => newValue` (keys preserved)\r\n   *\r\n   * @template T - The object type\r\n   * @template K - The original key type\r\n   * @template V - The original value type\r\n   * @returns A new mapped object\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const user = { id: 1, name: 'Ada', role: 'admin' };\r\n   *\r\n   * // Value mapping (keys preserved)\r\n   * const upper = Obj.map(user, (value) => String(value).toUpperCase());\r\n   * // { id: '1', name: 'ADA', role: 'ADMIN' }\r\n   *\r\n   * // Entry mapping (change keys + values)\r\n   * const pairs = Obj.map(user, ([key, value]) => [`user_${key}`, value]);\r\n   * // { user_id: 1, user_name: 'Ada', user_role: 'admin' }\r\n   * ```\r\n   */\r\n  map: ((obj: Record<string, any>, mapper: any) => {\r\n    const entries = Object.entries(obj);\r\n    const isEntryMapper = mapper.length <= 1;\r\n    const result: Record<PropertyKey, any> = {};\r\n\r\n    if (isEntryMapper) {\r\n      entries.forEach(([key, value]) => {\r\n        const [newKey, newValue] = mapper([key, value]);\r\n        result[newKey] = newValue;\r\n      });\r\n      return result;\r\n    }\r\n\r\n    entries.forEach(([key, value]) => {\r\n      result[key] = mapper(value, key);\r\n    });\r\n\r\n    return result;\r\n  }) as {\r\n    <T extends Record<string, any>, R>(\r\n      obj: T,\r\n      mapper: (value: T[keyof T], key: keyof T) => R\r\n    ): { [K in keyof T]: R };\r\n    <T extends Record<string, any>, NK extends PropertyKey, NV>(\r\n      obj: T,\r\n      mapper: (entry: [keyof T, T[keyof T]]) => [NK, NV]\r\n    ): Record<NK, NV>;\r\n  },\r\n\r\n  /**\r\n   * Renames a key on an object (immutable).\r\n   *\r\n   * Supports both call styles:\r\n   * - `Obj.renameKey(obj, from, to)`\r\n   * - `Obj.renameKey(from, to)(obj)`\r\n   *\r\n   * If the source key is missing, returns a shallow copy of the original.\r\n   *\r\n   * @template T - The object type\r\n   * @template F - Key to rename\r\n   * @template N - New key name\r\n   * @returns A new object with the renamed key\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const user = { id: 1, name: 'Ada' };\r\n   *\r\n   * const renamed = Obj.renameKey(user, 'name', 'fullName');\r\n   * // { id: 1, fullName: 'Ada' }\r\n   *\r\n   * const rename = Obj.renameKey('id', 'userId');\r\n   * const renamed2 = rename(user);\r\n   * // { userId: 1, name: 'Ada' }\r\n   * ```\r\n   */\r\n  renameKey: ((objOrFrom: any, fromOrTo: any, to?: any) => {\r\n    const rename = <T extends object, F extends keyof T, N extends PropertyKey>(\r\n      obj: T,\r\n      from: F,\r\n      newKey: N\r\n    ) => {\r\n      const result = { ...obj } as any;\r\n      if (!(from in obj)) {\r\n        return result as Omit<T, F> & Record<N, T[F]>;\r\n      }\r\n      const value = obj[from];\r\n      delete result[from];\r\n      result[newKey] = value;\r\n      return result as Omit<T, F> & Record<N, T[F]>;\r\n    };\r\n\r\n    if (to === undefined) {\r\n      return (obj: Record<PropertyKey, any>) => rename(obj, objOrFrom, fromOrTo);\r\n    }\r\n\r\n    return rename(objOrFrom, fromOrTo, to);\r\n  }) as {\r\n    <T extends object, F extends keyof T, N extends PropertyKey>(\r\n      obj: T,\r\n      from: F,\r\n      to: N\r\n    ): Omit<T, F> & Record<N, T[F]>;\r\n    <F extends PropertyKey, N extends PropertyKey>(\r\n      from: F,\r\n      to: N\r\n    ): <T extends Record<F, any>>(obj: T) => Omit<T, F> & Record<N, T[F]>;\r\n  },\r\n\r\n  /**\r\n   * Safely reads a nested value by path.\r\n   *\r\n   * Supports string paths (`\"a.b.0.c\"`) and array paths (`['a', 'b', 0, 'c']`).\r\n   * Returns `fallback` when the path cannot be resolved.\r\n   *\r\n   * Supports both call styles:\r\n   * - `Obj.get(obj, path, fallback?)`\r\n   * - `Obj.get(path, fallback?)(obj)`\r\n   *\r\n   * @template T - The object type\r\n   * @template R - The fallback type\r\n   * @param obj - The source object\r\n   * @param path - Path to read\r\n   * @param fallback - Optional fallback when missing\r\n   * @returns The resolved value or fallback\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const state = { user: { profile: { name: 'Ada' } }, items: [{ id: 1 }] };\r\n   *\r\n   * Obj.get(state, 'user.profile.name'); // 'Ada'\r\n   * Obj.get(state, ['items', 0, 'id']); // 1\r\n   * Obj.get(state, 'user.missing', 'Unknown'); // 'Unknown'\r\n   *\r\n   * const getUserName = Obj.get('user.profile.name');\r\n   * getUserName(state); // 'Ada'\r\n   * ```\r\n   */\r\n  get: ((objOrPath: any, pathOrFallback?: any, maybeFallback?: any) => {\r\n    const resolvePath = (path: Path) =>\r\n      Array.isArray(path) ? path : path.split('.').filter(Boolean);\r\n\r\n    if (typeof objOrPath === 'string' || Array.isArray(objOrPath)) {\r\n      const path = resolvePath(objOrPath);\r\n      const fallback = pathOrFallback;\r\n      return (obj: any) => {\r\n        let current = obj;\r\n        for (const segment of path) {\r\n          if (current == null) return fallback;\r\n          current = current[segment as keyof typeof current];\r\n        }\r\n        return current === undefined ? fallback : current;\r\n      };\r\n    }\r\n\r\n    const obj = objOrPath;\r\n    const path = resolvePath(pathOrFallback);\r\n    const fallback = maybeFallback;\r\n\r\n    let current = obj;\r\n    for (const segment of path) {\r\n      if (current == null) return fallback;\r\n      current = current[segment as keyof typeof current];\r\n    }\r\n\r\n    return current === undefined ? fallback : current;\r\n  }) as {\r\n    <T extends object, R = undefined>(\r\n      obj: T,\r\n      path: Path,\r\n      fallback?: R\r\n    ): R | any;\r\n    <R = undefined>(\r\n      path: Path,\r\n      fallback?: R\r\n    ): <T extends object>(obj: T) => R | any;\r\n  },\r\n\r\n  /**\r\n   * Sets a nested value by path (immutable).\r\n   *\r\n   * Creates missing objects/arrays as needed. Numeric path segments create arrays.\r\n   * Supports both call styles:\r\n   * - `Obj.set(obj, path, value)`\r\n   * - `Obj.set(path, value)(obj)`\r\n   *\r\n   * @template T - The object type\r\n   * @param obj - The source object\r\n   * @param path - Path to set\r\n   * @param value - Value to assign\r\n   * @returns A new object with the updated value\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const state = { user: { profile: { name: 'Ada' } }, items: [] };\r\n   *\r\n   * const updated = Obj.set(state, 'user.profile.name', 'Grace');\r\n   * const updated2 = Obj.set(state, ['items', 0, 'id'], 42);\r\n   *\r\n   * const setName = Obj.set('user.profile.name', 'Lin');\r\n   * setName(state);\r\n   * ```\r\n   */\r\n  set: ((objOrPath: any, pathOrValue: any, maybeValue?: any) => {\r\n    const resolvePath = (path: Path) =>\r\n      Array.isArray(path) ? path : path.split('.').filter(Boolean);\r\n\r\n    const setAtPath = (obj: any, path: Array<string | number>, value: any): any => {\r\n      if (path.length === 0) return value;\r\n      const [segment, ...rest] = path;\r\n      const isIndex = typeof segment === 'number';\r\n      const base = Array.isArray(obj) ? obj.slice() : { ...(obj ?? (isIndex ? [] : {})) };\r\n\r\n      const nextValue = setAtPath((obj ?? (isIndex ? [] : {}))[segment as any], rest, value);\r\n      (base as any)[segment] = nextValue;\r\n      return base;\r\n    };\r\n\r\n    if (typeof objOrPath === 'string' || Array.isArray(objOrPath)) {\r\n      const path = resolvePath(objOrPath);\r\n      const value = pathOrValue;\r\n      return (obj: any) => setAtPath(obj, path, value);\r\n    }\r\n\r\n    const obj = objOrPath;\r\n    const path = resolvePath(pathOrValue);\r\n    const value = maybeValue;\r\n    return setAtPath(obj, path, value);\r\n  }) as {\r\n    <T extends object>(\r\n      obj: T,\r\n      path: Path,\r\n      value: any\r\n    ): T;\r\n    <T extends object>(\r\n      path: Path,\r\n      value: any\r\n    ): (obj: T) => T;\r\n  },\r\n\r\n  /**\r\n   * Creates a new object excluding the specified keys.\r\n   * \r\n   * @template T - The object type\r\n   * @template K - The keys to omit\r\n   * @param obj - The source object\r\n   * @param keys - Array of keys to exclude\r\n   * @returns A new object without the specified keys\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const user = {\r\n   *   id: 1,\r\n   *   name: 'John',\r\n   *   email: 'john@example.com',\r\n   *   password: 'secret',\r\n   *   role: 'admin'\r\n   * };\r\n   * \r\n   * // Omit sensitive fields\r\n   * const safeUser = Obj.omit(user, ['password']);\r\n   * // { id: 1, name: 'John', email: 'john@example.com', role: 'admin' }\r\n   * \r\n   * // Omit multiple fields\r\n   * const publicUser = Obj.omit(user, ['password', 'email', 'role']);\r\n   * // { id: 1, name: 'John' }\r\n   * \r\n   * // Type-safe omitting\r\n   * type User = typeof user;\r\n   * const omitted: Omit<User, 'password'> = Obj.omit(user, ['password']);\r\n   * ```\r\n   */\r\n  omit: <T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {\r\n    const ret = { ...obj };\r\n    keys.forEach(k => delete ret[k]);\r\n    return ret as Omit<T, K>;\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 13. COLLECTIONS (BATCHING)\r\n// =============================================================================\r\n\r\n/**\r\n * Applies a function to each element in a collection.\r\n * \r\n * Similar to `Array.forEach()` but works with any iterable or array-like object\r\n * (NodeList, HTMLCollection, etc.). Returns the array for further processing.\r\n * \r\n * **Performance**: For simple iterations, native `forEach()` may be faster.\r\n * Use this when you need to work with non-array collections or want the return value.\r\n * \r\n * **vs forEach**: Unlike `forEach()`, this returns the array, allowing for\r\n * further chaining or processing.\r\n * \r\n * @template T - The element type\r\n * @param list - The collection to iterate over (null-safe)\r\n * @returns A curried function that accepts a callback and returns the array\r\n * \r\n * @example\r\n * ```typescript\r\n * // Work with NodeList\r\n * const items = document.querySelectorAll('li');\r\n * batch(items)((el, index) => {\r\n *   el.dataset.index = String(index);\r\n *   el.classList.add('processed');\r\n * });\r\n * \r\n * // Work with HTMLCollection\r\n * const divs = document.getElementsByTagName('div');\r\n * batch(divs)((div) => {\r\n *   div.style.opacity = '0.5';\r\n * });\r\n * \r\n * // Remove all matching elements\r\n * batch(document.querySelectorAll('.temp'))((el) => el.remove());\r\n * \r\n * // Add event listeners to multiple elements\r\n * batch(document.querySelectorAll('button'))((btn, i) => {\r\n *   on(btn)('click', () => console.log('Button', i, 'clicked'));\r\n * });\r\n * \r\n * // Chain with other operations\r\n * const elements = batch(items)((el) => el.classList.add('active'));\r\n * console.log('Processed', elements.length, 'elements');\r\n * \r\n * // Null-safe\r\n * batch(null)((el) => console.log(el)); // Returns []\r\n * ```\r\n */\r\nexport const batch = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\r\n  return (fn: (el: T, index: number) => void): T[] => {\r\n    if (!list) return [];\r\n    const arr = Array.from(list);\r\n    arr.forEach(fn);\r\n    return arr;\r\n  };\r\n};\r\n\r\n/**\r\n * Groups elements by a key function.\r\n * \r\n * Creates an object where keys are the result of the key function and values\r\n * are arrays of elements that produced that key. Useful for categorizing or\r\n * organizing collections of elements.\r\n * \r\n * **Type Inference**: The key function should return a string. For better type\r\n * safety, consider using a union of string literals as the return type.\r\n * \r\n * **Memory Considerations**: For very large collections, consider processing\r\n * in chunks or using a Map instead of a plain object.\r\n * \r\n * @template T - The element type\r\n * @param list - The collection to group (null-safe)\r\n * @returns A curried function that accepts a key function and returns grouped object\r\n * \r\n * @example\r\n * ```typescript\r\n * // Group by data attribute\r\n * const items = document.querySelectorAll('[data-category]');\r\n * const byCategory = groupBy(items)(el => el.dataset.category || 'uncategorized');\r\n * // { electronics: [...], clothing: [...], uncategorized: [...] }\r\n * \r\n * // Group by tag name\r\n * const elements = document.querySelectorAll('*');\r\n * const byTag = groupBy(elements)(el => el.tagName.toLowerCase());\r\n * // { div: [...], span: [...], button: [...], ... }\r\n * \r\n * // Group by class presence\r\n * const allDivs = document.querySelectorAll('div');\r\n * const byStatus = groupBy(allDivs)(el => \r\n *   el.classList.contains('active') ? 'active' : 'inactive'\r\n * );\r\n * \r\n * // Process groups\r\n * Object.entries(byCategory).forEach(([category, elements]) => {\r\n *   console.log(`${category}: ${elements.length} items`);\r\n *   elements.forEach(el => el.classList.add(`category-${category}`));\r\n * });\r\n * \r\n * // Group form inputs by type\r\n * const inputs = document.querySelectorAll('input');\r\n * const byType = groupBy(inputs)(input => input.type);\r\n * // { text: [...], email: [...], checkbox: [...], ... }\r\n * \r\n * // Null-safe\r\n * groupBy(null)(el => 'key'); // {}\r\n * ```\r\n */\r\nexport const groupBy = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\r\n  return (keyFn: (el: T) => string): Record<string, T[]> => {\r\n    const groups: Record<string, T[]> = {};\r\n    if (!list) return groups;\r\n    Array.from(list).forEach(el => {\r\n      const k = keyFn(el);\r\n      (groups[k] = groups[k] || []).push(el);\r\n    });\r\n    return groups;\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a reactive list binding with flexible rendering strategies.\r\n *\r\n * Provides three modes:\r\n * 1. **Default** (no `key`): Simple blow-away rendering - fast for small lists\r\n * 2. **Keyed** (with `key`): Efficient DOM diffing using Map-based reconciliation\r\n * 3. **Custom** (with `reconcile`): User-provided reconciliation for full control\r\n *\r\n * **Performance**:\r\n * - Default mode: O(n) render, best for lists <50 items that rarely change\r\n * - Keyed mode: O(n) diffing, best for dynamic lists with frequent updates\r\n * - Custom mode: Depends on user implementation (e.g., morphdom, nanomorph)\r\n *\r\n * **Memory**: Call `destroy()` when done to prevent memory leaks, especially\r\n * for keyed mode which maintains internal Maps.\r\n *\r\n * @template T - The data item type\r\n * @param container - The parent element to render into (null-safe)\r\n * @param options - Configuration for rendering strategy\r\n * @returns BoundList instance with reactive methods\r\n *\r\n * @example\r\n * ```typescript\r\n * import { List, h } from '@doeixd/dom';\r\n *\r\n * interface Todo {\r\n *   id: number;\r\n *   text: string;\r\n *   done: boolean;\r\n * }\r\n *\r\n * // Simple default mode (blow-away rendering)\r\n * const simpleList = List<string>(container, {\r\n *   render: (item) => h.li({}, [item])\r\n * });\r\n *\r\n * simpleList.set(['Item 1', 'Item 2', 'Item 3']);\r\n *\r\n * // Keyed mode (efficient diffing)\r\n * const todoList = List<Todo>(container, {\r\n *   key: todo => todo.id,\r\n *   render: (todo, index) => h.li({\r\n *     class: { done: todo.done }\r\n *   }, [\r\n *     h.input({\r\n *       attr: { type: 'checkbox' },\r\n *       dataRef: `todo-${todo.id}`\r\n *     }),\r\n *     h.span({}, [`${index + 1}. ${todo.text}`])\r\n *   ]),\r\n *   update: (el, todo, index) => {\r\n *     // Efficient: only update changed parts\r\n *     const checkbox = el.querySelector('input')!;\r\n *     checkbox.checked = todo.done;\r\n *     el.querySelector('span')!.textContent = `${index + 1}. ${todo.text}`;\r\n *     el.classList.toggle('done', todo.done);\r\n *   },\r\n *   onAdd: (el) => el.classList.add('fade-in'),\r\n *   onRemove: (el) => el.classList.add('fade-out')\r\n * });\r\n *\r\n * // Rich API\r\n * todoList.set(todos);\r\n * todoList.append([{ id: 4, text: 'New todo', done: false }]);\r\n * todoList.remove(todo => todo.done);\r\n * todoList.update(todo => todo.id === 1, todo => ({ ...todo, done: true }));\r\n *\r\n * // Custom reconciliation mode\r\n * import morphdom from 'morphdom';\r\n *\r\n * const customList = List<User>(container, {\r\n *   render: (user) => h.div({}, [user.name]),\r\n *   reconcile: (oldItems, newItems, container, renderFn) => {\r\n *     const newHTML = '<div>' +\r\n *       newItems.map(renderFn).map(el => el.outerHTML).join('') +\r\n *       '</div>';\r\n *     morphdom(container, newHTML);\r\n *   }\r\n * });\r\n *\r\n * // Cleanup when done\r\n * todoList.destroy();\r\n * ```\r\n */\r\nexport function List<T>(\r\n  container: HTMLElement | null,\r\n  options: ListOptions<T>\r\n): BoundList<T> {\r\n  // Null-safe no-op implementation\r\n  if (!container) {\r\n    const noop = () => {};\r\n    return {\r\n      set: noop,\r\n      append: noop,\r\n      prepend: noop,\r\n      insert: noop,\r\n      remove: noop,\r\n      update: noop,\r\n      clear: noop,\r\n      items: () => [],\r\n      elements: () => [],\r\n      destroy: noop\r\n    };\r\n  }\r\n\r\n  let currentItems: T[] = [];\r\n\r\n  // Custom reconciliation mode\r\n  if (options.reconcile) {\r\n    return {\r\n      set(items: T[]) {\r\n        options.reconcile!(currentItems, items, container, options.render);\r\n        currentItems = [...items];\r\n      },\r\n      append(items: T[]) {\r\n        const newItems = [...currentItems, ...items];\r\n        options.reconcile!(currentItems, newItems, container, options.render);\r\n        currentItems = newItems;\r\n      },\r\n      prepend(items: T[]) {\r\n        const newItems = [...items, ...currentItems];\r\n        options.reconcile!(currentItems, newItems, container, options.render);\r\n        currentItems = newItems;\r\n      },\r\n      insert(index: number, items: T[]) {\r\n        const newItems = [\r\n          ...currentItems.slice(0, index),\r\n          ...items,\r\n          ...currentItems.slice(index)\r\n        ];\r\n        options.reconcile!(currentItems, newItems, container, options.render);\r\n        currentItems = newItems;\r\n      },\r\n      remove(predicate: (item: T) => boolean) {\r\n        const newItems = currentItems.filter(item => !predicate(item));\r\n        options.reconcile!(currentItems, newItems, container, options.render);\r\n        currentItems = newItems;\r\n      },\r\n      update(predicate: (item: T) => boolean, updater: (item: T) => T) {\r\n        const newItems = currentItems.map(item =>\r\n          predicate(item) ? updater(item) : item\r\n        );\r\n        options.reconcile!(currentItems, newItems, container, options.render);\r\n        currentItems = newItems;\r\n      },\r\n      clear() {\r\n        options.reconcile!(currentItems, [], container, options.render);\r\n        currentItems = [];\r\n      },\r\n      items: () => currentItems,\r\n      elements: () => Array.from(container.children) as HTMLElement[],\r\n      destroy() {\r\n        this.clear();\r\n      }\r\n    };\r\n  }\r\n\r\n  // Keyed mode (efficient diffing)\r\n  if (options.key) {\r\n    const elementMap = new Map<string | number, HTMLElement>();\r\n\r\n    const reconcile = (newItems: T[]): void => {\r\n      const newKeys = new Set(newItems.map(options.key!));\r\n\r\n      // Remove deleted items\r\n      currentItems.forEach(item => {\r\n        const key = options.key!(item);\r\n        if (!newKeys.has(key)) {\r\n          const el = elementMap.get(key);\r\n          if (el) {\r\n            options.onRemove?.(el, item);\r\n            el.remove();\r\n            elementMap.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Build new element list\r\n      const newElements: HTMLElement[] = [];\r\n\r\n      newItems.forEach((item, index) => {\r\n        const key = options.key!(item);\r\n        let el = elementMap.get(key);\r\n\r\n        if (el) {\r\n          // Update existing element\r\n          if (options.update) {\r\n            options.update(el, item, index);\r\n          }\r\n        } else {\r\n          // Create new element\r\n          el = options.render(item, index) as HTMLElement;\r\n          elementMap.set(key, el);\r\n          options.onAdd?.(el, item);\r\n        }\r\n\r\n        newElements.push(el);\r\n      });\r\n\r\n      // Reorder DOM to match new order\r\n      newElements.forEach((el, index) => {\r\n        const currentEl = container.children[index];\r\n        if (currentEl !== el) {\r\n          container.insertBefore(el, currentEl || null);\r\n        }\r\n      });\r\n\r\n      currentItems = [...newItems];\r\n    };\r\n\r\n    return {\r\n      set(items: T[]) {\r\n        reconcile(items);\r\n      },\r\n      append(items: T[]) {\r\n        reconcile([...currentItems, ...items]);\r\n      },\r\n      prepend(items: T[]) {\r\n        reconcile([...items, ...currentItems]);\r\n      },\r\n      insert(index: number, items: T[]) {\r\n        reconcile([\r\n          ...currentItems.slice(0, index),\r\n          ...items,\r\n          ...currentItems.slice(index)\r\n        ]);\r\n      },\r\n      remove(predicate: (item: T) => boolean) {\r\n        reconcile(currentItems.filter(item => !predicate(item)));\r\n      },\r\n      update(predicate: (item: T) => boolean, updater: (item: T) => T) {\r\n        reconcile(currentItems.map(item => predicate(item) ? updater(item) : item));\r\n      },\r\n      clear() {\r\n        reconcile([]);\r\n      },\r\n      items: () => currentItems,\r\n      elements: () => Array.from(container.children) as HTMLElement[],\r\n      destroy() {\r\n        this.clear();\r\n        elementMap.clear();\r\n      }\r\n    };\r\n  }\r\n\r\n  // Default mode (simple blow-away rendering)\r\n  const render = (items: T[]): void => {\r\n    container.replaceChildren(...items.map((item, index) => options.render(item, index)));\r\n    currentItems = [...items];\r\n  };\r\n\r\n  return {\r\n    set(items: T[]) {\r\n      render(items);\r\n    },\r\n    append(items: T[]) {\r\n      render([...currentItems, ...items]);\r\n    },\r\n    prepend(items: T[]) {\r\n      render([...items, ...currentItems]);\r\n    },\r\n    insert(index: number, items: T[]) {\r\n      render([\r\n        ...currentItems.slice(0, index),\r\n        ...items,\r\n        ...currentItems.slice(index)\r\n      ]);\r\n    },\r\n    remove(predicate: (item: T) => boolean) {\r\n      render(currentItems.filter(item => !predicate(item)));\r\n    },\r\n    update(predicate: (item: T) => boolean, updater: (item: T) => T) {\r\n      render(currentItems.map(item => predicate(item) ? updater(item) : item));\r\n    },\r\n    clear() {\r\n      render([]);\r\n    },\r\n    items: () => currentItems,\r\n    elements: () => Array.from(container.children) as HTMLElement[],\r\n    destroy() {\r\n      this.clear();\r\n    }\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// 14. COMPONENT REFS\r\n// =============================================================================\r\n\r\n/**\r\n * Collects elements with `data-ref` attributes into a typed object.\r\n * \r\n * Scans the root element for children with `data-ref` attributes and creates\r\n * an object mapping ref names to elements. Useful for component-based patterns\r\n * where you need quick access to specific child elements.\r\n * \r\n * **Generic Ref Map**: For type-safe ref access, define an interface for your\r\n * expected refs and cast the result.\r\n * \r\n * **Duplicate Handling**: If multiple elements have the same ref name, only\r\n * the last one is kept. Use `groupRefs()` if you need all duplicates.\r\n * \r\n * @param root - The root element to search within (null-safe)\r\n * @returns Object mapping ref names to elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <form>\r\n * //   <input data-ref=\"username\" />\r\n * //   <input data-ref=\"email\" />\r\n * //   <button data-ref=\"submit\">Submit</button>\r\n * // </form>\r\n * \r\n * const form = document.querySelector('form');\r\n * const { username, email, submit } = refs(form);\r\n * \r\n * // Type-safe access\r\n * on(submit)('click', () => {\r\n *   const data = {\r\n *     username: (username as HTMLInputElement).value,\r\n *     email: (email as HTMLInputElement).value\r\n *   };\r\n *   console.log(data);\r\n * });\r\n * \r\n * // Component pattern\r\n * interface ModalRefs {\r\n *   title: HTMLElement;\r\n *   content: HTMLElement;\r\n *   closeBtn: HTMLElement;\r\n * }\r\n * \r\n * const modal = document.querySelector('.modal');\r\n * const r = refs(modal) as unknown as ModalRefs;\r\n * \r\n * modify(r.title)({ text: 'Welcome!' });\r\n * on(r.closeBtn)('click', () => modal.remove());\r\n * \r\n * // Null-safe\r\n * refs(null); // {}\r\n * ```\r\n */\r\nexport const refs = (root: ParentNode | null): Record<string, HTMLElement> => {\r\n  const r: Record<string, HTMLElement> = {};\r\n  if (root) {\r\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\r\n      if (el.dataset.ref) r[el.dataset.ref] = el;\r\n    });\r\n  }\r\n  return r;\r\n};\r\n\r\n/**\r\n * Collects elements with `data-ref` attributes into arrays.\r\n * \r\n * Like `refs()` but allows multiple elements with the same ref name. Each ref\r\n * name maps to an array of all elements with that ref.\r\n * \r\n * **Array Typing**: All refs are arrays, even if only one element exists.\r\n * This ensures consistent access patterns.\r\n * \r\n * **Duplicate Handling**: Unlike `refs()`, this preserves all elements with\r\n * the same ref name in document order.\r\n * \r\n * @param root - The root element to search within (null-safe)\r\n * @returns Object mapping ref names to arrays of elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <ul>\r\n * //   <li data-ref=\"item\">Item 1</li>\r\n * //   <li data-ref=\"item\">Item 2</li>\r\n * //   <li data-ref=\"item\">Item 3</li>\r\n * //   <button data-ref=\"action\">Delete All</button>\r\n * // </ul>\r\n * \r\n * const list = document.querySelector('ul');\r\n * const { item, action } = groupRefs(list);\r\n * \r\n * console.log(item.length); // 3\r\n * console.log(action.length); // 1\r\n * \r\n * // Process all items\r\n * item.forEach((el, index) => {\r\n *   el.dataset.index = String(index);\r\n * });\r\n * \r\n * // Add listeners to all items\r\n * item.forEach(el => {\r\n *   on(el)('click', () => console.log('Item clicked'));\r\n * });\r\n * \r\n * // Single action button (still an array)\r\n * on(action[0])('click', () => {\r\n *   item.forEach(el => el.remove());\r\n * });\r\n * \r\n * // Null-safe\r\n * groupRefs(null); // {}\r\n * ```\r\n */\r\nexport const groupRefs = (root: ParentNode | null): Record<string, HTMLElement[]> => {\r\n  const r: Record<string, HTMLElement[]> = {};\r\n  if (root) {\r\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\r\n      const k = el.dataset.ref;\r\n      if (k) (r[k] = r[k] || []).push(el);\r\n    });\r\n  }\r\n  return r;\r\n};\r\n\r\n/**\r\n * Creates a typed template factory with automatic ref extraction.\r\n *\r\n * Combines element creation with ref extraction into a single, type-safe pattern.\r\n * Perfect for reusable component templates where you need structured access to\r\n * internal elements.\r\n *\r\n * **Type Safety**: Generic parameter ensures refs are properly typed, providing\r\n * autocomplete and compile-time safety.\r\n *\r\n * **Pattern**: Template factory receives a context object that will be populated\r\n * with refs after the element is created, enabling advanced use cases.\r\n *\r\n * @template R - The shape of the refs object (interface mapping names to element types)\r\n * @param templateFactory - Function that creates the template element\r\n * @returns A factory function that creates instances with refs\r\n *\r\n * @example\r\n * ```typescript\r\n * import { viewRefs, h } from '@doeixd/dom';\r\n *\r\n * // Define the refs interface for type safety\r\n * interface CardRefs {\r\n *   title: HTMLHeadingElement;\r\n *   content: HTMLParagraphElement;\r\n *   action: HTMLButtonElement;\r\n * }\r\n *\r\n * // Create the template factory\r\n * const Card = viewRefs<CardRefs>(({ refs }) =>\r\n *   h.div({ class: { card: true } }, [\r\n *     h.h2({ dataRef: 'title' }, ['Default Title']),\r\n *     h.p({ dataRef: 'content' }, ['Default content']),\r\n *     h.button({ dataRef: 'action' }, ['Click Me'])\r\n *   ])\r\n * );\r\n *\r\n * // Create instance\r\n * const { element, refs, update } = Card();\r\n *\r\n * // Modify refs (fully typed!)\r\n * refs.title.textContent = 'My Card'; // âœ… Type-safe\r\n * refs.content.textContent = 'Some content';\r\n *\r\n * // Update root element\r\n * update({ class: { highlighted: true } });\r\n *\r\n * // Mount to DOM\r\n * document.body.appendChild(element);\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Advanced: With initial configuration\r\n * const card = Card({\r\n *   className: 'featured-card',\r\n *   props: { class: { featured: true } }\r\n * });\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Integration with List\r\n * interface TodoItemRefs {\r\n *   checkbox: HTMLInputElement;\r\n *   label: HTMLSpanElement;\r\n *   deleteBtn: HTMLButtonElement;\r\n * }\r\n *\r\n * const TodoItem = viewRefs<TodoItemRefs>(({ refs }) =>\r\n *   h.li({}, [\r\n *     h.input({ dataRef: 'checkbox', attr: { type: 'checkbox' } }),\r\n *     h.span({ dataRef: 'label' }),\r\n *     h.button({ dataRef: 'deleteBtn' }, ['Ã—'])\r\n *   ])\r\n * );\r\n *\r\n * const todoList = List<Todo>(container, {\r\n *   key: todo => todo.id,\r\n *   render: (todo) => {\r\n *     const { element, refs } = TodoItem();\r\n *     refs.label.textContent = todo.text;\r\n *     refs.checkbox.checked = todo.done;\r\n *     refs.deleteBtn.onclick = () => deleteTodo(todo.id);\r\n *     return element;\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport function viewRefs<R extends Record<string, HTMLElement>>(\r\n  templateFactory: (ctx: ViewRefsContext<R>) => HTMLElement\r\n) {\r\n  return (options?: ViewRefsOptions): ViewRefsInstance<R> => {\r\n    // Create context object (refs will be populated after creation)\r\n    const ctx: ViewRefsContext<R> = {\r\n      refs: {} as R\r\n    };\r\n\r\n    // Execute template factory\r\n    const element = templateFactory(ctx);\r\n\r\n    // Extract refs from created element\r\n    const extractedRefs = refs(element) as R;\r\n\r\n    // Populate context refs (so template factory can access them if needed)\r\n    Object.assign(ctx.refs, extractedRefs);\r\n\r\n    // Apply optional configuration\r\n    if (options) {\r\n      if (options.className) {\r\n        const classes = Array.isArray(options.className)\r\n          ? options.className\r\n          : [options.className];\r\n        element.classList.add(...classes);\r\n      }\r\n\r\n      if (options.id) {\r\n        element.id = options.id;\r\n      }\r\n\r\n      if (options.props) {\r\n        modify(element, options.props);\r\n      }\r\n    }\r\n\r\n    // Helper to apply a value to a ref element\r\n    const applyValueToRef = (el: HTMLElement, value: any): void => {\r\n      if (value === null || value === undefined) {\r\n        return;\r\n      }\r\n\r\n      // If value is a string or number, set as text content\r\n      if (typeof value === 'string' || typeof value === 'number') {\r\n        el.textContent = String(value);\r\n      }\r\n      // If value is an object with element properties, use modify\r\n      else if (typeof value === 'object' && !Array.isArray(value)) {\r\n        // Check if it's an ElementProps-like object\r\n        if ('text' in value || 'html' in value || 'class' in value ||\r\n            'style' in value || 'attr' in value) {\r\n          modify(el, value as ElementProps);\r\n        }\r\n        // Special handling for input elements\r\n        else if ('value' in value && 'value' in el) {\r\n          (el as any).value = value.value;\r\n        }\r\n        // Otherwise assume it's ElementProps\r\n        else {\r\n          modify(el, value as ElementProps);\r\n        }\r\n      }\r\n    };\r\n\r\n    return {\r\n      element,\r\n      refs: ctx.refs,\r\n      update(props: ElementProps): void {\r\n        modify(element, props);\r\n      },\r\n      updateRefs(updates: Partial<{[K in keyof R]: any}>): void {\r\n        Object.entries(updates).forEach(([key, value]) => {\r\n          const el = ctx.refs[key as keyof R];\r\n          if (el) {\r\n            applyValueToRef(el, value);\r\n          }\r\n        });\r\n      },\r\n      bind<K extends keyof R>(key: K): (value: any) => void {\r\n        return (value: any) => {\r\n          const el = ctx.refs[key];\r\n          if (el) {\r\n            applyValueToRef(el, value);\r\n          }\r\n        };\r\n      },\r\n      destroy(): void {\r\n        element.remove();\r\n      }\r\n    };\r\n  };\r\n}\r\n\r\n// =============================================================================\r\n// 15. COLOR UTILS\r\n// =============================================================================\r\n\r\n/**\r\n * Converts a color to a specific color space.\r\n * \r\n * Uses CSS `color-mix()` to convert colors between color spaces like sRGB,\r\n * Display P3, etc. Requires a browser environment and modern browser support.\r\n * \r\n * **Browser Support**: Requires support for `color-mix()` function (modern browsers).\r\n * Check compatibility before using in production.\r\n * \r\n * **Color Space Literal Types**: Common values include 'srgb', 'display-p3',\r\n * 'rec2020', 'a98-rgb', 'prophoto-rgb'.\r\n * \r\n * @param color - The color to convert (any valid CSS color)\r\n * @param space - The target color space (defaults to 'srgb')\r\n * @returns The color in the specified color space\r\n * \r\n * @example\r\n * ```typescript\r\n * // Convert to Display P3 (wider gamut)\r\n * const p3Blue = toColorSpace('blue', 'display-p3');\r\n * \r\n * // Convert hex to P3\r\n * const p3Red = toColorSpace('#ff0000', 'display-p3');\r\n * \r\n * // Convert named color\r\n * const p3Green = toColorSpace('green', 'display-p3');\r\n * \r\n * // Use in dynamic theming\r\n * const primaryColor = '#007bff';\r\n * const p3Primary = toColorSpace(primaryColor, 'display-p3');\r\n * CssVar.set(document.documentElement)('--primary-p3', p3Primary);\r\n * \r\n * // Check browser support\r\n * try {\r\n *   const converted = toColorSpace('red', 'display-p3');\r\n *   console.log('P3 supported:', converted);\r\n * } catch (e) {\r\n *   console.log('P3 not supported, using fallback');\r\n * }\r\n * ```\r\n */\r\nexport const toColorSpace = (color: string, space: string = 'srgb'): string => {\r\n  const div = document.createElement('div');\r\n  div.style.color = `color-mix(in ${space}, ${color} 100%, transparent)`;\r\n  document.body.appendChild(div);\r\n  const res = getComputedStyle(div).color;\r\n  div.remove();\r\n  return res;\r\n};\r\n\r\n// =============================================================================\r\n// 16. CLASS CYCLING & STATE MACHINES\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a function that cycles through a list of CSS classes.\r\n * \r\n * Returns a function that, when called, removes the current class and adds\r\n * the next one in the list. Useful for state machines, loading indicators,\r\n * or any cyclical UI states.\r\n * \r\n * **State Machine Type Inference**: For better type safety, define your states\r\n * as a const array with `as const` assertion.\r\n * \r\n * **State Persistence**: The current state is tracked internally. If you need\r\n * to persist state across page reloads, store the current index in localStorage.\r\n * \r\n * @param target - The element to cycle classes on (null-safe)\r\n * @returns A curried function that accepts class array and returns cycle function\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Loading states\r\n * const nextState = cycleClass(button)(['idle', 'loading', 'success', 'error']);\r\n * \r\n * on(button)('click', async () => {\r\n *   nextState(); // idle -> loading\r\n *   try {\r\n *     await fetchData();\r\n *     nextState(); // loading -> success\r\n *   } catch (e) {\r\n *     nextState(); // success -> error (or loading -> error)\r\n *   }\r\n * });\r\n * \r\n * // Traffic light simulation\r\n * const light = document.querySelector('.traffic-light');\r\n * const nextLight = cycleClass(light)(['red', 'yellow', 'green']);\r\n * setInterval(nextLight, 2000); // Cycle every 2 seconds\r\n * \r\n * // Theme cycling\r\n * const themeBtn = document.querySelector('.theme-toggle');\r\n * const cycleTheme = cycleClass(document.documentElement)(\r\n *   ['theme-light', 'theme-dark', 'theme-auto']\r\n * );\r\n * on(themeBtn)('click', cycleTheme);\r\n * \r\n * // Animation states\r\n * const box = document.querySelector('.box');\r\n * const animate = cycleClass(box)(['bounce', 'shake', 'pulse', 'spin']);\r\n * on(box)('click', animate);\r\n * \r\n * // Null-safe\r\n * const noop = cycleClass(null)(['a', 'b']); // Returns () => {}\r\n * ```\r\n */\r\nexport const cycleClass = (target: Element | null) => {\r\n  return (classes: string[]): (() => void) => {\r\n    if (!target) return () => { };\r\n\r\n    return () => {\r\n      const currentIdx = classes.findIndex(c => target.classList.contains(c));\r\n\r\n      // Remove current class if found\r\n      if (currentIdx > -1) target.classList.remove(classes[currentIdx]);\r\n\r\n      // Add next class\r\n      const nextIdx = (currentIdx + 1) % classes.length;\r\n      target.classList.add(classes[nextIdx]);\r\n    };\r\n  };\r\n};\r\n\r\nObject.assign(cls, {\r\n  watch: watchClass,\r\n  cycle: cycleClass\r\n});\r\n\r\n\r\n// =============================================================================\r\n// 17. CLEANUP & TEMPLATES\r\n// =============================================================================\r\n\r\n/**\r\n * Removes all event listeners from an element by cloning it.\r\n * \r\n * Creates a clone of the element and replaces the original with the clone.\r\n * This effectively removes ALL event listeners (both those added via\r\n * addEventListener and inline handlers). The element type is preserved.\r\n * \r\n * **Side Effects**: This is a destructive operation that removes ALL listeners,\r\n * including those you may want to keep. Use with caution.\r\n * \r\n * **Memory Leak Prevention**: Useful when you need to completely reset an\r\n * element's event handlers, especially with third-party libraries that may\r\n * have attached listeners you can't easily remove.\r\n * \r\n * @template T - The element type (preserved in return)\r\n * @param element - The element to strip listeners from (null-safe)\r\n * @returns The cloned element with no listeners, or null\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Add some listeners\r\n * button.addEventListener('click', handler1);\r\n * button.addEventListener('click', handler2);\r\n * button.onclick = handler3;\r\n * \r\n * // Remove ALL listeners\r\n * const cleanButton = stripListeners(button);\r\n * // cleanButton has no listeners, but same content/attributes\r\n * \r\n * // Use case: Reset third-party widget\r\n * const widget = document.querySelector('.third-party-widget');\r\n * const cleanWidget = stripListeners(widget);\r\n * // Now you can attach your own listeners\r\n * \r\n * // Use case: Memory leak cleanup\r\n * const oldElement = document.querySelector('.leaky');\r\n * const fresh = stripListeners(oldElement);\r\n * // Old listeners are garbage collected\r\n * \r\n * // Null-safe\r\n * stripListeners(null); // Returns null\r\n * \r\n * // Note: Element must have a parent\r\n * const orphan = document.createElement('div');\r\n * stripListeners(orphan); // Returns orphan unchanged (no parent)\r\n * ```\r\n */\r\nexport const stripListeners = <T extends Element>(element: T | null): T | null => {\r\n  if (!element || !element.parentNode) return element;\r\n  const copy = element.cloneNode(true) as T;\r\n  element.replaceWith(copy);\r\n  return copy;\r\n};\r\n\r\n\n\r\n/**\r\n * Instantiates a <template> element by ID or reference.\r\n * \r\n * Clones the template's content and optionally applies properties to the\r\n * first element in the fragment. Returns a DocumentFragment that can be\r\n * appended to the DOM.\r\n * \r\n * **Template Pattern**: Templates are great for reusable HTML structures.\r\n * Define once in HTML, instantiate many times in JavaScript.\r\n * \r\n * **Prop Application**: Properties are applied only to the first element child\r\n * in the fragment. For complex templates, use refs or selectors after appending.\r\n * \r\n * @param templateOrSelector - Template element or selector string\r\n * @returns A curried function that accepts props and returns a DocumentFragment\r\n * @throws Error if template is not found or invalid\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <template id=\"card-template\">\r\n * //   <div class=\"card\">\r\n * //     <h3 class=\"title\"></h3>\r\n * //     <p class=\"description\"></p>\r\n * //   </div>\r\n * // </template>\r\n * \r\n * // Instantiate template\r\n * const card = instantiate('#card-template')({\r\n *   class: { featured: true },\r\n *   dataset: { id: '123' }\r\n * });\r\n * \r\n * append(container)(card);\r\n * \r\n * // Multiple instances\r\n * const cards = [\r\n *   { title: 'Card 1', id: '1' },\r\n *   { title: 'Card 2', id: '2' },\r\n *   { title: 'Card 3', id: '3' }\r\n * ].map(data => {\r\n *   const card = instantiate('#card-template')({\r\n *     dataset: { id: data.id }\r\n *   });\r\n *   // Modify after instantiation\r\n *   const title = card.querySelector('.title');\r\n *   if (title) title.textContent = data.title;\r\n *   return card;\r\n * });\r\n * \r\n * // Use with template reference\r\n * const template = document.querySelector('#row-template') as HTMLTemplateElement;\r\n * const row = instantiate(template)({ class: { new: true } });\r\n * \r\n * // No props\r\n * const simple = instantiate('#simple-template')();\r\n * ```\r\n */\r\nexport const instantiate = (templateOrSelector: string | HTMLTemplateElement) => {\r\n  return (rootProps: ElementProps = {}): DocumentFragment => {\r\n    const tpl = typeof templateOrSelector === 'string'\r\n      ? document.querySelector(templateOrSelector) as HTMLTemplateElement\r\n      : templateOrSelector;\r\n\r\n    if (!tpl || !('content' in tpl)) {\r\n      throw new Error(`instantiate: Invalid template '${templateOrSelector}'`);\r\n    }\r\n\r\n    const content = tpl.content.cloneNode(true) as DocumentFragment;\r\n\r\n    // Apply props to the first actual element in the fragment\r\n    if (Object.keys(rootProps).length > 0 && content.firstElementChild) {\r\n      modify(content.firstElementChild as HTMLElement)(rootProps);\r\n    }\r\n\r\n    return content;\r\n  };\r\n};\r\n\r\n/**\r\n * Creates multiple deep clones of a node.\r\n * \r\n * Useful for creating skeleton screens, placeholder lists, or any scenario\r\n * where you need multiple copies of the same element structure.\r\n * \r\n * **Deep Cloning**: Each clone includes all descendants and their attributes,\r\n * but NOT event listeners.\r\n * \r\n * @param element - The node to clone (null-safe)\r\n * @returns A curried function that accepts count and returns array of clones\r\n * \r\n * @example\r\n * ```typescript\r\n * const template = document.querySelector('.card-template');\r\n * \r\n * // Create 5 skeleton cards\r\n * const skeletons = cloneMany(template)(5);\r\n * skeletons.forEach(card => append(container)(card));\r\n * \r\n * // Loading placeholders\r\n * const placeholder = document.querySelector('.placeholder');\r\n * const placeholders = cloneMany(placeholder)(10);\r\n * append(list)(...placeholders);\r\n * \r\n * // Generate list items\r\n * const listItem = el('li')({ class: { item: true } })([]);\r\n * const items = cloneMany(listItem)(20);\r\n * items.forEach((item, i) => {\r\n *   modify(item)({ text: `Item ${i + 1}` });\r\n * });\r\n * append(ul)(...items);\r\n * \r\n * // Null-safe\r\n * cloneMany(null)(5); // Returns []\r\n * ```\r\n */\r\nexport const cloneMany = (element: Node | null) => {\r\n  return (count: number): Node[] => {\r\n    if (!element) return [];\r\n    return Array.from({ length: count }).map(() => element.cloneNode(true));\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 18. GEOMETRY & DIMENSIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Gets the bounding client rectangle of an element.\r\n * \r\n * Returns a DOMRect with position and size information. Safe for null elements\r\n * (returns an empty rect at origin). The rect is relative to the viewport.\r\n * \r\n * **Reflow Considerations**: Reading layout properties like this triggers a reflow.\r\n * Batch reads together and separate from writes for better performance.\r\n * \r\n * @param element - The element to get bounds for (null-safe)\r\n * @returns DOMRect with position and size, or empty rect if null\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * const bounds = rect(div);\r\n * \r\n * console.log(bounds.width, bounds.height);\r\n * console.log(bounds.top, bounds.left);\r\n * console.log(bounds.right, bounds.bottom);\r\n * \r\n * // Check if element is in viewport\r\n * const inViewport = (\r\n *   bounds.top >= 0 &&\r\n *   bounds.left >= 0 &&\r\n *   bounds.bottom <= window.innerHeight &&\r\n *   bounds.right <= window.innerWidth\r\n * );\r\n * \r\n * // Calculate center point\r\n * const centerX = bounds.left + bounds.width / 2;\r\n * const centerY = bounds.top + bounds.height / 2;\r\n * \r\n * // Null-safe\r\n * rect(null); // DOMRect(0, 0, 0, 0)\r\n * ```\r\n */\r\nexport const rect = (element: Element | null): DOMRect => {\r\n  return element ? element.getBoundingClientRect() : new DOMRect(0, 0, 0, 0);\r\n};\r\n\r\n/**\r\n * Gets the element's position relative to the document.\r\n * \r\n * Returns the absolute position from the top-left of the document, accounting\r\n * for scroll position. Unlike `getBoundingClientRect()`, this gives document\r\n * coordinates, not viewport coordinates.\r\n * \r\n * **Viewport Calculation**: Adds current scroll position to viewport coordinates.\r\n * \r\n * @param element - The element to get position for (null-safe)\r\n * @returns Object with top and left coordinates, or {0, 0} if null\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.target');\r\n * const pos = offset(element);\r\n * \r\n * console.log('Distance from document top:', pos.top);\r\n * console.log('Distance from document left:', pos.left);\r\n * \r\n * // Scroll to element position\r\n * window.scrollTo({\r\n *   top: pos.top - 100, // 100px offset from top\r\n *   behavior: 'smooth'\r\n * });\r\n * \r\n * // Calculate distance between elements\r\n * const pos1 = offset(element1);\r\n * const pos2 = offset(element2);\r\n * const distance = Math.sqrt(\r\n *   Math.pow(pos2.left - pos1.left, 2) +\r\n *   Math.pow(pos2.top - pos1.top, 2)\r\n * );\r\n * \r\n * // Null-safe\r\n * offset(null); // { top: 0, left: 0 }\r\n * ```\r\n */\r\nexport const offset = (element: HTMLElement | null) => {\r\n  if (!element) return { top: 0, left: 0 };\r\n  const box = element.getBoundingClientRect();\r\n  const doc = document.documentElement;\r\n  return {\r\n    top: box.top + window.scrollY - doc.clientTop,\r\n    left: box.left + window.scrollX - doc.clientLeft\r\n  };\r\n};\r\n\r\n/**\r\n * Checks if an element is visible in the DOM.\r\n * \r\n * An element is considered visible if it has non-zero dimensions (width or height).\r\n * This checks if the element consumes space in the layout, not if it's actually\r\n * in the viewport or has `visibility: visible`.\r\n * \r\n * **Note**: This doesn't check `visibility`, `opacity`, or viewport position.\r\n * It only checks if the element has layout dimensions.\r\n * \r\n * @param element - The element to check (null-safe)\r\n * @returns True if element has non-zero width or height\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.target');\r\n * \r\n * if (isVisible(element)) {\r\n *   console.log('Element is rendered');\r\n * }\r\n * \r\n * // Check before animating\r\n * if (isVisible(element)) {\r\n *   element.classList.add('animate');\r\n * }\r\n * \r\n * // Hidden elements return false\r\n * element.style.display = 'none';\r\n * isVisible(element); // false\r\n * \r\n * // Zero-sized elements return false\r\n * element.style.width = '0';\r\n * element.style.height = '0';\r\n * isVisible(element); // false\r\n * \r\n * // Null-safe\r\n * isVisible(null); // false\r\n * ```\r\n */\r\nexport const isVisible = (element: HTMLElement | null): boolean => {\r\n  return !!(element && (element.offsetWidth > 0 || element.offsetHeight > 0));\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 19. SCROLL & FOCUS\r\n// =============================================================================\r\n\r\n/**\r\n * Scrolls an element into view.\r\n * \r\n * Uses the native `scrollIntoView()` API with customizable options. Returns\r\n * the element for chaining. Defaults to smooth scrolling with 'start' alignment.\r\n * \r\n * **Accessibility**: Ensure focus management accompanies scrolling for keyboard users.\r\n * \r\n * **Browser Differences**: Smooth scrolling may not work in all browsers.\r\n * The behavior gracefully degrades to instant scrolling.\r\n * \r\n * @param element - The element to scroll into view (null-safe)\r\n * @returns A curried function that accepts options and returns the element\r\n * \r\n * @example\r\n * ```typescript\r\n * const section = document.querySelector('#section-3');\r\n * \r\n * // Smooth scroll to element\r\n * scrollInto(section)();\r\n * \r\n * // Custom options\r\n * scrollInto(section)({\r\n *   behavior: 'smooth',\r\n *   block: 'center',\r\n *   inline: 'nearest'\r\n * });\r\n * \r\n * // Instant scroll\r\n * scrollInto(section)({ behavior: 'auto' });\r\n * \r\n * // Scroll to bottom of element\r\n * scrollInto(section)({ block: 'end' });\r\n * \r\n * // Navigation with scroll\r\n * on(navLink)('click', (e) => {\r\n *   e.preventDefault();\r\n *   const target = document.querySelector(navLink.hash);\r\n *   scrollInto(target)();\r\n *   focus(target)(); // Also focus for accessibility\r\n * });\r\n * \r\n * // Null-safe\r\n * scrollInto(null)(); // No-op, returns null\r\n * ```\r\n */\r\nexport const scrollInto = (element: Element | null) => {\r\n  return (options: ScrollIntoViewOptions = { behavior: 'smooth', block: 'start' }) => {\r\n    element?.scrollIntoView(options);\r\n    return element;\r\n  };\r\n};\r\n\r\n/**\r\n * Sets focus on an element.\r\n * \r\n * Safely focuses an element with optional focus options. Returns the element\r\n * for chaining. Null-safe.\r\n * \r\n * **Accessibility**: Essential for keyboard navigation and screen readers.\r\n * Always ensure focusable elements have visible focus indicators.\r\n * \r\n * @param element - The element to focus (null-safe)\r\n * @returns A curried function that accepts options and returns the element\r\n * \r\n * @example\r\n * ```typescript\r\n * const input = document.querySelector('input');\r\n * \r\n * // Basic focus\r\n * focus(input)();\r\n * \r\n * // Prevent scroll on focus\r\n * focus(input)({ preventScroll: true });\r\n * \r\n * // Focus after modal opens\r\n * const modal = document.querySelector('.modal');\r\n * modal.classList.add('open');\r\n * const firstInput = modal.querySelector('input');\r\n * focus(firstInput)();\r\n * \r\n * // Focus management in forms\r\n * on(form)('submit', (e) => {\r\n *   e.preventDefault();\r\n *   const firstError = form.querySelector('.error');\r\n *   if (firstError) {\r\n *     scrollInto(firstError)();\r\n *     focus(firstError)();\r\n *   }\r\n * });\r\n * \r\n * // Null-safe\r\n * focus(null)(); // No-op, returns null\r\n * ```\r\n */\r\nexport const focus = (element: HTMLElement | null) => {\r\n  return (options?: FocusOptions) => {\r\n    element?.focus(options);\r\n    return element;\r\n  };\r\n};\r\n\r\n/**\r\n * Removes focus from an element.\r\n * \r\n * Blurs the element, removing keyboard focus. Returns the element for chaining.\r\n * \r\n * **Accessibility**: Use carefully - removing focus can disorient keyboard users.\r\n * Usually better to move focus to another element rather than blur.\r\n * \r\n * @param element - The element to blur (null-safe)\r\n * @returns The element\r\n * \r\n * @example\r\n * ```typescript\r\n * const input = document.querySelector('input');\r\n * \r\n * // Remove focus\r\n * blur(input);\r\n * \r\n * // Close dropdown on blur\r\n * on(dropdown)('blur', () => {\r\n *   dropdown.classList.remove('open');\r\n * });\r\n * \r\n * // Validate on blur\r\n * on(input)('blur', () => {\r\n *   if (!input.value) {\r\n *     input.classList.add('error');\r\n *   }\r\n * });\r\n * \r\n * // Null-safe\r\n * blur(null); // No-op, returns null\r\n * ```\r\n */\r\nexport const blur = (element: HTMLElement | null) => {\r\n  element?.blur();\r\n  return element;\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 20. TIMING UTILS (DEBOUNCE / THROTTLE)\r\n// =============================================================================\r\n\r\n/**\r\n * Debounces a function, delaying execution until after a pause in calls.\r\n * \r\n * Creates a debounced version of the function that delays invoking until after\r\n * `ms` milliseconds have elapsed since the last time it was called. Perfect for\r\n * handling rapid events like typing, resizing, or scrolling.\r\n * \r\n * @template T - The function type to debounce\r\n * @param fn - The function to debounce\r\n * @param ms - The number of milliseconds to delay\r\n * @returns A debounced version of the function\r\n * \r\n * @example\r\n * ```typescript\r\n * // Search as user types (waits for pause)\r\n * const searchInput = document.querySelector('input');\r\n * const performSearch = debounce((query: string) => {\r\n *   console.log('Searching for:', query);\r\n *   // API call here\r\n * }, 300);\r\n * \r\n * on(searchInput)('input', (e) => {\r\n *   performSearch((e.target as HTMLInputElement).value);\r\n * });\r\n * \r\n * // Auto-save after user stops typing\r\n * const autoSave = debounce((content: string) => {\r\n *   localStorage.setItem('draft', content);\r\n *   console.log('Saved!');\r\n * }, 1000);\r\n * \r\n * on(textarea)('input', (e) => {\r\n *   autoSave((e.target as HTMLTextAreaElement).value);\r\n * });\r\n * \r\n * // Window resize handler\r\n * const handleResize = debounce(() => {\r\n *   console.log('Window resized to:', window.innerWidth);\r\n *   // Expensive layout calculations here\r\n * }, 250);\r\n * \r\n * on(window)('resize', handleResize);\r\n * ```\r\n */\r\nexport const debounce = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\r\n  let timeoutId: ReturnType<typeof setTimeout>;\r\n  return (...args: Parameters<T>): void => {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => fn(...args), ms);\r\n  };\r\n};\r\n\r\n/**\r\n * Throttles a function, limiting how often it can be called.\r\n * \r\n * Creates a throttled version that only invokes the function at most once per\r\n * `ms` milliseconds. Unlike debounce, throttle ensures the function is called\r\n * regularly during continuous events. Perfect for scroll, mousemove, or other\r\n * high-frequency events.\r\n * \r\n * @template T - The function type to throttle\r\n * @param fn - The function to throttle\r\n * @param ms - The minimum time between calls in milliseconds\r\n * @returns A throttled version of the function\r\n * \r\n * @example\r\n * ```typescript\r\n * // Scroll progress indicator (updates max once per 16ms)\r\n * const updateScrollProgress = throttle(() => {\r\n *   const scrollPercent = (window.scrollY / document.body.scrollHeight) * 100;\r\n *   progressBar.style.width = `${scrollPercent}%`;\r\n * }, 16); // ~60fps\r\n * \r\n * on(window)('scroll', updateScrollProgress);\r\n * \r\n * // Mouse tracking (limits updates)\r\n * const trackMouse = throttle((e: MouseEvent) => {\r\n *   console.log('Mouse at:', e.clientX, e.clientY);\r\n *   // Update parallax effect, etc.\r\n * }, 50);\r\n * \r\n * on(document)('mousemove', trackMouse);\r\n * \r\n * // Infinite scroll (check max once per 200ms)\r\n * const checkInfiniteScroll = throttle(() => {\r\n *   const scrollBottom = window.scrollY + window.innerHeight;\r\n *   if (scrollBottom >= document.body.scrollHeight - 100) {\r\n *     loadMoreItems();\r\n *   }\r\n * }, 200);\r\n * \r\n * on(window)('scroll', checkInfiniteScroll);\r\n * \r\n * // Difference from debounce:\r\n * // - Debounce: Waits for pause, then executes once\r\n * // - Throttle: Executes regularly during continuous events\r\n * ```\r\n */\r\nexport const throttle = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\r\n  let lastTime = 0;\r\n  return (...args: Parameters<T>): void => {\r\n    const now = Date.now();\r\n    if (now - lastTime >= ms) {\r\n      fn(...args);\r\n      lastTime = now;\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 21. WEB STORAGE (LOCAL & SESSION)\r\n// =============================================================================\r\n\r\n/**\r\n * Factory for creating typed storage wrappers.\r\n * \r\n * Creates storage utilities that automatically handle JSON serialization/deserialization.\r\n * Used internally to create `Local` and `Session` storage objects.\r\n * \r\n * **Generic Type Inference**: Use type parameters for type-safe storage access.\r\n * \r\n * **Schema Validation**: For production apps, consider adding schema validation\r\n * to ensure stored data matches expected types.\r\n * \r\n * **Quota Limits**: Most browsers limit localStorage to ~5-10MB. Check quota\r\n * before storing large amounts of data.\r\n * \r\n * **Error Handling**: Storage operations can fail (quota exceeded, private browsing).\r\n * Wrap in try-catch for production use.\r\n * \r\n * @param provider - The Storage object (localStorage or sessionStorage)\r\n * @returns Object with get, set, remove, and clear methods\r\n */\r\nconst createStorage = (provider: Storage) => ({\r\n  /**\r\n   * Gets a value from storage and parses it.\r\n   * \r\n   * Attempts to parse as JSON. If parsing fails, returns the raw string.\r\n   * Returns null if the key doesn't exist.\r\n   * \r\n   * @template T - The expected type of the stored value\r\n   * @param key - The storage key\r\n   * @returns The parsed value or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Get with type inference\r\n   * interface User { id: number; name: string; }\r\n   * const user = Local.get<User>('user');\r\n   * \r\n   * // Get primitive\r\n   * const count = Local.get<number>('count');\r\n   * \r\n   * // Get with fallback\r\n   * const theme = Local.get<string>('theme') || 'light';\r\n   * ```\r\n   */\r\n  get: <T>(key: string): T | null => {\r\n    const val = provider.getItem(key);\r\n    if (!val) return null;\r\n    try { return JSON.parse(val) as T; }\r\n    catch { return val as unknown as T; }\r\n  },\r\n\r\n  /**\r\n   * Sets a value in storage (auto-stringifies objects).\r\n   * \r\n   * Objects are JSON stringified. Primitives are converted to strings.\r\n   * \r\n   * @param key - The storage key\r\n   * @returns A curried function that accepts the value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Store object\r\n   * Local.set('user')({ id: 1, name: 'John' });\r\n   * \r\n   * // Store primitive\r\n   * Local.set('count')(42);\r\n   * Local.set('theme')('dark');\r\n   * \r\n   * // Error handling\r\n   * try {\r\n   *   Local.set('largeData')(hugeObject);\r\n   * } catch (e) {\r\n   *   console.error('Storage quota exceeded');\r\n   * }\r\n   * ```\r\n   */\r\n  set: (key: string) => (value: any): void => {\r\n    const val = typeof value === 'object' ? JSON.stringify(value) : String(value);\r\n    provider.setItem(key, val);\r\n  },\r\n\r\n  /**\r\n   * Removes a key from storage.\r\n   * \r\n   * @param key - The storage key to remove\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * Local.remove('user');\r\n   * Session.remove('tempData');\r\n   * ```\r\n   */\r\n  remove: (key: string) => provider.removeItem(key),\r\n\r\n  /**\r\n   * Clears all storage.\r\n   * \r\n   * **Warning**: This removes ALL keys from the storage, not just those\r\n   * created by your app. Use with caution.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Clear all localStorage\r\n   * Local.clear();\r\n   * \r\n   * // Clear session storage\r\n   * Session.clear();\r\n   * ```\r\n   */\r\n  clear: () => provider.clear()\r\n});\r\n\r\n/**\r\n * localStorage wrapper with automatic JSON serialization.\r\n * \r\n * Provides type-safe access to localStorage with automatic parsing/stringification.\r\n * Data persists across browser sessions until explicitly cleared.\r\n * \r\n * **Quota Limits**: ~5-10MB in most browsers. Check `navigator.storage.estimate()`\r\n * for available quota.\r\n * \r\n * **Error Handling**: Can throw QuotaExceededError. Wrap in try-catch for production.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Store user data\r\n * interface User { id: number; name: string; email: string; }\r\n * const user: User = { id: 1, name: 'John', email: 'john@example.com' };\r\n * Local.set('user')(user);\r\n * \r\n * // Retrieve user data\r\n * const savedUser = Local.get<User>('user');\r\n * if (savedUser) {\r\n *   console.log(savedUser.name);\r\n * }\r\n * \r\n * // Store app settings\r\n * Local.set('settings')({\r\n *   theme: 'dark',\r\n *   language: 'en',\r\n *   notifications: true\r\n * });\r\n * \r\n * // Remove item\r\n * Local.remove('tempData');\r\n * \r\n * // Clear all\r\n * Local.clear();\r\n * ```\r\n */\r\nexport const Local = createStorage(window.localStorage);\r\n/**\r\n * sessionStorage wrapper with automatic JSON serialization.\r\n * \r\n * Provides type-safe access to sessionStorage. Data persists only for the\r\n * current browser session (tab). Cleared when the tab is closed.\r\n * \r\n * **Use Cases**: Temporary data, form drafts, wizard state, tab-specific settings.\r\n * \r\n * **Quota Limits**: Similar to localStorage (~5-10MB).\r\n * \r\n * @example\r\n * ```typescript\r\n * // Store temporary form data\r\n * Session.set('formDraft')({\r\n *   name: 'John',\r\n *   email: 'john@example.com',\r\n *   message: 'Hello...'\r\n * });\r\n * \r\n * // Retrieve on page reload\r\n * const draft = Session.get('formDraft');\r\n * if (draft) {\r\n *   Form.populate(form)(draft);\r\n * }\r\n * \r\n * // Multi-step wizard\r\n * Session.set('wizardStep')(2);\r\n * Session.set('wizardData')({ step1: {...}, step2: {...} });\r\n * \r\n * // Clear on completion\r\n * Session.remove('wizardStep');\r\n * Session.remove('wizardData');\r\n * ```\r\n */\r\nexport const Session = createStorage(window.sessionStorage);\r\n\r\n\r\n// =============================================================================\r\n// 22. COOKIES\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with browser cookies.\r\n * \r\n * Provides a simple API for getting, setting, and removing cookies with\r\n * automatic URL encoding/decoding.\r\n * \r\n * **Security**: Cookies are sent with every request to the domain. Use `secure`\r\n * and `httpOnly` flags for sensitive data. Consider using localStorage for\r\n * client-side only data.\r\n * \r\n * **Size Limits**: Cookies are limited to ~4KB per cookie, ~20 cookies per domain.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Set a cookie\r\n * Cookie.set('theme')('dark')({ days: 30 });\r\n * \r\n * // Get a cookie\r\n * const theme = Cookie.get('theme'); // \"dark\"\r\n * \r\n * // Remove a cookie\r\n * Cookie.remove('theme');\r\n * ```\r\n */\r\nexport const Cookie = {\r\n  /**\r\n   * Gets a cookie value by name.\r\n   * \r\n   * Returns the decoded cookie value or null if not found.\r\n   * \r\n   * @param name - The cookie name\r\n   * @returns The decoded cookie value or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const token = Cookie.get('auth_token');\r\n   * if (token) {\r\n   *   // User is authenticated\r\n   * }\r\n   * \r\n   * const userId = Cookie.get('user_id');\r\n   * const preferences = Cookie.get('prefs');\r\n   * ```\r\n   */\r\n  get: (name: string): string | null => {\r\n    const v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');\r\n    return v ? decodeURIComponent(v[2]) : null;\r\n  },\r\n\r\n  /**\r\n   * Sets a cookie with optional expiration and security settings.\r\n   * \r\n   * **Security Options**:\r\n   * - `secure`: Only send over HTTPS (recommended for production)\r\n   * - `path`: Limit cookie to specific path (defaults to '/')\r\n   * - `days`: Expiration in days (omit for session cookie)\r\n   * \r\n   * @param name - The cookie name\r\n   * @returns A curried function that accepts value and options\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Session cookie (expires when browser closes)\r\n   * Cookie.set('session_id')('abc123')();\r\n   * \r\n   * // Persistent cookie (7 days)\r\n   * Cookie.set('theme')('dark')({ days: 7 });\r\n   * \r\n   * // Secure cookie (HTTPS only)\r\n   * Cookie.set('auth_token')('secret')({ days: 1, secure: true });\r\n   * \r\n   * // Path-specific cookie\r\n   * Cookie.set('admin_pref')('value')({ path: '/admin', days: 30 });\r\n   * \r\n   * // Remember me (1 year)\r\n   * Cookie.set('remember')('true')({ days: 365 });\r\n   * ```\r\n   */\r\n  set: (name: string) => (value: string) => (options: { days?: number, path?: string, secure?: boolean } = {}) => {\r\n    let d = new Date();\r\n    d.setTime(d.getTime() + 24 * 60 * 60 * 1000 * (options.days || 0));\r\n    document.cookie = `${name}=${encodeURIComponent(value)}`\r\n      + `;path=${options.path || '/'}`\r\n      + (options.days ? `;expires=${d.toUTCString()}` : '')\r\n      + (options.secure ? ';secure' : '');\r\n  },\r\n\r\n  /**\r\n   * Removes a cookie by setting its expiration to the past.\r\n   * \r\n   * @param name - The cookie name to remove\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Logout: remove auth cookie\r\n   * Cookie.remove('auth_token');\r\n   * \r\n   * // Clear preferences\r\n   * Cookie.remove('theme');\r\n   * Cookie.remove('language');\r\n   * ```\r\n   */\r\n  remove: (name: string) => {\r\n    Cookie.set(name)('')({ days: -1 });\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 23. NETWORK (FETCH WRAPPER)\r\n// =============================================================================\r\n\r\n/**\r\n * HTTP utilities - A lightweight, functional wrapper around the Fetch API.\r\n * \r\n * Provides type-safe HTTP methods with automatic JSON handling, error checking,\r\n * and a curried API for flexible composition.\r\n * \r\n * **Error Handling**: All methods throw on non-2xx responses. Wrap in try-catch\r\n * for production use.\r\n * \r\n * **CORS Considerations**: \r\n * - Credentials are not included by default. Add `credentials: 'include'` to headers for cookies.\r\n * - Preflight requests (OPTIONS) are handled automatically by the browser.\r\n * - Server must set appropriate CORS headers (Access-Control-Allow-Origin, etc.).\r\n * \r\n * **Type Safety**: Use generic type parameters for response typing.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define response types\r\n * interface User { id: number; name: string; email: string; }\r\n * interface ApiError { error: string; code: number; }\r\n * \r\n * // GET with type safety\r\n * try {\r\n *   const user = await Http.get<User>('/api/user/123');\r\n *   console.log(user.name);\r\n * } catch (error) {\r\n *   console.error('Failed to fetch user:', error);\r\n * }\r\n * \r\n * // POST with curried API\r\n * const response = await Http.post('/api/users')\r\n *   ({ name: 'John', email: 'john@example.com' })\r\n *   ({ 'Authorization': 'Bearer token123' });\r\n * \r\n * // Error handling with typed responses\r\n * try {\r\n *   const data = await Http.get<User>('/api/user');\r\n * } catch (err) {\r\n *   if (err instanceof Error) {\r\n *     // Parse error message for status code\r\n *     if (err.message.includes('404')) {\r\n *       console.log('User not found');\r\n *     }\r\n *   }\r\n * }\r\n * \r\n * // Retry pattern\r\n * async function fetchWithRetry<T>(\r\n *   url: string,\r\n *   maxRetries = 3,\r\n *   delay = 1000\r\n * ): Promise<T> {\r\n *   for (let i = 0; i < maxRetries; i++) {\r\n *     try {\r\n *       return await Http.get<T>(url);\r\n *     } catch (error) {\r\n *       if (i === maxRetries - 1) throw error;\r\n *       await wait(delay * (i + 1)); // Exponential backoff\r\n *     }\r\n *   }\r\n *   throw new Error('Max retries exceeded');\r\n * }\r\n * \r\n * // CORS with credentials\r\n * const data = await Http.get<User>(\r\n *   'https://api.example.com/user',\r\n *   { 'credentials': 'include' } as any\r\n * );\r\n * ```\r\n */\r\n\r\n\r\n\r\n// =============================================================================\r\n// 24. SERVICE WORKER\r\n// =============================================================================\r\n\r\n/**\r\n * Service Worker utilities for Progressive Web Apps (PWAs).\r\n * \r\n * Provides helpers for registering service workers, handling updates, and\r\n * communicating with the service worker.\r\n * \r\n * **Browser Support**: Check for 'serviceWorker' in navigator before using.\r\n * \r\n * **Lifecycle Events**:\r\n * 1. **Installing**: Service worker is being installed\r\n * 2. **Installed/Waiting**: New version is waiting to activate\r\n * 3. **Activating**: Service worker is taking control\r\n * 4. **Activated**: Service worker is controlling the page\r\n * \r\n * **Update Strategy**: Service workers update when:\r\n * - User navigates to a page in scope\r\n * - An event like push/sync occurs\r\n * - You call `registration.update()`\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic registration\r\n * const registration = await SW.register('/sw.js');\r\n * if (registration) {\r\n *   console.log('Service worker registered');\r\n * }\r\n * \r\n * // Handle updates\r\n * const reg = await SW.register('/sw.js');\r\n * if (reg) {\r\n *   reg.addEventListener('updatefound', () => {\r\n *     const newWorker = reg.installing;\r\n *     newWorker?.addEventListener('statechange', () => {\r\n *       if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\r\n *         // New version available\r\n *         if (confirm('New version available! Reload?')) {\r\n *           window.location.reload();\r\n *         }\r\n *       }\r\n *     });\r\n *   });\r\n * }\r\n * \r\n * // Send message to service worker\r\n * SW.post({ type: 'CACHE_CLEAR' });\r\n * SW.post({ type: 'SKIP_WAITING' });\r\n * ```\r\n */\r\nexport const SW = {\r\n  /**\r\n   * Registers a service worker script.\r\n   * \r\n   * **Registration Scope**: By default, the scope is the directory containing\r\n   * the service worker file. You can override this in registration options.\r\n   * \r\n   * **Update Check**: The browser checks for updates to the service worker\r\n   * script on navigation. Byte-for-byte comparison is used.\r\n   * \r\n   * **Error Handling**: Returns null if registration fails or if service workers\r\n   * are not supported. Check the return value before using.\r\n   * \r\n   * @param scriptPath - Path to the service worker script (e.g., '/sw.js')\r\n   * @param options - Optional registration options\r\n   * @returns Promise resolving to ServiceWorkerRegistration or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic registration\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   console.log('SW registered with scope:', reg.scope);\r\n   * }\r\n   * \r\n   * // Custom scope\r\n   * const reg = await SW.register('/sw.js', { scope: '/app/' });\r\n   * \r\n   * // Check for updates manually\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   // Check for updates every hour\r\n   *   setInterval(() => reg.update(), 60 * 60 * 1000);\r\n   * }\r\n   * \r\n   * // Listen for lifecycle events\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   // New service worker installing\r\n   *   reg.addEventListener('updatefound', () => {\r\n   *     const installing = reg.installing;\r\n   *     console.log('New service worker installing...');\r\n   *     \r\n   *     installing?.addEventListener('statechange', () => {\r\n   *       console.log('State changed to:', installing.state);\r\n   *       // States: installing, installed, activating, activated, redundant\r\n   *     });\r\n   *   });\r\n   * }\r\n   * \r\n   * // Skip waiting and activate immediately\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg?.waiting) {\r\n   *   // Tell waiting SW to skip waiting\r\n   *   SW.post({ type: 'SKIP_WAITING' });\r\n   * }\r\n   * \r\n   * // Unregister service worker\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   await reg.unregister();\r\n   *   console.log('Service worker unregistered');\r\n   * }\r\n   * ```\r\n   */\r\n  register: async (\r\n    scriptPath: string,\r\n    options?: RegistrationOptions\r\n  ): Promise<ServiceWorkerRegistration | null> => {\r\n    if ('serviceWorker' in navigator) {\r\n      try {\r\n        const reg = await navigator.serviceWorker.register(scriptPath, options);\r\n        return reg;\r\n      } catch (e) {\r\n        //console.error('SW Registration Failed:', e);\r\n        return null;\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n\r\n  /**\r\n   * Posts a message to the active service worker.\r\n   * \r\n   * **Controller**: The \"controller\" is the service worker that controls the\r\n   * current page. It's null if no service worker is active.\r\n   * \r\n   * **Message Format**: Use a consistent message format with a `type` field\r\n   * for routing in the service worker.\r\n   * \r\n   * **Response Handling**: To receive responses, listen for 'message' events\r\n   * on navigator.serviceWorker.\r\n   * \r\n   * @param message - The message to send (typically an object with a 'type' field)\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Clear cache\r\n   * SW.post({ type: 'CACHE_CLEAR' });\r\n   * \r\n   * // Skip waiting (activate new service worker immediately)\r\n   * SW.post({ type: 'SKIP_WAITING' });\r\n   * \r\n   * // Custom message with data\r\n   * SW.post({\r\n   *   type: 'CACHE_URLS',\r\n   *   urls: ['/page1.html', '/page2.html']\r\n   * });\r\n   * \r\n   * // Two-way communication\r\n   * // Send message\r\n   * SW.post({ type: 'GET_CACHE_SIZE' });\r\n   * \r\n   * // Listen for response\r\n   * navigator.serviceWorker.addEventListener('message', (event) => {\r\n   *   if (event.data.type === 'CACHE_SIZE') {\r\n   *     console.log('Cache size:', event.data.size);\r\n   *   }\r\n * });\r\n   * \r\n   * // Sync data when online\r\n   * SW.post({\r\n   *   type: 'SYNC_DATA',\r\n   *   data: { userId: 123, updates: [...] }\r\n   * });\r\n   * \r\n   * // Check if controller exists before posting\r\n   * if (navigator.serviceWorker?.controller) {\r\n   *   SW.post({ type: 'PING' });\r\n   * } else {\r\n   *   console.log('No active service worker');\r\n   * }\r\n   * ```\r\n   */\r\n  post: (message: any) => {\r\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\r\n      navigator.serviceWorker.controller.postMessage(message);\r\n    }\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 25. EVENT LIFECYCLE & CLEANUP (LISTENER GROUPS)\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a manager for grouping multiple event listeners and subscriptions.\r\n * \r\n * Essential for preventing memory leaks in Single Page Applications (SPAs)\r\n * and component-based architectures. Allows batch cleanup of all listeners\r\n * when a component unmounts or a feature is disabled.\r\n * \r\n * **Use Cases**:\r\n * - React useEffect cleanup\r\n * - Vue onUnmounted hooks\r\n * - Modal/dialog lifecycle management\r\n * - Feature toggle cleanup\r\n * - Page navigation cleanup\r\n * \r\n * **Memory Leak Prevention**: Always call `clear()` when the component/feature\r\n * is destroyed to prevent memory leaks from orphaned event listeners.\r\n * \r\n * @returns Object with `add` and `clear` methods for managing subscriptions\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const group = createListenerGroup();\r\n * \r\n * // Add multiple listeners\r\n * group.add(on(button)('click', handleClick));\r\n * group.add(on(window)('resize', handleResize));\r\n * group.add(on(document)('keydown', handleKeydown));\r\n * \r\n * // Later: cleanup all at once\r\n * group.clear(); // Removes all 3 listeners\r\n * \r\n * // React integration\r\n * function MyComponent() {\r\n *   useEffect(() => {\r\n *     const listeners = createListenerGroup();\r\n *     \r\n *     listeners.add(on(button)('click', handleClick));\r\n *     listeners.add(on(window)('scroll', handleScroll));\r\n *     listeners.add(Data.bind(element)('count', handleCountChange));\r\n *     \r\n *     // Cleanup on unmount\r\n *     return () => listeners.clear();\r\n *   }, []);\r\n * }\r\n * \r\n * // Vue 3 Composition API\r\n * import { onUnmounted } from 'vue';\r\n * \r\n * export default {\r\n *   setup() {\r\n *     const listeners = createListenerGroup();\r\n *     \r\n *     listeners.add(on(button.value)('click', handleClick));\r\n *     listeners.add(on(window)('resize', handleResize));\r\n *     \r\n *     onUnmounted(() => {\r\n *       listeners.clear();\r\n *     });\r\n *   }\r\n * }\r\n * \r\n * // Modal lifecycle\r\n * class Modal {\r\n *   private listeners = createListenerGroup();\r\n *   \r\n *   open() {\r\n *     this.listeners.add(on(this.closeBtn)('click', () => this.close()));\r\n *     this.listeners.add(on(this.overlay)('click', () => this.close()));\r\n *     this.listeners.add(on(document)('keydown', (e) => {\r\n *       if (e.key === 'Escape') this.close();\r\n *     }));\r\n *   }\r\n *   \r\n *   close() {\r\n *     this.listeners.clear(); // Clean up all listeners\r\n *     remove(this.element);\r\n *   }\r\n * }\r\n * \r\n * // Feature toggle\r\n * const featureListeners = createListenerGroup();\r\n * \r\n * function enableFeature() {\r\n *   featureListeners.add(on(button)('click', featureHandler));\r\n *   featureListeners.add(watchClass(element)('active', handleActiveChange));\r\n * }\r\n * \r\n * function disableFeature() {\r\n *   featureListeners.clear(); // Remove all feature listeners\r\n * }\r\n * \r\n * // Page navigation cleanup\r\n * let currentPageListeners = createListenerGroup();\r\n * \r\n * function navigateTo(page: string) {\r\n *   // Clean up previous page\r\n *   currentPageListeners.clear();\r\n *   \r\n *   // Set up new page\r\n *   currentPageListeners = createListenerGroup();\r\n *   currentPageListeners.add(on(pageElement)('click', handlePageClick));\r\n *   // ... more listeners\r\n * }\r\n * \r\n * // Combining with other cleanup\r\n * const group = createListenerGroup();\r\n * \r\n * // Add regular listeners\r\n * group.add(on(button)('click', handler));\r\n * \r\n * // Add custom cleanup logic\r\n * group.add(() => {\r\n *   console.log('Custom cleanup');\r\n *   clearInterval(intervalId);\r\n *   cancelAnimationFrame(rafId);\r\n * });\r\n * \r\n * group.clear(); // Runs all cleanup functions\r\n * ```\r\n */\r\nexport const createListenerGroup = () => {\n  const unsubs: Unsubscribe[] = [];\n  let clearCount = 0;\n\n  const add = (fn: Unsubscribe) => {\n    unsubs.push(fn);\n    return fn;\n  };\n\n  return {\n    /**\n     * Registers a cleanup function or unsubscribe callback.\n     * Returns the cleanup for convenient chaining.\n     * \n     * @param fn - The cleanup function to register\n     * \n     * @example\n     * ```typescript\n     * const group = createListenerGroup();\n     * \n     * // Add event listener cleanup\n     * group.add(on(button)('click', handler));\n     * \n     * // Add observer cleanup\n     * group.add(watchClass(element)('active', callback));\n     * \n     * // Add custom cleanup\n     * group.add(() => {\n     *   clearTimeout(timeoutId);\n     *   worker.terminate();\n     * });\n     * ```\n     */\n    add,\n\n    /**\n     * Registers multiple cleanup functions at once.\n     * \n     * @example\n     * ```typescript\n     * group.addMany(\n     *   on(btn)('click', handler),\n     *   on(window)('resize', resizeHandler)\n     * );\n     * ```\n     */\n    addMany: (...fns: Unsubscribe[]) => {\n      fns.forEach((fn) => add(fn));\n      return fns;\n    },\n\n    /**\n     * Runs a generator and auto-registers any cleanups it returns.\n     * If the group is cleared before async work completes, late cleanups\n     * are executed immediately.\n     *\n     * @example\n     * ```typescript\n     * group.auto((register) => {\n     *   register(on(btn)('click', handler));\n     *   return 'ready';\n     * });\n     * ```\n     */\n    auto: <T>(gen: (r: Register) => T | Promise<T>) => {\n      const startClearCount = clearCount;\n      const register: Register = (cleanup) => {\n        if (clearCount !== startClearCount) {\n          cleanup();\n          return cleanup;\n        }\n        unsubs.push(cleanup);\n        return cleanup;\n      };\n\n      return gen(register);\n    },\n\n    /**\n     * Returns the number of registered cleanups.\n     */\n    size: () => unsubs.length,\n\n    /**\n     * Executes all registered cleanup functions and clears the list.\n     * \n     * **Order**: Cleanup functions are called in the order they were added.\n     * \n     * **Idempotent**: Safe to call multiple times - subsequent calls do nothing.\n     * \n     * @example\n     * ```typescript\n     * const group = createListenerGroup();\n     * group.add(on(btn)('click', handler));\n     * group.add(on(window)('resize', resizeHandler));\n     * \n     * group.clear(); // Removes both listeners\n     * group.clear(); // Safe to call again - does nothing\n     * ```\n     */\n    clear: () => {\n      let firstError: unknown = null;\n      const pending = unsubs.splice(0);\n      pending.forEach(fn => {\n        try {\n          fn();\n        } catch (err) {\n          if (!firstError) {\n            firstError = err;\n          }\n        }\n      });\n      clearCount += 1;\n      if (firstError) {\n        throw firstError;\n      }\n    }\n  };\n};\n\r\n\r\n// =============================================================================\r\n// 26. SIGNALS & CONTROLLERS (ABORTCONTROLLER)\r\n// =============================================================================\r\n\r\n/**\r\n * AbortController and AbortSignal utilities for cancellable operations.\r\n * \r\n * Provides helpers for creating abort signals, timeout signals, and wrapping\r\n * promises with cancellation support. Essential for managing async operations\r\n * that may need to be cancelled (fetch requests, animations, long computations).\r\n * \r\n * **Use Cases**:\r\n * - Cancel fetch requests when component unmounts\r\n * - Timeout long-running operations\r\n * - Cancel animations or intervals\r\n * - Abort expensive computations\r\n * \r\n * **Signal Composition**: Multiple operations can share the same signal,\r\n * allowing batch cancellation.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic cancellation\r\n * const { signal, abort } = Signal.create();\r\n * fetch('/api/data', { signal });\r\n * // Later: abort the request\r\n * abort();\r\n * \r\n * // Timeout pattern\r\n * const timeoutSignal = Signal.timeout(5000);\r\n * try {\r\n *   const data = await fetch('/api/slow', { signal: timeoutSignal });\r\n * } catch (error) {\r\n *   if (error.name === 'AbortError') {\r\n *     console.log('Request timed out');\r\n *   }\r\n * }\r\n * \r\n * // Wrap non-fetch promises\r\n * const { signal, abort } = Signal.create();\r\n * const result = await Signal.wrap(\r\n *   longRunningComputation(),\r\n *   signal\r\n * );\r\n * ```\r\n */\r\nexport const Signal = {\r\n  /**\r\n   * Creates a new AbortController and returns its signal and abort function.\r\n   * \r\n   * **Pattern**: Destructure to get both signal and abort function.\r\n   * \r\n   * **Cleanup**: Call abort() to cancel all operations using this signal.\r\n   * \r\n   * @returns Object with `signal` (AbortSignal) and `abort` function\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic usage\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * fetch('/api/users', { signal })\r\n   *   .then(res => res.json())\r\n   *   .catch(err => {\r\n   *     if (err.name === 'AbortError') {\r\n   *       console.log('Request was cancelled');\r\n   *     }\r\n   *   });\r\n   * \r\n   * // Cancel the request\r\n   * abort();\r\n   * \r\n   * // React component cleanup\r\n   * function UserList() {\r\n   *   useEffect(() => {\r\n   *     const { signal, abort } = Signal.create();\r\n   *     \r\n   *     fetch('/api/users', { signal })\r\n   *       .then(res => res.json())\r\n   *       .then(setUsers);\r\n   *     \r\n   *     return () => abort(); // Cancel on unmount\r\n   *   }, []);\r\n   * }\r\n   * \r\n   * // Multiple operations with same signal\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * Promise.all([\r\n   *   fetch('/api/users', { signal }),\r\n   *   fetch('/api/posts', { signal }),\r\n   *   fetch('/api/comments', { signal })\r\n   * ]);\r\n   * \r\n   * // Abort all three requests at once\r\n   * abort();\r\n   * \r\n   * // Conditional abort\r\n   * const { signal, abort } = Signal.create();\r\n   * const button = document.querySelector('button');\r\n   * \r\n   * on(button)('click', () => {\r\n   *   fetch('/api/data', { signal });\r\n   * });\r\n   * \r\n   * on(button)('click', () => {\r\n   *   abort(); // Cancel if clicked again\r\n   * });\r\n   * ```\r\n   */\r\n  create: () => {\r\n    const c = new AbortController();\r\n    return { signal: c.signal, abort: () => c.abort() };\r\n  },\r\n\r\n  /**\r\n   * Creates an AbortSignal that automatically aborts after a timeout.\r\n   * \r\n   * **Browser Support**: Uses native `AbortSignal.timeout()` if available,\r\n   * falls back to manual implementation for older browsers.\r\n   * \r\n   * **Use Case**: Prevent operations from running indefinitely.\r\n   * \r\n   * @param ms - Timeout in milliseconds\r\n   * @returns An AbortSignal that aborts after the specified time\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Timeout fetch request after 5 seconds\r\n   * try {\r\n   *   const response = await fetch('/api/data', {\r\n   *     signal: Signal.timeout(5000)\r\n   *   });\r\n   *   const data = await response.json();\r\n   * } catch (error) {\r\n   *   if (error.name === 'AbortError') {\r\n   *     console.log('Request timed out after 5 seconds');\r\n   *   }\r\n   * }\r\n   * \r\n   * // Different timeouts for different endpoints\r\n   * const fastEndpoint = fetch('/api/fast', {\r\n   *   signal: Signal.timeout(1000)\r\n   * });\r\n   * \r\n   * const slowEndpoint = fetch('/api/slow', {\r\n   *   signal: Signal.timeout(10000)\r\n   * });\r\n   * \r\n   * // Timeout with fallback\r\n   * async function fetchWithFallback(url: string) {\r\n   *   try {\r\n   *     return await fetch(url, { signal: Signal.timeout(3000) });\r\n   *   } catch (error) {\r\n   *     if (error.name === 'AbortError') {\r\n   *       // Return cached data or default\r\n   *       return getCachedData(url);\r\n   *     }\r\n   *     throw error;\r\n   *   }\r\n   * }\r\n   * \r\n   * // Timeout for non-fetch operations\r\n   * const result = await Signal.wrap(\r\n   *   expensiveComputation(),\r\n   *   Signal.timeout(5000)\r\n   * );\r\n   * ```\r\n   */\r\n  timeout: (ms: number): AbortSignal => {\r\n    // Use native if available, fallback for older browsers\r\n    if ('timeout' in AbortSignal) return AbortSignal.timeout(ms);\r\n    const c = new AbortController();\r\n    setTimeout(() => c.abort(), ms);\r\n    return c.signal;\r\n  },\r\n\r\n  /**\r\n   * Wraps a Promise to make it abortable via an AbortSignal.\r\n   * \r\n   * **Behavior**: If the signal aborts, the promise rejects with AbortError.\r\n   * The original promise continues running but its result is ignored.\r\n   * \r\n   * **Error Handling**: Always check for `error.name === 'AbortError'` to\r\n   * distinguish cancellation from other errors.\r\n   * \r\n   * @template T - The promise result type\r\n   * @param promise - The promise to wrap\r\n   * @param signal - Optional AbortSignal to control cancellation\r\n   * @returns The wrapped promise that can be cancelled\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Wrap async function\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * async function processData() {\r\n   *   await wait(1000);\r\n   *   return { result: 'done' };\r\n   * }\r\n   * \r\n   * const result = await Signal.wrap(processData(), signal);\r\n   * \r\n   * // Cancel before completion\r\n   * setTimeout(() => abort(), 500);\r\n   * \r\n   * // Timeout pattern\r\n   * try {\r\n   *   const result = await Signal.wrap(\r\n   *     longComputation(),\r\n   *     Signal.timeout(5000)\r\n   *   );\r\n   * } catch (error) {\r\n   *   if (error.name === 'AbortError') {\r\n   *     console.log('Computation timed out');\r\n   *   }\r\n * }\r\n   * \r\n   * // Animation loop with cancellation\r\n   * async function animateWithCancel(signal: AbortSignal) {\r\n   *   for (let i = 0; i < 100; i++) {\r\n   *     if (signal.aborted) break;\r\n   *     await Signal.wrap(nextFrame(), signal);\r\n   *     element.style.opacity = String(i / 100);\r\n   *   }\r\n   * }\r\n   * \r\n   * const { signal, abort } = Signal.create();\r\n   * animateWithCancel(signal);\r\n   * // Later: abort()\r\n   * \r\n   * // Race with timeout\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * try {\r\n   *   const result = await Promise.race([\r\n   *     Signal.wrap(fetchData(), signal),\r\n   *     wait(5000).then(() => { throw new Error('Timeout'); })\r\n   *   ]);\r\n   * } catch (error) {\r\n   *   console.error('Failed or timed out:', error);\r\n   * }\r\n   * \r\n   * // Cleanup on abort\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * signal.addEventListener('abort', () => {\r\n   *   console.log('Operation cancelled, cleaning up...');\r\n   *   cleanup();\r\n   * });\r\n   * \r\n   * await Signal.wrap(operation(), signal);\r\n   * ```\r\n   */\r\n  wrap: <T>(promise: Promise<T>, signal?: AbortSignal): Promise<T> => {\r\n    if (!signal) return promise;\r\n    if (signal.aborted) return Promise.reject(new DOMException('Aborted', 'AbortError'));\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const abortHandler = () => {\r\n        reject(new DOMException('Aborted', 'AbortError'));\r\n        signal.removeEventListener('abort', abortHandler);\r\n      };\r\n\r\n      signal.addEventListener('abort', abortHandler);\r\n\r\n      promise.then(\r\n        val => { signal.removeEventListener('abort', abortHandler); resolve(val); },\r\n        err => { signal.removeEventListener('abort', abortHandler); reject(err); }\r\n      );\r\n    });\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 27. APP-WIDE PUB/SUB (TYPED EVENT BUS)\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a strongly-typed event bus for application-wide communication.\r\n * \r\n * Provides a type-safe pub/sub system using native EventTarget under the hood.\r\n * Perfect for decoupling components without the overhead of heavy state\r\n * management libraries.\r\n * \r\n * **Type Safety**: Define your event map as a type parameter for full\r\n * IntelliSense support and compile-time checking.\r\n * \r\n * **vs Native Events**: Unlike DOM events, this provides:\r\n * - Type-safe event names and payloads\r\n * - No DOM dependency (works anywhere)\r\n * - Simpler API focused on pub/sub patterns\r\n * \r\n * **Performance**: Uses native EventTarget, so it's as fast as DOM events.\r\n * \r\n * **Memory**: Remember to unsubscribe when components unmount to prevent leaks.\r\n * \r\n * @template Events - Event map type: `{ eventName: payloadType }`\r\n * @returns Object with `on`, `emit`, and `once` methods\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define event types\r\n * interface AppEvents {\r\n *   'user:login': { id: number; name: string; };\r\n *   'user:logout': void;\r\n *   'cart:add': { productId: string; quantity: number; };\r\n *   'cart:remove': { productId: string; };\r\n *   'notification:show': { message: string; type: 'success' | 'error'; };\r\n * }\r\n * \r\n * // Create typed bus\r\n * const bus = createBus<AppEvents>();\r\n * \r\n * // Subscribe with full type safety\r\n * const unsubscribe = bus.on('user:login', (data) => {\r\n *   console.log(`User ${data.name} logged in`); // data is typed!\r\n *   updateUI(data.id);\r\n * });\r\n * \r\n * // Emit events\r\n * bus.emit('user:login', { id: 123, name: 'John' });\r\n * bus.emit('user:logout'); // void events don't need data\r\n * \r\n * // Cleanup\r\n * unsubscribe();\r\n * \r\n * // One-time listeners\r\n * bus.once('user:login', (data) => {\r\n *   console.log('First login:', data.name);\r\n *   // Automatically unsubscribes after first call\r\n * });\r\n * \r\n * // Cross-component communication\r\n * // Component A\r\n * bus.on('cart:add', ({ productId, quantity }) => {\r\n *   updateCartUI(productId, quantity);\r\n *   showNotification(`Added ${quantity} items`);\r\n * });\r\n * \r\n * // Component B\r\n * function addToCart(productId: string, qty: number) {\r\n *   bus.emit('cart:add', { productId, quantity: qty });\r\n * }\r\n * \r\n * // React integration\r\n * function CartBadge() {\r\n *   const [count, setCount] = useState(0);\r\n *   \r\n *   useEffect(() => {\r\n *     const unsub1 = bus.on('cart:add', ({ quantity }) => {\r\n *       setCount(c => c + quantity);\r\n *     });\r\n *     \r\n *     const unsub2 = bus.on('cart:remove', () => {\r\n *       setCount(c => c - 1);\r\n *     });\r\n *     \r\n *     return () => {\r\n *       unsub1();\r\n *       unsub2();\r\n *     };\r\n *   }, []);\r\n *   \r\n *   return <span>{count}</span>;\r\n * }\r\n * \r\n * // Global notification system\r\n * const notifications = createBus<{\r\n *   show: { message: string; type: 'info' | 'success' | 'error'; };\r\n *   hide: void;\r\n * }>();\r\n * \r\n * notifications.on('show', ({ message, type }) => {\r\n *   const toast = createToast(message, type);\r\n *   append(document.body)(toast);\r\n * });\r\n * \r\n * // Anywhere in your app\r\n * notifications.emit('show', {\r\n *   message: 'Saved successfully!',\r\n *   type: 'success'\r\n * });\r\n * ```\r\n */\r\nexport const createBus = <Events extends Record<string, any>>() => {\r\n  const target = new EventTarget();\r\n\r\n  return {\r\n    /**\r\n     * Subscribes to an event.\r\n     * \r\n     * **Type Safety**: Event name and data are fully typed based on the Events map.\r\n     * \r\n     * **Cleanup**: Always store and call the returned unsubscribe function to\r\n     * prevent memory leaks.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to listen for\r\n     * @param handler - Callback function receiving typed event data\r\n     * @returns Unsubscribe function to remove the listener\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'data:updated': { id: number; value: string; };\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Subscribe\r\n     * const unsub = bus.on('data:updated', (data) => {\r\n     *   console.log(`Data ${data.id} = ${data.value}`);\r\n     * });\r\n     * \r\n     * // Unsubscribe\r\n     * unsub();\r\n     * \r\n     * // Multiple subscribers\r\n     * const unsub1 = bus.on('data:updated', updateUI);\r\n     * const unsub2 = bus.on('data:updated', logChange);\r\n     * const unsub3 = bus.on('data:updated', syncToServer);\r\n     * \r\n     * // Cleanup all\r\n     * [unsub1, unsub2, unsub3].forEach(fn => fn());\r\n     * ```\r\n     */\r\n    on: <K extends keyof Events & string>(\r\n      event: K,\r\n      handler: (data: Events[K]) => void\r\n    ): Unsubscribe => {\r\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\r\n      target.addEventListener(event, listener);\r\n      return () => target.removeEventListener(event, listener);\r\n    },\r\n\r\n    /**\r\n     * Emits an event with typed data.\r\n     * \r\n     * **Type Checking**: TypeScript ensures you provide the correct data type\r\n     * for each event.\r\n     * \r\n     * **Synchronous**: All handlers are called synchronously in registration order.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to emit\r\n     * @param data - The event data (type-checked against Events map)\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'save': { id: number; data: object; };\r\n     *   'delete': { id: number; };\r\n     *   'clear': void;\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Valid emissions\r\n     * bus.emit('save', { id: 1, data: { name: 'John' } });\r\n     * bus.emit('delete', { id: 1 });\r\n     * bus.emit('clear'); // void event\r\n     * \r\n     * // TypeScript errors:\r\n     * // bus.emit('save', { id: 1 }); // Missing 'data'\r\n     * // bus.emit('delete', {}); // Missing 'id'\r\n     * // bus.emit('clear', {}); // Unexpected data\r\n     * \r\n     * // Conditional emit\r\n     * if (hasChanges) {\r\n     *   bus.emit('save', { id, data: formData });\r\n     * }\r\n     * ```\r\n     */\r\n    emit: <K extends keyof Events & string>(event: K, data: Events[K]) => {\r\n      target.dispatchEvent(new CustomEvent(event, { detail: data }));\r\n    },\r\n\r\n    /**\r\n     * Subscribes to an event for one-time execution.\r\n     * \r\n     * **Auto-Unsubscribe**: The handler is automatically removed after the\r\n     * first time it's called.\r\n     * \r\n     * **Use Cases**: Initialization events, one-time confirmations, first-load actions.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to listen for\r\n     * @param handler - Callback function (called only once)\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'app:ready': void;\r\n     *   'user:firstLogin': { userId: number; };\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Run once when app is ready\r\n     * bus.once('app:ready', () => {\r\n     *   console.log('App initialized');\r\n     *   loadUserPreferences();\r\n     * });\r\n     * \r\n     * // First login bonus\r\n     * bus.once('user:firstLogin', ({ userId }) => {\r\n     *   showWelcomeModal(userId);\r\n     *   grantSignupBonus(userId);\r\n     * });\r\n     * \r\n     * // Emit multiple times - handler only runs once\r\n     * bus.emit('app:ready');\r\n     * bus.emit('app:ready'); // Handler doesn't run again\r\n     * ```\r\n     */\r\n    once: <K extends keyof Events & string>(\r\n      event: K,\r\n      handler: (data: Events[K]) => void\r\n    ): void => {\r\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\r\n      target.addEventListener(event, listener, { once: true });\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 28. FLUENT WRAPPER ($)\r\n// =============================================================================\r\n\r\n/**\r\n * Wraps a single element in a fluent object with all fdom functions pre-bound.\r\n * \r\n * Provides an object-oriented, method-chaining API as an alternative to the\r\n * functional style. All methods return the wrapper (except getters), enabling\r\n * jQuery-like chaining.\r\n * \r\n * **vs Functional Style**:\r\n * - **Fluent**: `$(btn).addClass('active').css({ color: 'red' }).on('click', handler)`\r\n * - **Functional**: `cls.add(btn)('active'); css(btn)({ color: 'red' }); on(btn)('click', handler)`\r\n * \r\n * **When to Use**:\r\n * - **Fluent ($)**: When performing multiple operations on the same element\r\n * - **Functional**: When working with multiple elements or in functional pipelines\r\n * \r\n * **Type Preservation**: The generic type parameter preserves the element type\r\n * throughout the chain.\r\n * \r\n * **Null Safety**: All methods handle null elements gracefully.\r\n * \r\n * @template T - The HTML element type (inferred from input)\r\n * @param target - The element to wrap (null-safe)\r\n * @returns Fluent wrapper object with all fdom methods pre-bound\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic chaining\r\n * const button = document.querySelector('button');\r\n * $(button)\r\n *   .modify({ text: 'Click me' })\r\n *   .addClass('btn', 'btn-primary')\r\n *   .css({ padding: '10px 20px' })\r\n *   .on('click', () => console.log('Clicked!'));\r\n * \r\n * // vs Functional style (same result)\r\n * modify(button)({ text: 'Click me' });\r\n * cls.add(button)('btn', 'btn-primary');\r\n * css(button)({ padding: '10px 20px' });\r\n * on(button)('click', () => console.log('Clicked!'));\r\n * \r\n * // Type preservation\r\n * const input = document.querySelector('input');\r\n * $(input)\r\n *   .modify({ value: 'test' })\r\n *   .val('new value')  // Type-safe: knows it's an input\r\n *   .onInput((val) => console.log(val));\r\n * \r\n * // Conditional chaining\r\n * $(element)\r\n *   .addClass('base')\r\n *   .toggleClass('active', isActive)\r\n *   .css({ opacity: isVisible ? '1' : '0' });\r\n * \r\n * // Event handling with chaining\r\n * $(form)\r\n *   .on('submit', (e) => {\r\n *     e.preventDefault();\r\n *     const data = Form.serialize(form);\r\n *     submitData(data);\r\n *   })\r\n *   .on('reset', () => console.log('Form reset'));\r\n * \r\n * // Access raw element\r\n * const wrapped = $(button);\r\n * const raw = wrapped.raw; // Get underlying HTMLElement\r\n * \r\n * // Complex UI setup\r\n * $(modal)\r\n *   .addClass('modal')\r\n *   .css({ display: 'none' })\r\n *   .on('click', (e) => {\r\n *     if (e.target === modal) closeModal();\r\n *   })\r\n *   .append(\r\n *     el('div')({ class: { 'modal-content': true } })([\r\n *       el('h2')({})(['Modal Title']),\r\n *       el('p')({})(['Modal content'])\r\n *     ])\r\n *   );\r\n * \r\n * // Animation with chaining\r\n * $(element)\r\n *   .addClass('fade-in')\r\n *   .waitTransition()\r\n *   .then(() => {\r\n *     $(element).removeClass('fade-in').addClass('visible');\r\n *   });\r\n * \r\n * // Null-safe operations\r\n * const missing = document.querySelector('.nonexistent');\r\n * $(missing).addClass('test'); // No error, safely ignored\r\n * \r\n * // Comparison: Fluent vs Functional\r\n * // Fluent: Better for single-element operations\r\n * $(button).addClass('active').css({ color: 'red' });\r\n * \r\n * // Functional: Better for multiple elements\r\n * [button1, button2, button3].forEach(btn => {\r\n *   cls.add(btn)('active');\r\n *   css(btn)({ color: 'red' });\r\n * });\r\n * \r\n * // Or use $$ for batch operations\r\n * $$('.button').addClass('active').css({ color: 'red' });\r\n * ```\r\n */\r\nexport const $ = <T extends HTMLElement>(target: T | null) => {\r\n  // Helper to bind target-first functions and return wrapper for chaining\r\n  const chain = <F extends (t: any) => (...args: any[]) => any>(fn: F) =>\r\n    (...args: Parameters<ReturnType<F>>) => {\r\n      if (target) fn(target)(...args);\r\n      return wrapper;\r\n    };\r\n\r\n  const wrapper = {\r\n    /**\r\n     * The raw underlying HTMLElement.\r\n     * @type {T | null}\r\n     */\r\n    raw: target,\r\n\r\n    // =========================================\r\n    // EVENTS\r\n    // =========================================\r\n\r\n    /**\r\n     * Adds an event listener.\r\n     * @param event - Event name (e.g., 'click', 'submit')\r\n     * @param handler - Function to handle the event\r\n     * @param options - Event options (capture, passive, etc.)\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    on: chain(on),\r\n\r\n    /**\r\n     * Dispatches a custom event.\r\n     * @param name - Name of the event\r\n     * @param detail - Data to pass with the event\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    dispatch: chain(dispatch),\r\n\r\n    // =========================================\r\n    // MANIPULATION\r\n    // =========================================\r\n\r\n    /**\r\n     * Modifies element properties (text, html, class, etc.).\r\n     * @param props - Object of properties to set\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    modify: chain(modify),\r\n\r\n    /**\r\n     * Applies inline CSS styles.\r\n     * @param styles - Object of CSS properties (camelCase or kebab-case)\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    css: chain(css),\r\n\r\n    /**\r\n     * Applies temporary styles that revert after a delay.\r\n     * @param styles - Styles to apply\r\n     * @param ms - Optional duration in ms to revert styles\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    tempStyle: (styles: Partial<CSSStyleDeclaration>, ms?: number) => {\r\n      if (target) {\r\n        const revert = tempStyle(target)(styles);\r\n        if (ms) setTimeout(revert, ms);\r\n      }\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // STRUCTURE\r\n    // =========================================\r\n\r\n    /**\r\n     * Appends children to this element.\r\n     * @param children - Elements or strings to append\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    append: chain(append),\r\n\r\n    /**\r\n     * Prepends children to this element.\r\n     * @param children - Elements or strings to prepend\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    prepend: chain(prepend),\r\n\r\n    /**\r\n     * Inserts content after this element.\r\n     * @param content - Elements or strings to insert\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    after: chain(after),\r\n\r\n    /**\r\n     * Inserts content before this element.\r\n     * @param content - Elements or strings to insert\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    before: chain(before),\r\n\r\n    /**\r\n     * Removes this element from the DOM.\r\n     * @returns {void}\r\n     */\r\n    remove: () => { if (target) remove(target); },\r\n\r\n    /**\r\n     * Removes all children from this element.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    empty: () => { if (target) empty(target); return wrapper; },\r\n\r\n    /**\r\n     * Wraps this element with another element.\r\n     * @param wrapperEl - The wrapping element\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    wrap: chain(wrap),\r\n\r\n    /**\r\n     * Clones this element.\r\n     * @returns {HTMLElement} The cloned element (not wrapped)\r\n     */\r\n    clone: () => target ? clone(target) : null,\r\n\r\n    // =========================================\r\n    // CLASSES\r\n    // =========================================\r\n\r\n    /**\r\n     * Adds one or more classes.\r\n     * @param classes - Class names to add\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    addClass: chain(cls.add),\r\n\r\n    /**\r\n     * Removes one or more classes.\r\n     * @param classes - Class names to remove\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    removeClass: chain(cls.remove),\r\n\r\n    /**\r\n     * Toggles a class (conditionally or always).\r\n     * @param className - Class to toggle\r\n     * @param force - Optional boolean to force add/remove\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    toggleClass: chain(cls.toggle),\r\n\r\n    /**\r\n     * Replaces one class with another.\r\n     * @param oldClass - Class to remove\r\n     * @param newClass - Class to add\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    replaceClass: chain(cls.replace),\r\n\r\n    /**\r\n     * Checks if the element has a class.\r\n     * @param className - Class to check\r\n     * @returns {boolean} True if class exists\r\n     */\r\n    hasClass: (className: string) => target ? cls.has(target)(className) : false,\r\n\r\n    /**\r\n     * Watches for class changes.\r\n     * @param callback - Function called when classes change\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    //watchClass: (callback: (classes: string[]) => void) => target ? watchClass(target)(callback) : () => { },\r\n\r\n    /**\r\n     * Cycles through a list of classes (removes current, adds next).\r\n     * @param classes - Array of classes to cycle\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    cycleClass: chain(cycleClass),\r\n\r\n    // =========================================\r\n    // DATA & ATTRIBUTES\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets a data attribute value (raw string).\r\n     * @param key - Attribute name (without 'data-')\r\n     * @returns {string | undefined} Raw value\r\n     */\r\n    dataGet: (key: string) => target ? Data.get(target)(key) : undefined,\r\n\r\n    /**\r\n     * Sets a data attribute.\r\n     * @param key - Attribute name\r\n     * @param val - Value to set (automatically stringified)\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    dataSet: chain(Data.set),\r\n\r\n    /**\r\n     * Reads and parses a data attribute.\r\n     * @param key - Attribute name\r\n     * @returns {any} Parsed value (JSON, number, boolean, string)\r\n     */\r\n    dataRead: (key: string) => target ? Data.read(target)(key) : undefined,\r\n\r\n    /**\r\n     * Binds a callback to data attribute changes.\r\n     * @param key - Attribute to watch\r\n     * @param handler - Callback receiving new parsed value\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    dataBind: (key: string, handler: (val: any) => void) => target ? Data.bind(target)(key, handler) : () => { },\r\n\r\n    /**\r\n     * Watches an attribute for changes.\r\n     * @param attr - Attribute name\r\n     * @param handler - Callback receiving new value\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    watchAttr: (attr: string, handler: (val: string | null) => void) => target ? watchAttr(target)(attr, handler) : () => { },\r\n\r\n    /**\r\n     * Watches text content for changes.\r\n     * @param handler - Callback receiving new text\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    watchText: (handler: (text: string | null) => void) => target ? watchText(target)(handler) : () => { },\r\n\r\n    // =========================================\r\n    // INPUTS & FORMS\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets or sets the value.\r\n     * - No args: Gets value (smart typed)\r\n     * - Arg provided: Sets value\r\n     * @param newVal - Value to set\r\n     * @returns {any | this} Value if getting, wrapper if setting\r\n     */\r\n    val: (newVal?: any) => {\r\n      if (newVal === undefined) return Input.get(target as unknown as FormElement);\r\n      Input.set(target as unknown as FormElement)(newVal);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Gets files from an input[type=\"file\"].\r\n     * @returns {File[]} Array of files\r\n     */\r\n    files: () => Input.files(target as unknown as HTMLInputElement),\r\n\r\n    /**\r\n     * Listens for input events (keystrokes).\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onInput: (handler: (val: any, e: Event) => void) => target ? Input.watch(target as unknown as FormElement)(handler) : () => { },\r\n\r\n    /**\r\n     * Listens for input events with debounce.\r\n     * @param ms - Debounce delay in ms\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onInputDebounced: (ms: number, handler: (val: any, e: Event) => void) => target ? Input.watchDebounced(target as unknown as FormElement)(handler as unknown as any, ms) : () => { },\r\n\r\n    /**\r\n     * Listens for change events (blur/enter).\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onChange: (handler: (val: any, e: Event) => void) => target ? Input.change(target as unknown as FormElement)(handler) : () => { },\r\n\r\n    /**\r\n     * Selects all text in the input.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    selectText: () => { Input.select(target as unknown as HTMLInputElement); return wrapper; },\r\n\r\n    /**\r\n     * Validates the input using HTML5 validation API.\r\n     * @returns {boolean} True if valid\r\n     */\r\n    validate: () => target ? Input.validate(target as unknown as FormElement) : false,\r\n\r\n    // =========================================\r\n    // KEYBOARD\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for a specific key press.\r\n     * @param key - Key to listen for (e.g., 'Enter', 'Escape')\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onKey: (key: string, handler: (e: KeyboardEvent) => void) => {\r\n      if (target) Key.is(target)(key, handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for the Tab key.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onTab: (handler: (e: KeyboardEvent) => void) => {\r\n      if (target) Key.onTab(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for Arrow keys.\r\n     * @param handler - Callback receiving direction and event\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onArrow: (handler: (dir: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\r\n      if (target) Key.onArrow(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // FOCUS\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for focus event.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocus: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.on(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for blur event.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onBlur: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onBlur(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for focusin (bubbles).\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocusIn: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onIn(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for focusout (bubbles).\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocusOut: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onOut(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Traps focus within this element (for modals/dialogs).\r\n     * @returns {Unsubscribe} Function to disable trap\r\n     */\r\n    trapFocus: () => Focus.trap(target),\r\n\r\n    // =========================================\r\n    // POINTER & TEXT\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for clicks outside this element.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    clickOutside: (handler: () => void) => {\r\n      return onClickOutside(target, () => handler());\r\n    },\r\n\r\n    /**\r\n     * Checks if element contains text.\r\n     * @param text - String or RegExp to search\r\n     * @returns {boolean} True if found\r\n     */\r\n    hasText: (text: string | RegExp) => target ? !!Text.find(target)(text) : false,\r\n\r\n    /**\r\n     * Finds the first text node matching the pattern.\r\n     * @param text - String or RegExp to search\r\n     * @param selector - Optional selector to scope search\r\n     * @returns {Text | null} The found text node\r\n     */\r\n    findText: (text: string | RegExp, selector?: string) => target ? Text.find(target)(text, selector) : null,\r\n\r\n    /**\r\n     * Finds all text nodes matching the pattern.\r\n     * @param text - String or RegExp to search\r\n     * @param selector - Optional selector to scope search\r\n     * @returns {Text[]} Array of found text nodes\r\n     */\r\n    findAllText: (text: string | RegExp, selector?: string) => target ? Text.findAll(target)(text, selector) : [],\r\n\r\n    /**\r\n     * Replaces text content.\r\n     * @param search - String or RegExp to find\r\n     * @param replace - Replacement string\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    replaceText: (search: string | RegExp, replace: string) => {\r\n      if (target) Text.replace(target)(search, replace);\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // VIEW TRANSITIONS\r\n    // =========================================\r\n\r\n    /**\r\n     * Sets the view-transition-name.\r\n     * @param name - Transition name\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    transitionName: chain(ViewTransitions.name),\r\n\r\n    /**\r\n     * Removes the view-transition-name.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    removeTransitionName: () => { ViewTransitions.unname(target); return wrapper; },\r\n\r\n    /**\r\n     * Runs a view transition focusing on this element.\r\n     * @param name - Temporary transition name\r\n     * @param updateFn - Function to run during transition\r\n     * @returns {Promise<void>} Promise resolving when done\r\n     */\r\n    transitionWith: (name: string, updateFn: () => void) => ViewTransitions.tempName(target)(name)(updateFn),\r\n\r\n    // =========================================\r\n    // TRAVERSAL\r\n    // =========================================\r\n\r\n    /** Parent element */\r\n    parent: Traverse.parent(target),\r\n    /** Next sibling element */\r\n    next: Traverse.next(target),\r\n    /** Previous sibling element */\r\n    prev: Traverse.prev(target),\r\n    /** Child elements */\r\n    children: Traverse.children(target),\r\n    /** Sibling elements */\r\n    siblings: Traverse.siblings(target),\r\n\r\n    // =========================================\r\n    // GEOMETRY & UI\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets the bounding client rect.\r\n     * @returns {DOMRect | undefined}\r\n     */\r\n    rect: () => rect(target),\r\n\r\n    /**\r\n     * Gets the element's offset position.\r\n     * @returns {{ top: number, left: number } | undefined}\r\n     */\r\n    offset: () => offset(target),\r\n\r\n    /**\r\n     * Scrolls the element into view.\r\n     * @param arg - Scroll options or boolean\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    scrollInto: (arg?: boolean | ScrollIntoViewOptions) => { target?.scrollIntoView(arg); return wrapper; },\r\n\r\n    /**\r\n     * Focuses the element.\r\n     * @param options - Focus options\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    focus: (options?: FocusOptions) => { target?.focus(options); return wrapper; },\r\n\r\n    /**\r\n     * Blurs the element.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    blur: () => { target?.blur(); return wrapper; },\r\n\r\n    // =========================================\r\n    // UTILS\r\n    // =========================================\r\n\r\n    /**\r\n     * Waits for CSS transitions to complete.\r\n     * @returns {Promise<void>}\r\n     */\r\n    waitTransition: () => waitTransition(target)\r\n  };\r\n\r\n  return wrapper;\r\n};\r\n\r\n/**\r\n * Turns a DOM tree into a component object by mapping `data-ref` nodes.\r\n * \r\n * **Pattern**: Use `data-ref=\"name\"` in HTML to mark elements. This function\r\n * gathers them into a strongly-typed object for easy access.\r\n * \r\n * **Type Safety**: Pass a generic type to define the expected refs.\r\n * \r\n * **Performance**: Scans the tree once on initialization. Much faster than\r\n * repeated `querySelector` calls.\r\n * \r\n * @template T - Interface defining the expected refs (e.g. `{ title: HTMLElement }`)\r\n * @param rootOrSelector - The root element or a selector string\r\n * @returns Object containing the root and all mapped refs\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <div id=\"card\">\r\n * //   <h1 data-ref=\"title\"></h1>\r\n * //   <button data-ref=\"btn\"></button>\r\n * //   <input data-ref=\"input\" type=\"text\">\r\n * // </div>\r\n * \r\n * // Define types\r\n * interface CardRefs {\r\n *   title: HTMLHeadingElement;\r\n *   btn: HTMLButtonElement;\r\n *   input: HTMLInputElement;\r\n * }\r\n * \r\n * // Initialize\r\n * const card = component<CardRefs>('#card');\r\n * \r\n * // Access refs directly (type-safe)\r\n * card.title.textContent = 'Hello World';\r\n * card.input.value = 'Initial value';\r\n * \r\n * // Use with fluent API\r\n * $(card.btn).on('click', () => {\r\n *   console.log(card.input.value);\r\n * });\r\n * \r\n * // Component Factory Pattern\r\n * function createCard(data: any) {\r\n *   const el = clone(template);\r\n *   const cmp = component<CardRefs>(el);\r\n *   \r\n *   cmp.title.textContent = data.title;\r\n *   \r\n *   return cmp;\r\n * }\r\n * ```\r\n */\r\nexport const component = <T extends Record<string, HTMLElement>>(rootOrSelector: HTMLElement | string | null) => {\r\n  const root = typeof rootOrSelector === 'string' ? find(document)(rootOrSelector) : rootOrSelector;\r\n  if (!root) return {} as T & { root: null };\r\n\r\n  // Get all refs\r\n  const nodes = refs(root) as T;\r\n\r\n  return {\r\n    root,\r\n    ...nodes\r\n  };\r\n};\r\n\r\n/**\r\n * Wraps a LIST of elements for batch operations.\r\n * \r\n * **Batch Processing**: Calling a method applies it to ALL elements in the list.\r\n * \r\n * **Performance**: Optimized for batch DOM updates.\r\n * \r\n * **Parallel Operations**: Methods run sequentially on each element, but\r\n * can be conceptually treated as parallel updates.\r\n * \r\n * @param selectorOrList - Selector string, Array of Elements, or NodeList\r\n * @returns Fluent wrapper for the list of elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // Select and update multiple elements\r\n * $$('.btn')\r\n *   .addClass('active')\r\n *   .css({ opacity: '1' })\r\n *   .on('click', handler);\r\n * \r\n * // Filter and map\r\n * $$('input')\r\n *   .filter((el) => el.value === '')\r\n *   .addClass('error');\r\n * \r\n * // Batch event handling\r\n * const unsubscribeAll = $$('.item').on('click', (e) => {\r\n *   console.log('Item clicked');\r\n * });\r\n * \r\n * // Cleanup\r\n * unsubscribeAll();\r\n * \r\n * // Complex batch update\r\n * $$('.card')\r\n *   .removeClass('selected')\r\n *   .modify({ title: 'Reset' })\r\n *   .css({ transform: 'none' });\r\n * \r\n * // Functional map (returns array of results)\r\n * const values = $$('input').map(el => el.value);\r\n * \r\n * // Chaining with filter\r\n * $$('li')\r\n *   .filter((el, i) => i % 2 === 0) // Evens\r\n *   .css({ background: '#eee' });\r\n * ```\r\n */\r\nexport const $$ = (selectorOrList: string | Element[] | NodeListOf<Element>) => {\r\n  const elements = typeof selectorOrList === 'string'\r\n    ? findAll(document)(selectorOrList)\r\n    : Array.from(selectorOrList) as HTMLElement[];\r\n\r\n  // Helper to map a function over all elements\r\n  const map = (fn: any) => (arg: any, arg2?: any) => {\r\n    elements.forEach(el => fn(el)(arg, arg2));\r\n    return wrapper; // Return self for chaining\r\n  };\r\n\r\n  const wrapper = {\r\n    raw: elements,\r\n\r\n    // Batch Operations\r\n    modify: map(modify),\r\n    css: map(css),\r\n    addClass: map(cls.add),\r\n    removeClass: map(cls.remove),\r\n    toggleClass: map(cls.toggle),\r\n    attr: map((el: any) => (attr: any) => modify(el)({ attr })),\r\n\r\n    // Batch Events\r\n    on: (evt: any, handler: any) => {\r\n      const unsubs = elements.map(el => on(el)(evt, handler));\r\n      return () => unsubs.forEach(u => u()); // Return batch unsubscribe\r\n    },\r\n\r\n    // Batch Traversal / Manipulation\r\n    remove: () => elements.forEach(el => remove(el)),\r\n    empty: () => elements.forEach(el => empty(el)),\r\n\r\n    // Functional map (standard array map)\r\n    map: <T>(fn: (el: HTMLElement, i: number) => T) => elements.map(fn),\r\n    filter: (fn: (el: HTMLElement, i: number) => boolean) => elements.filter(fn)\r\n  };\r\n\r\n  return wrapper;\r\n};\r\n\r\n/**\r\n * Creates a Proxy object where properties are 2-way bound to the element's dataset.\r\n * \r\n * **Reactivity**: Assigning to properties updates the DOM `data-*` attributes.\r\n * Reading properties reads from the DOM.\r\n * \r\n * **Type Safety**: Use a generic interface to define the expected data structure.\r\n * \r\n * **Limitations**:\r\n * - Only stores strings (or JSON serialized values)\r\n * - Performance cost of DOM access on every read/write\r\n * - Property names are converted to kebab-case (e.g. `userId` -> `data-user-id`)\r\n * \r\n * @template T - Interface defining the store shape\r\n * @param element - The element to bind to\r\n * @returns Proxy object mirroring the element's dataset\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define state shape\r\n * interface UserState {\r\n *   userId: number;\r\n *   isAdmin: boolean;\r\n *   theme: 'light' | 'dark';\r\n *   preferences: { notifications: boolean };\r\n * }\r\n * \r\n * // Create store\r\n * const state = store<UserState>(document.body);\r\n * \r\n * // Write to DOM (updates data-attributes)\r\n * state.userId = 123;          // data-user-id=\"123\"\r\n * state.isAdmin = true;        // data-is-admin=\"true\"\r\n * state.theme = 'dark';        // data-theme=\"dark\"\r\n * state.preferences = { notifications: true }; // JSON serialized\r\n * \r\n * // Read from DOM\r\n * console.log(state.userId); // 123 (typed as number)\r\n * \r\n * // Reactivity with MutationObserver\r\n * Data.bind(document.body)('user-id', (newId) => {\r\n *   console.log('User ID changed to:', newId);\r\n * });\r\n * \r\n * // Delete property\r\n * delete state.theme; // Removes data-theme attribute\r\n * ```\r\n */\r\nexport const store = <T extends Record<string, any> = Record<string, any>>(element: HTMLElement | null) => {\r\n  if (!element) return new EventTarget() as T & EventTarget;\r\n\r\n  const target = new EventTarget();\r\n  return new Proxy(target, {\r\n    get: (t, prop: string | symbol) => {\r\n      if (prop in t) {\r\n        const val = (t as any)[prop];\r\n        return typeof val === 'function' ? val.bind(t) : val;\r\n      }\r\n      return Data.read(element)(String(prop));\r\n    },\r\n    set: (t, prop: string | symbol, value: any) => {\r\n      if (prop in t) return true;\r\n      Data.set(element)(String(prop), value);\r\n      t.dispatchEvent(new CustomEvent(String(prop), { detail: value }));\r\n      t.dispatchEvent(new CustomEvent('change', { detail: { prop, value } }));\r\n      return true;\r\n    },\r\n    deleteProperty: (t, prop: string | symbol) => {\r\n      if (prop in t) return false;\r\n      Data.set(element)(String(prop), null);\r\n      t.dispatchEvent(new CustomEvent(String(prop), { detail: null }));\r\n      t.dispatchEvent(new CustomEvent('change', { detail: { prop, value: null } }));\r\n      return true;\r\n    },\r\n    // Allow iteration over current dataset\r\n    ownKeys: () => Reflect.ownKeys(element.dataset),\r\n    getOwnPropertyDescriptor: (_, _key) => ({\r\n      enumerable: true,\r\n      configurable: true,\r\n    })\r\n  }) as T & EventTarget;\r\n};\r\n\r\n/**\r\n * Wraps a form or container to manage input values, validation, and submission.\r\n * \r\n * **Features**:\r\n * - Automatic serialization of all inputs\r\n * - Population of inputs from data objects\r\n * - Simplified submit handling with `preventDefault`\r\n * - Batch clearing of inputs\r\n * \r\n * **Validation**: Combine with `Input.validate` or custom logic in submit handler.\r\n * \r\n * @param target - Form element or selector\r\n * @returns Form wrapper object\r\n * \r\n * @example\r\n * ```typescript\r\n * const f = form('#login-form');\r\n * \r\n * // Get all values\r\n * const data = f.values();\r\n * console.log(data.username, data.password);\r\n * \r\n * // Pre-fill form\r\n * f.set({\r\n *   username: 'admin',\r\n *   rememberMe: true\r\n * });\r\n * \r\n * // Handle submit\r\n * f.submit((data, e) => {\r\n *   // Validations\r\n *   if (!data.username) {\r\n *     alert('Username required');\r\n *     return;\r\n *   }\r\n *   \r\n *   // API call\r\n *   api.login(data).catch(err => {\r\n *     console.error(err);\r\n *     f.clear(); // Clear on error if needed\r\n *   });\r\n * });\r\n * \r\n * // Clear form\r\n * f.clear();\r\n * ```\r\n */\r\nexport const form = (target: HTMLElement | string | null) => {\r\n  const el = typeof target === 'string' ? find(document)(target) : target;\r\n\r\n  return {\r\n    raw: el,\r\n    /** Get all values as object */\r\n    values: () => Form.serialize(el),\r\n    /** Set values from object */\r\n    set: (data: Record<string, any>) => Form.populate(el)(data),\r\n    /** Clear all inputs */\r\n    clear: () => {\r\n      if (!el) return;\r\n      el.querySelectorAll('input, select, textarea').forEach((i: any) => {\r\n        if (i.type === 'checkbox' || i.type === 'radio') i.checked = false;\r\n        else i.value = '';\r\n      });\r\n    },\r\n    /** Short hand for on('submit') with preventDefault and serialization */\r\n    submit: (handler: (data: any, e: Event) => void) => {\r\n      return on(el)('submit', (e) => {\r\n        e.preventDefault();\r\n        handler(Form.serialize(el), e);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 29. INPUTS & CONTROLS\r\n// =============================================================================\r\n\r\nexport type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\r\n\r\nexport const Input = {\r\n  /**\r\n   * Smart Getter. Automatically handles:\r\n   * - Checkbox/Radio -> boolean\r\n   * - Number/Range -> number\r\n   * - File -> FileList\r\n   * - Select/Text -> string\r\n   * \r\n   * @example const val = Input.get(input);\r\n   */\r\n  get: (el: FormElement | null): any => {\r\n    if (!el) return undefined;\r\n    if (el instanceof HTMLInputElement) {\r\n      if (el.type === 'checkbox' || el.type === 'radio') return el.checked;\r\n      if (el.type === 'number' || el.type === 'range') return el.valueAsNumber;\r\n      if (el.type === 'file') return el.files;\r\n      if (el.type === 'date') return el.valueAsDate;\r\n    }\r\n    return el.value;\r\n  },\r\n\r\n  /**\r\n   * Smart Setter. Automatically handles checkboxes, numbers, etc.\r\n   * \r\n   * @example Input.set(checkbox)(true);\r\n   */\r\n  set: (el: FormElement | null) => (val: any) => {\r\n    if (!el) return el;\r\n    if (el instanceof HTMLInputElement) {\r\n      if (el.type === 'checkbox' || el.type === 'radio') {\r\n        el.checked = !!val;\r\n      } else if (el.type === 'file') {\r\n        // Read-only usually, but clearing allowed\r\n        if (!val) el.value = '';\r\n      } else if (el.type === 'date' && val instanceof Date) {\r\n        el.valueAsDate = val;\r\n      } else {\r\n        el.value = String(val);\r\n      }\r\n    } else {\r\n      el.value = String(val);\r\n    }\r\n    // Trigger event so listeners know it changed programmatically\r\n    el.dispatchEvent(new Event('input', { bubbles: true }));\r\n    el.dispatchEvent(new Event('change', { bubbles: true }));\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of Files from a file input (easier than FileList).\r\n   */\r\n  files: (el: HTMLInputElement | null): File[] => {\r\n    return el && el.files ? Array.from(el.files) : [];\r\n  },\r\n\r\n  /**\r\n   * Watches the 'input' event (keystrokes).\r\n   * callback receives the *parsed* value, not the event.\r\n   * \r\n   * @example Input.watch(search)(query => filterList(query));\r\n   */\r\n  watch: (el: FormElement | null) => {\r\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const handler = (e: Event) => callback(Input.get(el), e);\r\n      el.addEventListener('input', handler);\r\n      return () => el.removeEventListener('input', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Watches input while respecting IME composition events.\r\n   * Fires on compositionend or non-composing input.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * Input.watchComposed(input)((value) => update(value));\r\n   * ```\r\n   */\r\n  watchComposed: (el: FormElement | null) => {\r\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      let composing = false;\r\n\r\n      const handleCompositionStart = () => {\r\n        composing = true;\r\n      };\r\n\r\n      const handleCompositionEnd = (e: Event) => {\r\n        composing = false;\r\n        callback(Input.get(el), e);\r\n      };\r\n\r\n      const handleInput = (e: Event) => {\r\n        if (!composing) callback(Input.get(el), e);\r\n      };\r\n\r\n      el.addEventListener('compositionstart', handleCompositionStart);\r\n      el.addEventListener('compositionend', handleCompositionEnd);\r\n      el.addEventListener('input', handleInput);\r\n\r\n      return () => {\r\n        el.removeEventListener('compositionstart', handleCompositionStart);\r\n        el.removeEventListener('compositionend', handleCompositionEnd);\r\n        el.removeEventListener('input', handleInput);\r\n      };\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Watches the 'input' event with a DEBOUNCE.\r\n\r\n   * Perfect for search bars.\r\n   * \r\n   * @example Input.watchDebounced(search)(query => api.search(query), 500);\r\n   */\r\n  watchDebounced: (el: FormElement | null) => {\r\n    return (callback: (val: any) => void, ms: number): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const d = debounce((_e) => callback(Input.get(el)), ms);\r\n      el.addEventListener('input', d);\r\n      return () => el.removeEventListener('input', d);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Watches the 'change' event (blur/enter/selection).\r\n   * \r\n   * @example Input.change(dropdown)(val => console.log('Selected', val));\r\n   */\r\n  change: (el: FormElement | null) => {\r\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const handler = (e: Event) => callback(Input.get(el), e);\r\n      el.addEventListener('change', handler);\r\n      return () => el.removeEventListener('change', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Selects all text in the input/textarea.\r\n   */\r\n  select: (el: HTMLInputElement | HTMLTextAreaElement | null) => {\r\n    el?.select();\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Checks validity and returns boolean. \r\n   * Optionally sets custom validity message.\r\n   */\r\n  validate: (el: FormElement | null) => (msg?: string): boolean => {\r\n    if (!el) return false;\r\n    if (msg !== undefined) el.setCustomValidity(msg);\r\n    return el.checkValidity();\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 29.5 INPUT EXTRAS\r\n// =============================================================================\r\n\r\nexport interface AutoResizeOptions {\r\n  /** Maximum height before enabling scroll. */\r\n  maxHeight?: number;\r\n}\r\n\r\n/**\r\n * Automatically resizes a textarea to fit its content.\r\n *\r\n * @param textarea - Target textarea\r\n * @param options - Resize options\r\n * @returns Cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const stop = autoResize(textarea, { maxHeight: 300 });\r\n * // stop() to remove listeners\r\n * ```\r\n */\r\nexport const autoResize = (\r\n  textarea: HTMLTextAreaElement | null,\r\n  options: AutoResizeOptions = {}\r\n): Unsubscribe => {\r\n  if (!textarea) return () => { };\r\n\r\n  const { maxHeight } = options;\r\n  const resize = () => {\r\n    textarea.style.height = 'auto';\r\n    const height = textarea.scrollHeight;\r\n    const nextHeight = maxHeight ? Math.min(height, maxHeight) : height;\r\n    textarea.style.height = `${nextHeight}px`;\r\n    textarea.style.overflowY = maxHeight && height > maxHeight ? 'auto' : 'hidden';\r\n  };\r\n\r\n  resize();\r\n  textarea.addEventListener('input', resize);\r\n\r\n  return () => textarea.removeEventListener('input', resize);\r\n};\r\n\r\nexport interface UploadOptions {\r\n  /** Accepted file types (e.g., ['image/*', '.pdf']). */\r\n  accept?: string[];\r\n  /** Maximum file size in bytes. */\r\n  maxSize?: number;\r\n  /** Allow multiple file selection. */\r\n  multiple?: boolean;\r\n  /** Called when files are selected and validated. */\r\n  onFiles?: (files: File[]) => void;\r\n  /** Progress callback (used by optional upload handler). */\r\n  onProgress?: (file: File, percent: number) => void;\r\n  /** Called when a file upload completes. */\r\n  onComplete?: (file: File, response: any) => void;\r\n  /** Called when a file fails validation or upload. */\r\n  onError?: (file: File, error: Error) => void;\r\n  /** Optional upload handler for automatic uploads. */\r\n  upload?: (file: File, onProgress: (percent: number) => void) => Promise<any>;\r\n}\r\n\r\nexport interface UploadController {\r\n  /** Opens the native file picker. */\r\n  open: () => void;\r\n  /** Removes listeners and input element. */\r\n  destroy: () => void;\r\n  /** Internal file input element. */\r\n  input: HTMLInputElement | null;\r\n}\r\n\r\n/**\r\n * Creates a drag-and-drop + click file upload controller.\r\n *\r\n * @param dropzone - Target element or selector\r\n * @param options - Upload configuration\r\n * @returns Upload controller with open/destroy\r\n *\r\n * @example\r\n * ```typescript\r\n * const upload = createUpload(zone, {\r\n *   accept: ['image/*'],\r\n *   maxSize: 5 * 1024 * 1024,\r\n *   onFiles: (files) => console.log(files)\r\n * });\r\n * ```\r\n */\r\nexport const createUpload = (\r\n  dropzone: HTMLElement | string | null,\r\n  options: UploadOptions = {}\r\n): UploadController => {\r\n  const target = typeof dropzone === 'string' ? find(document)(dropzone) : dropzone;\r\n  if (!target) {\r\n    return {\r\n      open: () => { },\r\n      destroy: () => { },\r\n      input: null\r\n    };\r\n  }\r\n\r\n  const input = document.createElement('input');\r\n  input.type = 'file';\r\n  input.multiple = !!options.multiple;\r\n  if (options.accept?.length) {\r\n    input.accept = options.accept.join(',');\r\n  }\r\n  input.style.display = 'none';\r\n  target.appendChild(input);\r\n\r\n  const acceptsFile = (file: File) => {\r\n    if (!options.accept || options.accept.length === 0) return true;\r\n    return options.accept.some((rule) => {\r\n      if (rule.endsWith('/*')) {\r\n        const prefix = rule.replace('/*', '');\r\n        return file.type.startsWith(prefix);\r\n      }\r\n      if (rule.startsWith('.')) {\r\n        return file.name.toLowerCase().endsWith(rule.toLowerCase());\r\n      }\r\n      return file.type === rule;\r\n    });\r\n  };\r\n\r\n  const handleFiles = async (files: File[]) => {\r\n    const validFiles: File[] = [];\r\n\r\n    files.forEach((file) => {\r\n      if (!acceptsFile(file)) {\r\n        options.onError?.(file, new Error('File type not accepted.'));\r\n        return;\r\n      }\r\n      if (options.maxSize && file.size > options.maxSize) {\r\n        options.onError?.(file, new Error('File exceeds maximum size.'));\r\n        return;\r\n      }\r\n      validFiles.push(file);\r\n    });\r\n\r\n    if (validFiles.length === 0) return;\r\n    options.onFiles?.(validFiles);\r\n\r\n    if (options.upload) {\r\n      for (const file of validFiles) {\r\n        try {\r\n          const response = await options.upload(file, (percent) => {\r\n            options.onProgress?.(file, percent);\r\n          });\r\n          options.onComplete?.(file, response);\r\n        } catch (error) {\r\n          options.onError?.(\r\n            file,\r\n            error instanceof Error ? error : new Error(String(error))\r\n          );\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleInputChange = () => {\r\n    const files = input.files ? Array.from(input.files) : [];\r\n    handleFiles(files);\r\n    input.value = '';\r\n  };\r\n\r\n  const handleDragOver = (e: DragEvent) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  const handleDrop = (e: DragEvent) => {\r\n    e.preventDefault();\r\n    const files = Array.from(e.dataTransfer?.files ?? []);\r\n    handleFiles(files);\r\n  };\r\n\r\n  const handleClick = () => input.click();\r\n\r\n  input.addEventListener('change', handleInputChange);\r\n  target.addEventListener('click', handleClick);\r\n  target.addEventListener('dragover', handleDragOver);\r\n  target.addEventListener('drop', handleDrop);\r\n\r\n  return {\r\n    open: () => input.click(),\r\n    destroy: () => {\r\n      input.removeEventListener('change', handleInputChange);\r\n      target.removeEventListener('click', handleClick);\r\n      target.removeEventListener('dragover', handleDragOver);\r\n      target.removeEventListener('drop', handleDrop);\r\n      input.remove();\r\n    },\r\n    input\r\n  };\r\n};\r\n\r\nexport interface DraggableBounds {\r\n  left: number;\r\n  top: number;\r\n  right: number;\r\n  bottom: number;\r\n}\r\n\r\nexport interface DraggableOptions {\r\n  /** Bounds for dragging (element, selector, or rect). */\r\n  bounds?: HTMLElement | DOMRect | DraggableBounds | string;\r\n  /** Axis constraint (default: both). */\r\n  axis?: 'x' | 'y' | 'both';\r\n  /** Drag callback with current translation. */\r\n  onDrag?: (pos: { x: number; y: number }) => void;\r\n  /** Called when dragging ends. */\r\n  onDrop?: (pos: { x: number; y: number }) => void;\r\n}\r\n\r\n/**\r\n * Makes an element draggable with optional bounds.\r\n *\r\n * @param element - Element to drag\r\n * @param options - Drag behavior options\r\n * @returns Cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const stop = draggable(card, { axis: 'y', bounds: container });\r\n * ```\r\n */\r\nexport const draggable = (\r\n  element: HTMLElement | null,\r\n  options: DraggableOptions = {}\r\n): Unsubscribe => {\r\n  if (!element) return () => { };\r\n\r\n  const axis = options.axis ?? 'both';\r\n  let isDragging = false;\r\n  let startX = 0;\r\n  let startY = 0;\r\n  let currentX = 0;\r\n  let currentY = 0;\r\n  let originX = 0;\r\n  let originY = 0;\r\n  let boundsRect: DOMRect | DraggableBounds | null = null;\r\n  let startRect: DOMRect | null = null;\r\n\r\n  const resolveBounds = (): DOMRect | DraggableBounds | null => {\r\n    if (!options.bounds) return null;\r\n    if (typeof options.bounds === 'string') {\r\n      const el = find(document)(options.bounds);\r\n      return el ? el.getBoundingClientRect() : null;\r\n    }\r\n    if (options.bounds instanceof HTMLElement) {\r\n      return options.bounds.getBoundingClientRect();\r\n    }\r\n    if (options.bounds instanceof DOMRect) {\r\n      return options.bounds;\r\n    }\r\n    return options.bounds;\r\n  };\r\n\r\n  const applyTransform = (x: number, y: number) => {\r\n    element.style.transform = `translate(${x}px, ${y}px)`;\r\n  };\r\n\r\n  const handlePointerMove = (e: PointerEvent) => {\r\n    if (!isDragging) return;\r\n\r\n    const dx = e.clientX - startX;\r\n    const dy = e.clientY - startY;\r\n    let nextX = axis === 'y' ? originX : originX + dx;\r\n    let nextY = axis === 'x' ? originY : originY + dy;\r\n\r\n    if (boundsRect && startRect) {\r\n      const minX = boundsRect.left - startRect.left;\r\n      const maxX = boundsRect.right - startRect.right;\r\n      const minY = boundsRect.top - startRect.top;\r\n      const maxY = boundsRect.bottom - startRect.bottom;\r\n\r\n      if (axis !== 'y') nextX = Math.min(Math.max(nextX, minX), maxX);\r\n      if (axis !== 'x') nextY = Math.min(Math.max(nextY, minY), maxY);\r\n    }\r\n\r\n    currentX = nextX;\r\n    currentY = nextY;\r\n    applyTransform(currentX, currentY);\r\n    options.onDrag?.({ x: currentX, y: currentY });\r\n  };\r\n\r\n  const handlePointerUp = () => {\r\n    if (!isDragging) return;\r\n    isDragging = false;\r\n    document.removeEventListener('pointermove', handlePointerMove);\r\n    document.removeEventListener('pointerup', handlePointerUp);\r\n    options.onDrop?.({ x: currentX, y: currentY });\r\n  };\r\n\r\n  const handlePointerDown = (e: PointerEvent) => {\r\n    if (e.button !== 0) return;\r\n    isDragging = true;\r\n    startX = e.clientX;\r\n    startY = e.clientY;\r\n    originX = currentX;\r\n    originY = currentY;\r\n    boundsRect = resolveBounds();\r\n    startRect = element.getBoundingClientRect();\r\n\r\n    element.setPointerCapture?.(e.pointerId);\r\n    document.addEventListener('pointermove', handlePointerMove);\r\n    document.addEventListener('pointerup', handlePointerUp);\r\n  };\r\n\r\n  element.addEventListener('pointerdown', handlePointerDown);\r\n\r\n  return () => {\r\n    element.removeEventListener('pointerdown', handlePointerDown);\r\n    document.removeEventListener('pointermove', handlePointerMove);\r\n    document.removeEventListener('pointerup', handlePointerUp);\r\n  };\r\n};\r\n\r\nexport interface SortableOptions {\r\n  /** Selector for sortable items within the container. */\r\n  items: string;\r\n  /** Optional drag handle selector. */\r\n  handle?: string;\r\n  /** Called when items are reordered. */\r\n  onReorder?: (fromIndex: number, toIndex: number) => void;\r\n}\r\n\r\nexport interface SortableController {\r\n  /** Refreshes item bindings (useful when DOM changes). */\r\n  refresh: () => void;\r\n  /** Removes all listeners. */\r\n  destroy: () => void;\r\n}\r\n\r\n/**\r\n * Enables basic sortable reordering for a list.\r\n *\r\n * @param container - Container element\r\n * @param options - Sortable options\r\n * @returns Sortable controller\r\n *\r\n * @example\r\n * ```typescript\r\n * const sortable = createSortable(list, {\r\n *   items: 'li',\r\n *   handle: '.drag-handle',\r\n *   onReorder: (from, to) => console.log(from, to)\r\n * });\r\n * ```\r\n */\r\nexport const createSortable = (\r\n  container: HTMLElement | null,\r\n  options: SortableOptions\r\n): SortableController => {\r\n  if (!container) {\r\n    return {\r\n      refresh: () => { },\r\n      destroy: () => { }\r\n    };\r\n  }\r\n\r\n  const { items, handle, onReorder } = options;\r\n  let dragging: HTMLElement | null = null;\r\n  let fromIndex = -1;\r\n\r\n  const getItems = () => Array.from(container.querySelectorAll<HTMLElement>(items));\r\n\r\n  const onDragStart = (e: DragEvent) => {\r\n    const target = e.currentTarget as HTMLElement;\r\n    if (handle && !(e.target as HTMLElement | null)?.closest(handle)) {\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n    dragging = target;\r\n    fromIndex = getItems().indexOf(target);\r\n    e.dataTransfer?.setData('text/plain', '');\r\n  };\r\n\r\n  const onDragEnd = () => {\r\n    if (!dragging) return;\r\n    const toIndex = getItems().indexOf(dragging);\r\n    if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {\r\n      onReorder?.(fromIndex, toIndex);\r\n    }\r\n    dragging = null;\r\n    fromIndex = -1;\r\n  };\r\n\r\n  const onDragOver = (e: DragEvent) => {\r\n    e.preventDefault();\r\n    if (!dragging) return;\r\n    const target = (e.target as HTMLElement | null)?.closest(items) as HTMLElement | null;\r\n    if (!target || target === dragging) return;\r\n\r\n    const currentItems = getItems();\r\n    const draggingIndex = currentItems.indexOf(dragging);\r\n    const targetIndex = currentItems.indexOf(target);\r\n\r\n    if (draggingIndex < targetIndex) {\r\n      container.insertBefore(dragging, target.nextSibling);\r\n    } else {\r\n      container.insertBefore(dragging, target);\r\n    }\r\n  };\r\n\r\n  const onDrop = (e: DragEvent) => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  const bindItems = () => {\r\n    getItems().forEach((item) => {\r\n      item.draggable = true;\r\n      item.addEventListener('dragstart', onDragStart);\r\n      item.addEventListener('dragend', onDragEnd);\r\n    });\r\n  };\r\n\r\n  const unbindItems = () => {\r\n    getItems().forEach((item) => {\r\n      item.removeEventListener('dragstart', onDragStart);\r\n      item.removeEventListener('dragend', onDragEnd);\r\n    });\r\n  };\r\n\r\n  bindItems();\r\n  container.addEventListener('dragover', onDragOver);\r\n  container.addEventListener('drop', onDrop);\r\n\r\n  return {\r\n    refresh: () => {\r\n      unbindItems();\r\n      bindItems();\r\n    },\r\n    destroy: () => {\r\n      unbindItems();\r\n      container.removeEventListener('dragover', onDragOver);\r\n      container.removeEventListener('drop', onDrop);\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 30. EVENT HELPERS\r\n// =============================================================================\r\n\r\nexport interface ClickOutsideOptions {\r\n  /** Elements/selectors to ignore. */\r\n  ignore?: Array<ElementInput>;\r\n  /** Use capture phase (default: true). */\r\n  capture?: boolean;\r\n}\r\n\r\n/**\r\n * Runs a handler when a click occurs outside of a target element.\r\n *\r\n * @param target - Element or selector to watch\r\n * @param handler - Callback to run on outside click\r\n * @param options - Ignore list and capture flag\r\n * @returns Cleanup function\r\n *\r\n * @example\r\n * ```typescript\r\n * const stop = onClickOutside(menu, close, { ignore: [trigger] });\r\n * ```\r\n */\r\nexport const onClickOutside = (\r\n  target: ElementInput,\r\n  handler: (event: Event) => void,\r\n  options: ClickOutsideOptions = {}\r\n): Unsubscribe => {\r\n  const resolve = (input: ElementInput): Element | null => {\r\n    if (typeof input === 'function') return input();\r\n    if (typeof input === 'string') return find(document)(input);\r\n    return input;\r\n  };\r\n\r\n  const root = resolve(target);\r\n  if (!root) return () => { };\r\n\r\n  const ignore = (options.ignore ?? [])\r\n    .map(resolve)\r\n    .filter((el): el is Element => !!el);\r\n\r\n  const capture = options.capture ?? true;\r\n\r\n  const listener = (event: Event) => {\r\n    const path = (event as any).composedPath?.() as EventTarget[] | undefined;\r\n    const eventTarget = event.target as Node | null;\r\n    const isInside = path ? path.includes(root) : !!eventTarget && root.contains(eventTarget);\r\n    if (isInside) return;\r\n\r\n    const isIgnored = ignore.some((el) =>\r\n      path ? path.includes(el) : !!eventTarget && el.contains(eventTarget)\r\n    );\r\n\r\n    if (!isIgnored) handler(event);\r\n  };\r\n\r\n  document.addEventListener('pointerdown', listener, { capture });\r\n  return () => document.removeEventListener('pointerdown', listener, { capture });\r\n};\r\n\r\nexport const Evt = {\r\n  /**\r\n   * Stops propagation (bubbling) of the event.\r\n   * Can be used as a wrapper for handlers.\r\n   * \r\n   * @example on(btn)('click', Evt.stop(handler));\r\n   */\r\n  stop: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.stopPropagation();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Prevents default behavior.\r\n   * \r\n   * @example on(form)('submit', Evt.prevent(submitHandler));\r\n   */\r\n  prevent: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.preventDefault();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Stops propagation AND prevents default.\r\n   */\r\n  kill: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Filters an event handler to only run for specific keys.\r\n   * \r\n   * @example on(input)('keydown', Evt.key('Enter', search));\r\n   */\r\n  key: (keyOrKeys: string | string[], fn: (e: KeyboardEvent) => void) => (e: KeyboardEvent) => {\r\n    const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\r\n    if (keys.includes(e.key)) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Checks if the event triggered exactly on the element (not a child).\r\n   */\r\n  isSelf: (e: Event) => e.target === e.currentTarget,\r\n\r\n  /**\r\n   * Gets the coordinate of the event relative to the viewport.\r\n   * Handles Mouse and Touch events uniformly.\r\n   */\r\n  pointer: (e: MouseEvent | TouchEvent | Event) => {\r\n    if ('touches' in e) {\r\n      const t = (e as TouchEvent).touches[0] || (e as TouchEvent).changedTouches[0];\r\n      return { x: t.clientX, y: t.clientY };\r\n    }\r\n    return { x: (e as MouseEvent).clientX, y: (e as MouseEvent).clientY };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 31. MEDIA QUERIES\r\n// =============================================================================\r\n\r\nexport type MediaQueryMap = Record<string, string>;\r\n\r\nexport type MediaQueryMatches<T extends MediaQueryMap> = {\r\n  [K in keyof T]: boolean;\r\n};\r\n\r\nexport interface MediaQueryController<T extends MediaQueryMap> {\r\n  /** Current match state for each query. */\r\n  matches: MediaQueryMatches<T>;\r\n  /** Subscribe to a query key. */\r\n  on: (key: keyof T, handler: (matches: boolean) => void) => Unsubscribe;\r\n  /** Remove all listeners. */\r\n  destroy: () => void;\r\n}\r\n\r\n/**\r\n * Creates a reactive media query controller.\r\n *\r\n * @param queries - Map of query names to media queries\r\n * @returns Controller with matches and subscriptions\r\n *\r\n * @example\r\n * ```typescript\r\n * const screen = createMediaQuery({ mobile: '(max-width: 640px)' });\r\n * screen.on('mobile', (matches) => console.log(matches));\r\n * ```\r\n */\r\nexport const createMediaQuery = <T extends MediaQueryMap>(\r\n  queries: T\r\n): MediaQueryController<T> => {\r\n  if (typeof window === 'undefined' || typeof window.matchMedia === 'undefined') {\r\n    return {\r\n      matches: {} as MediaQueryMatches<T>,\r\n      on: () => () => { },\r\n      destroy: () => { }\r\n    };\r\n  }\r\n\r\n  const matches = {} as MediaQueryMatches<T>;\r\n  const listeners: Array<() => void> = [];\r\n  const mqlMap = new Map<keyof T, MediaQueryList>();\r\n\r\n  (Object.keys(queries) as Array<keyof T>).forEach((key) => {\r\n    const query = queries[key];\r\n    const mql = window.matchMedia(query);\r\n    matches[key] = mql.matches;\r\n    mqlMap.set(key, mql);\r\n  });\r\n\r\n  const on = (key: keyof T, handler: (match: boolean) => void) => {\r\n    const mql = mqlMap.get(key);\r\n    if (!mql) return () => { };\r\n\r\n    const listener = (e: MediaQueryListEvent) => {\r\n      matches[key] = e.matches;\r\n      handler(e.matches);\r\n    };\r\n\r\n    matches[key] = mql.matches;\r\n    handler(mql.matches);\r\n\r\n    if ('addEventListener' in mql) {\r\n      mql.addEventListener('change', listener);\r\n      listeners.push(() => mql.removeEventListener('change', listener));\r\n      return () => mql.removeEventListener('change', listener);\r\n    }\r\n\r\n    const legacyListener = (e: MediaQueryListEvent) => listener(e);\r\n    (mql as any).addListener(legacyListener);\r\n    const cleanup = () => (mql as any).removeListener(legacyListener);\r\n    listeners.push(cleanup);\r\n    return cleanup;\r\n  };\r\n\r\n  return {\r\n    matches,\r\n    on,\r\n    destroy: () => {\r\n      listeners.forEach((cleanup) => cleanup());\r\n      listeners.length = 0;\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 32. KEYBOARD & FOCUS INTERACTIONS\r\n// =============================================================================\r\n\r\n\r\nexport const Key = {\r\n  /**\r\n   * Returns true if the keyboard event matches a key or predicate.\r\n   * Supports optional currying.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (Key.matches(e, 'Enter')) onSubmit();\r\n   * if (Key.matches(['ArrowUp', 'ArrowDown'])(e)) moveFocus();\r\n   * ```\r\n   */\r\n  matches: ((eventOrKey: KeyboardEvent | string | string[] | ((key: string) => boolean),\r\n    keyOrPredicate?: string | string[] | ((key: string) => boolean)) => {\r\n    const matchesKey = (event: KeyboardEvent, matcher: string | string[] | ((key: string) => boolean)) => {\r\n      if (typeof matcher === 'function') return matcher(event.key);\r\n      if (Array.isArray(matcher)) return matcher.includes(event.key);\r\n      return event.key === matcher;\r\n    };\r\n\r\n    if (typeof eventOrKey === 'object' && 'key' in eventOrKey) {\r\n      if (!keyOrPredicate) return false;\r\n      return matchesKey(eventOrKey, keyOrPredicate);\r\n    }\r\n\r\n    const matcher = eventOrKey;\r\n    return (event: KeyboardEvent) => matchesKey(event, matcher);\r\n  }) as {\r\n    (event: KeyboardEvent, key: string | string[] | ((key: string) => boolean)): boolean;\r\n    (key: string | string[] | ((key: string) => boolean)): (event: KeyboardEvent) => boolean;\r\n  },\r\n\r\n  /**\r\n   * Listens for a specific key press.\r\n   * @example Key.is(input)('Enter', onSubmit);\r\n   */\r\n  is: (target: EventTarget | null) => (key: string, handler: (e: KeyboardEvent) => void) => {\r\n    return on(target)('keydown', (e) => {\r\n      if (e.key === key) handler(e as KeyboardEvent);\r\n    });\r\n  },\r\n\r\n\r\n  /**\r\n   * Listens for the 'Tab' key.\r\n   * Useful for trapping focus or form navigation logic.\r\n   */\r\n  onTab: (target: EventTarget | null) => (handler: (e: KeyboardEvent) => void) => {\r\n    return on(target)('keydown', (e) => {\r\n      if (e.key === 'Tab') handler(e as KeyboardEvent);\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Listens for any Arrow key.\r\n   * Handler receives the direction ('Up' | 'Down' | 'Left' | 'Right').\r\n   * \r\n   * @example \r\n   * Key.onArrow(menu)((dir, e) => {\r\n   *   if (dir === 'Down') focusNext();\r\n   * });\r\n   */\r\n  onArrow: (target: EventTarget | null) => {\r\n    return (handler: (direction: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\r\n      return on(target)('keydown', (e) => {\r\n        if (e.key.startsWith('Arrow')) {\r\n          const dir = e.key.replace('Arrow', '') as 'Up' | 'Down' | 'Left' | 'Right';\r\n          handler(dir, e as KeyboardEvent);\r\n        }\r\n      });\r\n    };\r\n  }\r\n};\r\n\r\nexport const Focus = {\r\n  /**\r\n   * Standard Focus event.\r\n   */\r\n  on: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focus', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Standard Blur event.\r\n   */\r\n  onBlur: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('blur', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Focus In (Bubbles).\r\n   * Useful for detecting if ANY child within a container gained focus.\r\n   */\r\n  onIn: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focusin', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Focus Out (Bubbles).\r\n   * Useful for detecting if focus left a container entirely.\r\n   */\r\n  onOut: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focusout', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Traps focus within an element (Accessibility).\r\n   * Prevents Tab from leaving the target container.\r\n   */\r\n  trap: (target: HTMLElement | null) => {\r\n    if (!target) return () => { };\r\n\r\n    const handler = (e: KeyboardEvent) => {\r\n      if (e.key !== 'Tab') return;\r\n\r\n      const focusables = target.querySelectorAll<HTMLElement>(\r\n        'a[href], button, textarea, input, select, [tabindex]:not([tabindex=\"-1\"])'\r\n      );\r\n      const first = focusables[0];\r\n      const last = focusables[focusables.length - 1];\r\n\r\n      if (e.shiftKey) {\r\n        if (document.activeElement === first) {\r\n          e.preventDefault();\r\n          last.focus();\r\n        }\r\n      } else {\r\n        if (document.activeElement === last) {\r\n          e.preventDefault();\r\n          first.focus();\r\n        }\r\n      }\r\n    };\r\n\r\n    target.addEventListener('keydown', handler);\r\n    return () => target.removeEventListener('keydown', handler);\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 33. ACCESSIBILITY\r\n// =============================================================================\r\n\r\nexport interface A11yRovingOptions {\r\n  /** Arrow key axis to respond to. */\r\n  axis?: 'horizontal' | 'vertical' | 'both';\r\n  /** Loop focus from end to start. */\r\n  loop?: boolean;\r\n  /** Initial active index or element. */\r\n  initial?: number | HTMLElement;\r\n}\r\n\r\nexport const A11y = (() => {\r\n  let liveRegion: HTMLElement | null = null;\r\n\r\n  const ensureLiveRegion = () => {\r\n    if (typeof document === 'undefined' || !document.body) return null;\r\n    if (!liveRegion || !document.body.contains(liveRegion)) {\r\n      liveRegion = document.createElement('div');\r\n      liveRegion.setAttribute('aria-live', 'polite');\r\n      liveRegion.setAttribute('aria-atomic', 'true');\r\n      liveRegion.setAttribute('role', 'status');\r\n      liveRegion.style.position = 'absolute';\r\n      liveRegion.style.width = '1px';\r\n      liveRegion.style.height = '1px';\r\n      liveRegion.style.margin = '-1px';\r\n      liveRegion.style.padding = '0';\r\n      liveRegion.style.border = '0';\r\n      liveRegion.style.overflow = 'hidden';\r\n      liveRegion.style.clip = 'rect(0 0 0 0)';\r\n      liveRegion.style.clipPath = 'inset(50%)';\r\n      liveRegion.style.whiteSpace = 'nowrap';\r\n      document.body.appendChild(liveRegion);\r\n    }\r\n    return liveRegion;\r\n  };\r\n\r\n  const resolve = (input: ElementInput): HTMLElement | null => {\r\n    if (typeof input === 'function') return input() as HTMLElement | null;\r\n    if (typeof input === 'string') return find(document)(input) as HTMLElement | null;\r\n    return input as HTMLElement | null;\r\n  };\r\n\r\n  return {\r\n    /**\r\n     * Announces a message to screen readers.\r\n     *\r\n     * @param message - Message to announce\r\n     * @param politeness - 'polite' or 'assertive'\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * A11y.announce('Saved', 'polite');\r\n     * ```\r\n     */\r\n    announce: (message: string, politeness: 'polite' | 'assertive' = 'polite') => {\r\n      const region = ensureLiveRegion();\r\n      if (!region) return;\r\n      region.setAttribute('aria-live', politeness);\r\n      region.setAttribute('role', politeness === 'assertive' ? 'alert' : 'status');\r\n      region.textContent = '';\r\n      const announceNow = () => {\r\n        region.textContent = message;\r\n      };\r\n      if (typeof requestAnimationFrame !== 'undefined') {\r\n        requestAnimationFrame(announceNow);\r\n      } else {\r\n        setTimeout(announceNow, 0);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets aria-expanded and aria-controls on a trigger/panel pair.\r\n     *\r\n     * @param triggerInput - Trigger element or selector\r\n     * @param panelInput - Panel element or selector\r\n     * @param expanded - Optional expanded state (defaults to toggle)\r\n     * @returns Final expanded state\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * A11y.setExpanded(button, panel, true);\r\n     * ```\r\n     */\r\n    setExpanded: (\r\n      triggerInput: ElementInput,\r\n      panelInput: ElementInput,\r\n      expanded?: boolean\r\n    ) => {\r\n      const trigger = resolve(triggerInput);\r\n      const panel = resolve(panelInput);\r\n      if (!trigger || !panel) return null;\r\n\r\n      const current = trigger.getAttribute('aria-expanded') === 'true';\r\n      const next = expanded ?? !current;\r\n      const panelId = panel.id || `panel-${Math.random().toString(36).slice(2, 9)}`;\r\n      panel.id = panelId;\r\n      trigger.setAttribute('aria-controls', panelId);\r\n      trigger.setAttribute('aria-expanded', String(next));\r\n      return next;\r\n    },\r\n\r\n    /**\r\n     * Sets aria-selected for an option and clears siblings within a listbox.\r\n     *\r\n     * @param optionInput - Option element or selector\r\n     * @param listboxInput - Optional listbox container\r\n     * @param selected - Selected state (default: true)\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * A11y.setSelected(option, listbox, true);\r\n     * ```\r\n     */\r\n    setSelected: (\r\n      optionInput: ElementInput,\r\n      listboxInput?: ElementInput,\r\n      selected: boolean = true\r\n    ) => {\r\n      const option = resolve(optionInput);\r\n      if (!option) return null;\r\n\r\n      const listbox = listboxInput ? resolve(listboxInput) : null;\r\n      if (listbox) {\r\n        listbox.querySelectorAll<HTMLElement>('[aria-selected=\"true\"]').forEach((el) => {\r\n          if (el !== option) {\r\n            el.setAttribute('aria-selected', 'false');\r\n          }\r\n        });\r\n      }\r\n\r\n      option.setAttribute('aria-selected', String(selected));\r\n      return selected;\r\n    },\r\n\r\n    /**\r\n     * Creates roving tabindex behavior for composite widgets.\r\n     *\r\n     * @param root - Widget root element\r\n     * @param selector - Selector for focusable items\r\n     * @param options - Roving options\r\n     * @returns Cleanup function\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const stop = A11y.roving(toolbar, 'button', { axis: 'horizontal' });\r\n     * ```\r\n     */\r\n    roving: (\r\n      root: HTMLElement | null,\r\n      selector: string,\r\n      options: A11yRovingOptions = {}\r\n    ): Unsubscribe => {\r\n      if (!root) return () => { };\r\n\r\n      const items = Array.from(root.querySelectorAll<HTMLElement>(selector));\r\n      if (items.length === 0) return () => { };\r\n\r\n      const axis = options.axis ?? 'both';\r\n      const loop = options.loop ?? true;\r\n\r\n      const resolveInitial = () => {\r\n        if (typeof options.initial === 'number') {\r\n          return Math.min(Math.max(options.initial, 0), items.length - 1);\r\n        }\r\n        if (options.initial instanceof HTMLElement) {\r\n          const idx = items.indexOf(options.initial);\r\n          if (idx >= 0) return idx;\r\n        }\r\n        const existing = items.findIndex((item) => item.tabIndex === 0);\r\n        return existing >= 0 ? existing : 0;\r\n      };\r\n\r\n      let currentIndex = resolveInitial();\r\n\r\n      const setActive = (index: number, focusItem: boolean) => {\r\n        currentIndex = index;\r\n        items.forEach((item, i) => {\r\n          item.tabIndex = i === index ? 0 : -1;\r\n        });\r\n        if (focusItem) {\r\n          items[index]?.focus();\r\n        }\r\n      };\r\n\r\n      setActive(currentIndex, false);\r\n\r\n      const handleKey = (e: KeyboardEvent) => {\r\n        const key = e.key;\r\n        const isHorizontal = axis === 'horizontal' || axis === 'both';\r\n        const isVertical = axis === 'vertical' || axis === 'both';\r\n\r\n        let nextIndex = currentIndex;\r\n\r\n        if (key === 'Home') {\r\n          nextIndex = 0;\r\n        } else if (key === 'End') {\r\n          nextIndex = items.length - 1;\r\n        } else if (isHorizontal && key === 'ArrowRight') {\r\n          nextIndex = currentIndex + 1;\r\n        } else if (isHorizontal && key === 'ArrowLeft') {\r\n          nextIndex = currentIndex - 1;\r\n        } else if (isVertical && key === 'ArrowDown') {\r\n          nextIndex = currentIndex + 1;\r\n        } else if (isVertical && key === 'ArrowUp') {\r\n          nextIndex = currentIndex - 1;\r\n        } else {\r\n          return;\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        if (loop) {\r\n          if (nextIndex < 0) nextIndex = items.length - 1;\r\n          if (nextIndex >= items.length) nextIndex = 0;\r\n        } else {\r\n          nextIndex = Math.min(Math.max(nextIndex, 0), items.length - 1);\r\n        }\r\n\r\n        setActive(nextIndex, true);\r\n      };\r\n\r\n      root.addEventListener('keydown', handleKey);\r\n      return () => root.removeEventListener('keydown', handleKey);\r\n    }\r\n  };\r\n})();\r\n\r\n// =============================================================================\r\n// 34. TEXT QUERYING\r\n// =============================================================================\r\n\r\nexport const Text = {\r\n  /**\r\n   * Finds all elements containing the specified text or matching a Regex.\r\n   * \r\n   * @example\r\n   * // Find all buttons saying \"Submit\"\r\n   * const btns = Text.findAll(document)('Submit', 'button');\r\n   * \r\n   * // Find using Regex\r\n   * const prices = Text.findAll(table)(/$\\d+\\.\\d{2}/);\r\n   */\r\n  findAll: (root: Element | Document = document) => {\r\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element[] => {\r\n      const matches = new Set<Element>();\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n\r\n      let node: Node | null;\r\n      while ((node = walker.nextNode())) {\r\n        const parent = node.parentElement;\r\n        const content = node.nodeValue || '';\r\n\r\n        // 1. Check if parent matches selector\r\n        if (!parent || !parent.matches(selector)) continue;\r\n\r\n        // 2. Check text match\r\n        const isMatch = typeof textOrRegex === 'string'\r\n          ? content.includes(textOrRegex)\r\n          : textOrRegex.test(content);\r\n\r\n        if (isMatch) matches.add(parent);\r\n      }\r\n\r\n      return Array.from(matches);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Finds the FIRST element containing the text.\r\n   * \r\n   * @example\r\n   * const btn = Text.find(form)('Save');\r\n   */\r\n  find: (root: Element | Document = document) => {\r\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element | null => {\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n      let node: Node | null;\r\n\r\n      while ((node = walker.nextNode())) {\r\n        const parent = node.parentElement;\r\n        const content = node.nodeValue || '';\r\n\r\n        if (!parent || !parent.matches(selector)) continue;\r\n\r\n        const isMatch = typeof textOrRegex === 'string'\r\n          ? content.includes(textOrRegex)\r\n          : textOrRegex.test(content);\r\n\r\n        if (isMatch) return parent;\r\n      }\r\n      return null;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Replaces text in the target's descendants.\r\n   * Safe wrapper that only touches text nodes, preserving HTML structure.\r\n   * \r\n   * @example\r\n   * Text.replace(document.body)('foo', 'bar');\r\n   */\r\n  replace: (root: Element | null) => {\r\n    return (searchValue: string | RegExp, replaceValue: string) => {\r\n      if (!root) return root;\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n      let node: Node | null;\r\n\r\n      while ((node = walker.nextNode())) {\r\n        const val = node.nodeValue || '';\r\n        if (typeof searchValue === 'string' ? val.includes(searchValue) : searchValue.test(val)) {\r\n          node.nodeValue = val.replace(searchValue, replaceValue);\r\n        }\r\n      }\r\n      return root;\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 33. VIEW TRANSITIONS\r\n// =============================================================================\r\n\r\n// Type shim for environments where ViewTransition isn't in 'lib' yet\r\ninterface ViewTransition {\r\n  finished: Promise<void>;\r\n  ready: Promise<void>;\r\n  updateCallbackDone: Promise<void>;\r\n  skipTransition(): void;\r\n}\r\n\r\nexport const ViewTransitions = {\r\n  /** Checks if View Transitions are supported. */\r\n  isSupported: () => 'startViewTransition' in document,\r\n\r\n  /**\r\n   * Sets the `view-transition-name` on an element.\r\n   * Essential for connecting elements across DOM updates.\r\n   * \r\n   * @example View.name(img)('hero-image');\r\n   */\r\n  name: (target: HTMLElement | null) => (name: string) => {\r\n    if (target) target.style.viewTransitionName = name;\r\n    return target;\r\n  },\r\n\r\n  /** Removes the view-transition-name. */\r\n  unname: (target: HTMLElement | null) => {\r\n    if (target) target.style.removeProperty('view-transition-name');\r\n    return target;\r\n  },\r\n\r\n  /**\r\n   * Starts a global View Transition.\r\n   * Gracefully falls back to immediate execution if not supported.\r\n   * \r\n   * @example\r\n   * ViewTransitions.start(() => {\r\n   *   // Update DOM here\r\n   *   document.body.append(newPage);\r\n   * });\r\n   */\r\n  start: (updateCallback: () => Promise<void> | void): ViewTransition | null => {\r\n    if (!('startViewTransition' in document)) {\r\n      updateCallback();\r\n      return null;\r\n    }\r\n    // @ts-ignore\r\n    return document.startViewTransition(updateCallback);\r\n  },\r\n\r\n  /**\r\n   * Starts a transition with a specific class applied to the document element.\r\n   * Useful for defining different animations (e.g. 'slide-left' vs 'slide-right').\r\n   * \r\n   * @example ViewTransitions.withClass('slide-back')(() => history.back());\r\n   */\r\n  withClass: (className: string) => (updateCallback: () => Promise<void> | void) => {\r\n    document.documentElement.classList.add(className);\r\n\r\n    const transition = ViewTransitions.start(updateCallback);\r\n\r\n    if (transition) {\r\n      transition.finished.finally(() => document.documentElement.classList.remove(className));\r\n    } else {\r\n      document.documentElement.classList.remove(className);\r\n    }\r\n    return transition;\r\n  },\r\n\r\n  /**\r\n   * Applies a transition name to an element ONLY for the duration of the next transition.\r\n   * Auto-cleans up the name when the transition finishes.\r\n   * \r\n   * @example View.tempName(img)('hero-morph')(async () => updateDOM());\r\n   */\r\n  tempName: (target: HTMLElement | null) => (name: string) => {\r\n    return (updateCallback: () => Promise<void> | void) => {\r\n      if (!target) return ViewTransitions.start(updateCallback);\r\n\r\n      target.style.viewTransitionName = name;\r\n      const transition = ViewTransitions.start(updateCallback);\r\n\r\n      if (transition) {\r\n        transition.finished.finally(() => target.style.removeProperty('view-transition-name'));\r\n      } else {\r\n        target.style.removeProperty('view-transition-name');\r\n      }\r\n      return transition;\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 34. ASYNC & PROMISES\r\n// =============================================================================\r\n\r\nexport const Async = {\r\n  /**\r\n   * Wraps a value or Promise in a Promise (safe normalization).\r\n   */\r\n  resolve: <T>(v: T | PromiseLike<T>): Promise<T> => Promise.resolve(v),\r\n\r\n  /**\r\n   * Sleeps for N milliseconds.\r\n   * @example await Async.sleep(1000);\r\n   */\r\n  sleep: (ms: number) => new Promise(resolve => setTimeout(resolve, ms)),\r\n\r\n  /**\r\n   * Waits for the next Animation Frame.\r\n   */\r\n  nextFrame: () => new Promise(resolve => requestAnimationFrame(resolve)),\r\n\r\n  /**\r\n   * Retries a function N times with exponential backoff.\r\n   * \r\n   * @example\r\n   * const data = await Async.retry(() => api.get(), { retries: 3 });\r\n   */\r\n  retry: <T>(\r\n    fn: () => Promise<T>,\r\n    options: { retries?: number, delay?: number, factor?: number } = {}\r\n  ): Promise<T> => {\r\n    const { retries = 3, delay = 100, factor = 2 } = options;\r\n\r\n    return fn().catch(err => {\r\n      if (retries <= 0) throw err;\r\n      return Async.sleep(delay).then(() =>\r\n        Async.retry(fn, { retries: retries - 1, delay: delay * factor, factor })\r\n      );\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Races a promise against a timeout.\r\n   * Throws 'TimeoutError' if time limit exceeded.\r\n   * \r\n   * @example\r\n   * await Async.timeout(fetch('/long'), 5000);\r\n   */\r\n  timeout: <T>(promise: Promise<T>, ms: number): Promise<T> => {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => setTimeout(() => reject(new Error('TimeoutError')), ms))\r\n    ]);\r\n  },\r\n\r\n  /**\r\n   * Limits concurrency of a map function.\r\n   * Useful for batch processing without flooding the network.\r\n   * \r\n   * @example\r\n   * await Async.map(userIds, fetchUser, 2); // 2 at a time\r\n   */\r\n  map: async <T, R>(\r\n    items: T[],\r\n    fn: (item: T, index: number) => Promise<R>,\r\n    concurrency: number = Infinity\r\n  ): Promise<R[]> => {\r\n    const results: R[] = [];\r\n    const queue = items.map((item, i) => ({ item, i }));\r\n\r\n    const worker = async () => {\r\n      while (queue.length > 0) {\r\n        const { item, i } = queue.shift()!;\r\n        results[i] = await fn(item, i);\r\n      }\r\n    };\r\n\r\n    await Promise.all(Array.from({ length: Math.min(items.length, concurrency) }, worker));\r\n    return results;\r\n  },\r\n\r\n  /**\r\n   * Creates a \"Deferred\" promise object (exposed resolve/reject).\r\n   * \r\n   * @example\r\n   * const { promise, resolve } = Async.defer();\r\n   */\r\n  defer: <T>() => {\r\n    let resolve!: (value: T | PromiseLike<T>) => void;\r\n    let reject!: (reason?: any) => void;\r\n    const promise = new Promise<T>((res, rej) => { resolve = res; reject = rej; });\r\n    return { promise, resolve, reject };\r\n  },\r\n\r\n  /**\r\n   * Wraps a promise to make it \"Cancelable\" (wrapper only).\r\n   * Note: Does not stop the underlying operation, just ignores the result.\r\n   */\r\n  cancelable: <T>(promise: Promise<T>) => {\r\n    let isCanceled = false;\r\n    const wrapped = new Promise<T>((resolve, reject) => {\r\n      promise.then(\r\n        val => !isCanceled && resolve(val),\r\n        err => !isCanceled && reject(err)\r\n      );\r\n    });\r\n    return {\r\n      promise: wrapped,\r\n      cancel: () => { isCanceled = true; }\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 35. TASK QUEUE\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a Task Queue with concurrency control.\r\n * Useful for throttling API calls, toasts, or sequential animations.\r\n * \r\n * @example\r\n * const q = createQueue({ concurrency: 1 });\r\n * q.add(() => api.save(A));\r\n * q.add(() => api.save(B));\r\n * await q.drain();\r\n */\r\nexport const createQueue = (options: { concurrency?: number, autoStart?: boolean } = {}) => {\r\n  type Task<T = any> = () => Promise<T> | T;\r\n\r\n  const concurrency = options.concurrency || 1;\r\n  const queue: { fn: Task, resolve: Function, reject: Function }[] = [];\r\n  let active = 0;\r\n  let isPaused = !options.autoStart && options.autoStart !== undefined;\r\n\r\n  // Event listeners\r\n  const listeners: Record<string, Function[]> = {\r\n    drain: [],\r\n    error: []\r\n  };\r\n\r\n  const next = () => {\r\n    if (isPaused || active >= concurrency || queue.length === 0) {\r\n      if (active === 0 && queue.length === 0) listeners.drain.forEach(fn => fn());\r\n      return;\r\n    }\r\n\r\n    const job = queue.shift();\r\n    if (!job) return;\r\n\r\n    active++;\r\n\r\n    Promise.resolve()\r\n      .then(() => job.fn())\r\n      .then(res => job.resolve(res))\r\n      .catch(err => {\r\n        listeners.error.forEach(fn => fn(err));\r\n        job.reject(err);\r\n      })\r\n      .finally(() => {\r\n        active--;\r\n        next();\r\n      });\r\n\r\n    next(); // Try to start more if concurrency allows\r\n  };\r\n\r\n  return {\r\n    /** Adds a task to the queue. Returns a promise that resolves when the task finishes. */\r\n    add: <T>(fn: Task<T>): Promise<T> => {\r\n      return new Promise((resolve, reject) => {\r\n        queue.push({ fn, resolve, reject });\r\n        next();\r\n      });\r\n    },\r\n\r\n    /** Pauses processing. Active tasks complete, but new ones wait. */\r\n    pause: () => { isPaused = true; },\r\n\r\n    /** Resumes processing. */\r\n    resume: () => { isPaused = false; next(); },\r\n\r\n    /** Clears all pending tasks. */\r\n    clear: () => { queue.length = 0; },\r\n\r\n    /** Returns the number of pending + active tasks. */\r\n    size: () => queue.length + active,\r\n\r\n    /** Returns a promise that resolves when all tasks are complete. */\r\n    drain: () => new Promise<void>(resolve => {\r\n      if (active === 0 && queue.length === 0) return resolve();\r\n      listeners.drain.push(resolve);\r\n    }),\r\n\r\n    /** Listen for errors (globally for the queue). */\r\n    onError: (fn: (err: any) => void) => listeners.error.push(fn)\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 36. HISTORY & URL STATE\r\n// =============================================================================\r\n\r\n/**\r\n * Valid types for URL Query Parameters.\r\n */\r\nexport type QueryValue = string | number | boolean | null | undefined;\r\nexport type QueryParams = Record<string, QueryValue | QueryValue[]>;\r\n\r\nexport const History = {\r\n  /**\r\n   * Updates the URL Query Parameters with new values.\r\n   * Merges with existing params. Pass `null` or `undefined` to remove a key.\r\n   * Handles arrays as repeated params (e.g., `?tag=a&tag=b`).\r\n   * \r\n   * Order: params -> (mode?)\r\n   * \r\n   * @example \r\n   * // Results in ?page=2&sort=desc\r\n   * History.query({ page: 2, sort: 'desc' })(); \r\n   * \r\n   * // Replace history instead of push\r\n   * History.query({ tab: 'settings' })('replace');\r\n   */\r\n  query: (params: QueryParams) => (mode: 'push' | 'replace' = 'push') => {\r\n    const url = new URL(window.location.href);\r\n\r\n    Object.entries(params).forEach(([k, v]) => {\r\n      // 1. Remove existing keys to overwrite/clear them\r\n      url.searchParams.delete(k);\r\n\r\n      // 2. Set new values\r\n      if (v === null || v === undefined || v === '') return;\r\n\r\n      if (Array.isArray(v)) {\r\n        v.forEach(item => url.searchParams.append(k, String(item)));\r\n      } else {\r\n        url.searchParams.set(k, String(v));\r\n      }\r\n    });\r\n\r\n    const method = mode === 'replace' ? 'replaceState' : 'pushState';\r\n    window.history[method](window.history.state, '', url.href);\r\n  },\r\n\r\n  /**\r\n   * Reads current Query Parameters into a typed Object.\r\n   * Note: duplicate keys (arrays) will return the *last* value, \r\n   * use `History.readQueryAll()` if you expect arrays.\r\n   * \r\n   * @template T\r\n   * @returns {T}\r\n   * \r\n   * @example \r\n   * const { page, sort } = History.readQuery<{ page: string, sort: string }>();\r\n   */\r\n  readQuery: <T extends Record<string, string>>(): T => {\r\n    return Object.fromEntries(new URLSearchParams(window.location.search)) as unknown as T;\r\n  },\r\n\r\n  /**\r\n   * Reads Query Parameters, ensuring all values are arrays.\r\n   * Useful for filters like `?tags=a&tags=b`.\r\n   */\r\n  readQueryAll: (): Record<string, string[]> => {\r\n    const params: Record<string, string[]> = {};\r\n    new URLSearchParams(window.location.search).forEach((val, key) => {\r\n      (params[key] = params[key] || []).push(val);\r\n    });\r\n    return params;\r\n  },\r\n\r\n  /**\r\n   * Pushes a new entry onto the history stack with optional state.\r\n   * \r\n   * @template T - Type of the state object\r\n   * @example History.push('/profile', { userId: 123 });\r\n   */\r\n  push: <T = any>(path: string, state?: T) => {\r\n    window.history.pushState(state, '', path);\r\n  },\r\n\r\n  /**\r\n   * Replaces the current history entry.\r\n   * \r\n   * @template T - Type of the state object\r\n   * @example History.replace(window.location.pathname, { scrolled: true });\r\n   */\r\n  replace: <T = any>(path: string, state?: T) => {\r\n    window.history.replaceState(state, '', path);\r\n  },\r\n\r\n  /**\r\n   * Gets the current history state object with Type Safety.\r\n   * \r\n   * @template T\r\n   * @example const state = History.state<{ userId: number }>();\r\n   */\r\n  state: <T>(): T | null => {\r\n    return window.history.state as T;\r\n  },\r\n\r\n  /**\r\n   * Navigates back in history.\r\n   */\r\n  back: () => window.history.back(),\r\n\r\n  /**\r\n   * Navigates forward in history.\r\n   */\r\n  forward: () => window.history.forward(),\r\n\r\n  /**\r\n   * Reloads the current page.\r\n   */\r\n  reload: () => window.location.reload(),\r\n\r\n  /**\r\n   * Listens for history changes (Back/Forward buttons).\r\n   * Returns a cleanup function.\r\n   * \r\n   * @example \r\n   * const stop = History.onPop(e => console.log('Navigated to', e.state));\r\n   */\r\n  onPop: (handler: (e: PopStateEvent) => void): Unsubscribe => {\r\n    window.addEventListener('popstate', handler);\r\n    return () => window.removeEventListener('popstate', handler);\r\n  },\r\n\r\n  /**\r\n   * Serializes an object to a Unicode-safe Base64 string.\r\n   * Useful for storing complex state in the URL hash.\r\n   * \r\n   * @example window.location.hash = History.encodeState({ filters: [...] });\r\n   */\r\n  encodeState: (state: any): string => {\r\n    try {\r\n      const json = JSON.stringify(state);\r\n      // encodeURIComponent handles Unicode chars that btoa chokes on\r\n      return btoa(encodeURIComponent(json).replace(/%([0-9A-F]{2})/g,\r\n        (_, p1) => String.fromCharCode(parseInt(p1, 16))\r\n      ));\r\n    } catch { return ''; }\r\n  },\r\n\r\n  /**\r\n   * Deserializes a Base64 string back to an object.\r\n   */\r\n  decodeState: <T>(str: string): T | null => {\r\n    try {\r\n      const json = decodeURIComponent(Array.prototype.map.call(atob(str),\r\n        (c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\r\n      ).join(''));\r\n      return JSON.parse(json);\r\n    } catch { return null; }\r\n  },\r\n\r\n  /**\r\n * Two-way binds a form input to a URL Query Parameter.\r\n * \r\n * Features:\r\n * 1. Sets input value from URL on load.\r\n * 2. Updates URL on input change (debounced).\r\n * 3. Updates input on PopState (Back/Forward button).\r\n * \r\n * Order: paramName -> debounceMs -> element\r\n * \r\n * @example \r\n * const searchInput = find(document)('#search');\r\n * History.syncToUrl('q', 300)(searchInput);\r\n */\r\n  syncToUrl: (paramName: string, debounceMs = 300) => (target: HTMLElement | null): Unsubscribe => {\r\n    if (!target) return () => { };\r\n\r\n    // Determine if element is Checkbox/Radio or Text-like\r\n    const isCheckable = (target as HTMLInputElement).type === 'checkbox' || (target as HTMLInputElement).type === 'radio';\r\n\r\n    // 1. READ: Function to update DOM from URL\r\n    const updateFromUrl = () => {\r\n      const val = new URLSearchParams(window.location.search).get(paramName);\r\n      if (val === null) return; // No param = do nothing (or clear?)\r\n\r\n      if (isCheckable) {\r\n        (target as HTMLInputElement).checked = val === 'true';\r\n      } else {\r\n        (target as HTMLInputElement).value = val;\r\n      }\r\n    };\r\n\r\n    // 2. WRITE: Function to update URL from DOM\r\n    const updateToUrl = debounce(() => {\r\n      const val = isCheckable\r\n        ? String((target as HTMLInputElement).checked)\r\n        : (target as HTMLInputElement).value;\r\n\r\n      History.query({ [paramName]: val })('replace');\r\n    }, debounceMs);\r\n\r\n    // 3. BIND: Attach listeners\r\n    updateFromUrl(); // Initial sync\r\n\r\n    target.addEventListener('input', updateToUrl);\r\n    target.addEventListener('change', updateToUrl);\r\n    window.addEventListener('popstate', updateFromUrl);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      target.removeEventListener('input', updateToUrl);\r\n      target.removeEventListener('change', updateToUrl);\r\n      window.removeEventListener('popstate', updateFromUrl);\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// 0.1 FUNCTIONAL COMBINATORS\r\n// =============================================================================\r\n\r\n// =============================================================================\r\n// FUNCTIONAL COMBINATORS & UTILITIES\r\n// =============================================================================\r\n\r\nexport type WithArgMapped<E, F extends Array<(arg: E, ...args: any[]) => any>> = {\r\n  [K in keyof F]: F[K] extends (arg: E, ...args: infer A) => infer R ? (...args: A) => R : never;\r\n};\r\n\r\nexport type WithArgFn = {\r\n  <E>(arg: E): <F extends Array<(arg: E, ...args: any[]) => any>>(\r\n    ...fns: F\r\n  ) => WithArgMapped<E, F>;\r\n  <E, F extends Array<(arg: E, ...args: any[]) => any>>(\r\n    arg: E,\r\n    ...fns: F\r\n  ): WithArgMapped<E, F>;\r\n};\r\n\r\nexport type DataLastFn<D, A extends any[], R> = {\r\n  (...args: [...A, D]): R;\r\n  (...args: A): (data: D) => R;\r\n};\r\n\r\nexport type DataLastMapped<D, F extends Array<(data: D, ...args: any[]) => any>> = {\r\n  [K in keyof F]: F[K] extends (data: D, ...args: infer A) => infer R ? DataLastFn<D, A, R> : never;\r\n};\r\n\r\nexport type DataLastPredFn = {\r\n  <D>(isData: (value: unknown) => value is D): <F extends Array<(data: D, ...args: any[]) => any>>(\r\n    ...fns: F\r\n  ) => DataLastMapped<D, F>;\r\n  <D, F extends Array<(data: D, ...args: any[]) => any>>(\r\n    isData: (value: unknown) => value is D,\r\n    ...fns: F\r\n  ): DataLastMapped<D, F>;\r\n};\r\n\r\nexport type DataLastElFn = {\r\n  <D extends ElementInput, F extends Array<(data: D, ...args: any[]) => any>>(\r\n    ...fns: F\r\n  ): DataLastMapped<D, F>;\r\n};\r\n\r\nexport type FlexFn<D, A extends any[], R> = {\r\n  (data: D, ...args: A): R;\r\n  (...args: [...A, D]): R;\r\n  (data: D): (...args: A) => R;\r\n  (...args: A): (data: D) => R;\r\n};\r\n\r\nexport type FlexMapped<D, F extends Array<(data: D, ...args: any[]) => any>> = {\r\n  [K in keyof F]: F[K] extends (data: D, ...args: infer A) => infer R ? FlexFn<D, A, R> : never;\r\n};\r\n\r\nexport type FlexElFn = {\r\n  <D extends ElementInput, F extends Array<(data: D, ...args: any[]) => any>>(\r\n    ...fns: F\r\n  ): FlexMapped<D, F>;\r\n};\r\n\r\nexport type Path = string | Array<string | number>;\r\n\r\n/**\r\n * Represents a function that can be called either Data-First or Data-Last.\r\n */\r\ninterface DualModeFn<D, A extends any[], R> {\r\n  // Signature 1: Data First (Standard)\r\n  (data: D, ...args: A): R;\r\n\r\n  // Signature 2: Data Last (Inverted)\r\n  // Uses Variadic Tuple Types to append D to the end of A\r\n  (...argsThenData: [...A, D]): R;\r\n}\r\n\r\n\r\n/**\r\n * A collection of functional programming helpers for composition, currying,\r\n * and creating point-free logic. Essential for building complex behaviors\r\n * from small, reusable functions.\r\n */\r\nexport const Fn = {\r\n  def,\r\n\r\n\r\n/**\r\n * Creates a function that accepts data as either the first OR the last argument.\r\n * \r\n * @param fn - The original function (must be written as Data-First: (data, ...args) => result)\r\n * @param isData - A Type Guard to identify the Data argument at runtime.\r\n */\r\n makeDataFirstOrLast<D, A extends any[], R>(\r\n  fn: (data: D, ...args: A) => R,\r\n  isData: (input: any) => input is D\r\n): DualModeFn<D, A, R> {\r\n  \r\n  // We return a new function that handles the logic\r\n  return ((...args: any[]): R => {\r\n    \r\n    // Runtime Logic: Check if the FIRST argument is Data\r\n    if (args.length > 0 && isData(args[0])) {\r\n      // MODE: Data First -> fn(data, ...args)\r\n      const data = args[0] as D;\r\n      const rest = args.slice(1) as A;\r\n      return fn(data, ...rest);\r\n    } \r\n    \r\n    // Runtime Logic: Check if the LAST argument is Data\r\n    const lastIndex = args.length - 1;\r\n    if (lastIndex >= 0 && isData(args[lastIndex])) {\r\n      // MODE: Data Last -> fn(...args, data)\r\n      const data = args[lastIndex] as D;\r\n      const rest = args.slice(0, lastIndex) as A;\r\n      // We must cast 'rest' to A because runtime slicing is loose\r\n      return fn(data, ...rest as unknown as A);\r\n    }\r\n\r\n    throw new Error(\r\n      \"Could not determine call signature: Data argument not found at start or end.\"\r\n    );\r\n  }) as DualModeFn<D, A, R>; // Cast implementation to the overloaded interface\r\n },\r\n\r\n  /**\r\n   * (B-Combinator) Chains functions in left-to-right order.\r\n   * `pipe(f, g, h)(x)` is equivalent to `h(g(f(x)))`.\r\n   * \r\n   * @param fns - The sequence of functions to apply.\r\n   * @returns A new function that applies the sequence to its input.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, modify, cls } from '@doeixd/dom';\r\n   * \r\n   * const makeActive = Fn.pipe(\r\n   *   modify({ text: 'Active' }),\r\n   *   cls.add('is-active')\r\n   * );\r\n   * \r\n   * makeActive(myButton);\r\n   * ```\r\n   */\r\n  pipe: <T>(...fns: Array<(arg: any) => any>) => (x: T): any => fns.reduce((v, f) => f(v), x),\r\n\r\n  /**\r\n   * Alias for `chain` utility.\r\n   */\r\n  chain,\r\n\r\n  /**\r\n   * Alias for `exec` utility.\r\n   */\r\n  exec,\r\n\r\n  /**\r\n   * Converts a function that takes two arguments `fn(a, b)` into a curried\r\n   * function that takes them one at a time `fn(a)(b)`.\r\n   * \r\n   * @param fn - The binary function to curry.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const add = (a: number, b: number) => a + b;\r\n   * const curriedAdd = Fn.curry(add);\r\n   * const add5 = curriedAdd(5);\r\n   * add5(3); // 8\r\n   * ```\r\n   */\r\n  curry: <A, B, R>(fn: (a: A, b: B) => R) => (a: A) => (b: B): R => fn(a, b),\r\n\r\n  /**\r\n   * Prefills the first argument for multiple functions.\r\n   *\r\n   * Supports both call styles:\r\n   * - `Fn.withArg(arg, fn1, fn2)`\r\n   * - `Fn.withArg(arg)(fn1, fn2)`\r\n   *\r\n   * Returns a tuple of functions with `arg` applied as the first parameter.\r\n   *\r\n   * @template E - The first argument type\r\n   * @template F - Tuple of functions that accept `E` first\r\n   * @param arg - The argument to prefill\r\n   * @param fns - Functions to prefill with `arg`\r\n   * @returns Tuple of functions with `arg` applied\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on, modify } from '@doeixd/dom';\r\n   *\r\n   * const [onButton, modifyButton] = Fn.withArg(button, on, modify);\r\n   * onButton('click', handler);\r\n   * modifyButton({ text: 'Save' });\r\n   *\r\n   * const [onCard, modifyCard] = Fn.withArg(card)(on, modify);\r\n   * onCard('mouseenter', handler);\r\n   * modifyCard({ class: { active: true } });\r\n   * ```\r\n   */\r\n  withArg: (() => {\r\n    const apply = <E, F extends Array<(arg: E, ...args: any[]) => any>>(\r\n      arg: E,\r\n      fns: F\r\n    ) => fns.map(fn => (...args: any[]) => fn(arg, ...args)) as any;\r\n\r\n    const wrapper = (arg: any, ...fns: any[]) => {\r\n      if (fns.length > 0) {\r\n        return apply(arg, fns);\r\n      }\r\n      return (...rest: any[]) => apply(arg, rest);\r\n    };\r\n\r\n    return wrapper as WithArgFn;\r\n  })(),\r\n\r\n  /**\r\n   * Converts a data-first function into a data-last, dual-mode function.\r\n   *\r\n   * Turns `(data, ...args) => result` into:\r\n   * - Immediate: `(...args, data) => result`\r\n   * - Curried: `(...args) => (data) => result`\r\n   *\r\n   * Detection defaults to arity (`fn.length`) and can be customized with:\r\n   * - `arity`: expected argument count (including data)\r\n   * - `isData`: predicate for the last argument\r\n   *\r\n   * @template D - The data type\r\n   * @template A - Argument tuple (excluding data)\r\n   * @template R - Return type\r\n   * @param fn - Data-first function\r\n   * @param config - Optional arity or predicate config\r\n   * @returns Dual-mode data-last function\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on } from '@doeixd/dom';\r\n   *\r\n   * const onLast = Fn.dataLast(on, { arity: 3 });\r\n   * onLast('click', handler, button); // Immediate\r\n   * onLast('click', handler)(button); // Curried\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, modify } from '@doeixd/dom';\r\n   *\r\n   * const modifyLast = Fn.dataLast(modify, (value): value is HTMLElement => value instanceof HTMLElement);\r\n   * modifyLast({ text: 'Save' }, button);\r\n   * modifyLast({ text: 'Save' })(button);\r\n   * ```\r\n   */\r\n  dataLast: <D, A extends any[], R>(\r\n    fn: (data: D, ...args: A) => R,\r\n    config?:\r\n      | number\r\n      | ((value: unknown) => value is D)\r\n      | { arity?: number; isData?: (value: unknown) => value is D }\r\n  ): DataLastFn<D, A, R> => {\r\n    const arity =\r\n      typeof config === 'number'\r\n        ? config\r\n        : typeof config === 'function'\r\n          ? fn.length\r\n          : config?.arity ?? fn.length;\r\n    const isData =\r\n      typeof config === 'function'\r\n        ? config\r\n        : typeof config === 'number'\r\n          ? undefined\r\n          : config?.isData;\r\n\r\n    return ((...args: any[]) => {\r\n      if (isData) {\r\n        if (args.length > 0 && isData(args[args.length - 1])) {\r\n          const data = args[args.length - 1] as D;\r\n          const rest = args.slice(0, -1) as A;\r\n          return fn(data, ...rest);\r\n        }\r\n        return (data: D) => fn(data, ...(args as A));\r\n      }\r\n\r\n      if (args.length >= arity) {\r\n        const data = args[args.length - 1] as D;\r\n        const rest = args.slice(0, -1) as A;\r\n        return fn(data, ...rest);\r\n      }\r\n\r\n      return (data: D) => fn(data, ...(args as A));\r\n    }) as DataLastFn<D, A, R>;\r\n  },\r\n\r\n  /**\r\n   * Builds a data-last transformer from a predicate.\r\n   *\r\n   * Useful when arity detection is ambiguous or when the data argument can be\r\n   * inferred by shape (like elements, selectors, or custom objects).\r\n   *\r\n   * Supports both call styles:\r\n   * - `Fn.dataLastPred(isData, fn1, fn2)`\r\n   * - `Fn.dataLastPred(isData)(fn1, fn2)`\r\n   *\r\n   * @param isData - Predicate that identifies the data argument\r\n   * @returns Data-last versions of the provided functions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on } from '@doeixd/dom';\r\n   *\r\n   * const isElement = (value: unknown): value is HTMLElement => value instanceof HTMLElement;\r\n   * const [onLast] = Fn.dataLastPred(isElement)(on);\r\n   *\r\n   * onLast('click', handler, button);\r\n   * onLast('click', handler)(button);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, modify, cls } from '@doeixd/dom';\r\n   *\r\n   * const isTarget = (value: unknown): value is HTMLElement | null =>\r\n   *   value === null || value instanceof HTMLElement;\r\n   *\r\n   * const [modifyLast, addClassLast] = Fn.dataLastPred(isTarget)(modify, cls.add);\r\n   * modifyLast({ text: 'Save' }, button);\r\n   * addClassLast('active', button);\r\n   * ```\r\n   */\r\n  dataLastPred: (() => {\r\n    const wrapper = (isData: any, ...fns: any[]) => {\r\n      if (fns.length > 0) {\r\n        return fns.map(fn => Fn.dataLast(fn, { isData })) as any;\r\n      }\r\n      return (...rest: any[]) => rest.map(fn => Fn.dataLast(fn, { isData })) as any;\r\n    };\r\n\r\n    return wrapper as DataLastPredFn;\r\n  })(),\r\n\r\n  /**\r\n   * Element/selector-aware data-last helper.\r\n   *\r\n   * Uses a built-in predicate that treats `ElementInput` as the data argument,\r\n   * enabling immediate vs curried behavior for element/selector inputs.\r\n   *\r\n   * @returns Data-last versions of the provided functions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on, modify } from '@doeixd/dom';\r\n   *\r\n   * const [onLast, modifyLast] = Fn.dataLastEl(on, modify);\r\n   *\r\n   * onLast('click', handler, button);\r\n   * onLast('click', handler)(button);\r\n   * onLast('click', handler, '#save');\r\n   * onLast('click', handler)('#save');\r\n   *\r\n   * modifyLast({ text: 'Save' }, button);\r\n   * modifyLast({ text: 'Save' })('#save');\r\n   * ```\r\n   */\r\n  dataLastEl: (() => {\r\n    const isElementInput = (value: unknown): value is ElementInput => {\r\n      if (value === null || value === undefined) return true;\r\n      if (typeof value === 'string') return true;\r\n      if (typeof value === 'function') return true;\r\n      return value instanceof Element;\r\n    };\r\n\r\n    const wrapper = (...fns: any[]) => Fn.dataLastPred(isElementInput)(...fns);\r\n\r\n    return wrapper as DataLastElFn;\r\n  })(),\r\n\r\n  /**\r\n   * Makes a function flexible about the position of its first argument.\r\n   *\r\n   * Supports all of the following call styles:\r\n   * - `fnFlex(firstArg, ...rest)`\r\n   * - `fnFlex(firstArg)(...rest)`\r\n   * - `fnFlex(...rest, firstArg)`\r\n   * - `fnFlex(...rest)(firstArg)`\r\n   *\r\n   * For ambiguous signatures, pass a predicate to identify the first argument\r\n   * (the \"subject\") so immediate vs curried behavior is deterministic.\r\n   *\r\n   * @template D - The first argument type\r\n   * @template A - Remaining arguments tuple\r\n   * @template R - Return type\r\n   * @param fn - Function to wrap\r\n   * @param isFirstArg - Optional predicate for the first argument\r\n   * @returns A flexible function with both data-first and data-last usage\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on } from '@doeixd/dom';\r\n   *\r\n   * const isElement = (value: unknown): value is HTMLElement => value instanceof HTMLElement;\r\n   * const onFlex = Fn.flex(on, isElement);\r\n   *\r\n   * onFlex(button, 'click', handler);\r\n   * onFlex(button)('click', handler);\r\n   * onFlex('click', handler, button);\r\n   * onFlex('click', handler)(button);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, modify } from '@doeixd/dom';\r\n   *\r\n   * const isTarget = (value: unknown): value is HTMLElement | null =>\r\n   *   value === null || value instanceof HTMLElement;\r\n   *\r\n   * const modifyFlex = Fn.flex(modify, isTarget);\r\n   * modifyFlex(button, { text: 'Save' });\r\n   * modifyFlex({ text: 'Save' }, button);\r\n   * ```\r\n   */\r\n  flex: <D, A extends any[], R>(\r\n    fn: (data: D, ...args: A) => R,\r\n    isFirstArg?: (value: unknown) => value is D\r\n  ): FlexFn<D, A, R> => {\r\n    const arity = fn.length;\r\n\r\n    return ((...args: any[]) => {\r\n      if (args.length === 0) {\r\n        return (data: D) => fn(data, ...([] as unknown as A));\r\n      }\r\n\r\n      if (isFirstArg) {\r\n        const first = args[0];\r\n        if (isFirstArg(first)) {\r\n          if (args.length === 1) {\r\n            return (...rest: A) => fn(first, ...rest);\r\n          }\r\n          return fn(first, ...(args.slice(1) as A));\r\n        }\r\n\r\n        const last = args[args.length - 1];\r\n        if (isFirstArg(last)) {\r\n          if (args.length === 1) {\r\n            return (...rest: A) => fn(last, ...rest);\r\n          }\r\n          return fn(last, ...(args.slice(0, -1) as A));\r\n        }\r\n      }\r\n\r\n      if (args.length >= arity) {\r\n        return fn(args[0], ...(args.slice(1) as A));\r\n      }\r\n\r\n      return (data: D) => fn(data, ...(args as A));\r\n    }) as FlexFn<D, A, R>;\r\n  },\r\n\r\n  /**\r\n   * Element/selector-aware flex helper.\r\n   *\r\n   * Uses the same ElementInput predicate as `dataLastEl`, enabling flexible\r\n   * first/last positioning for element/selector inputs.\r\n   *\r\n   * @returns Flexible versions of the provided functions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on, modify } from '@doeixd/dom';\r\n   *\r\n   * const [onFlex, modifyFlex] = Fn.flexEl(on, modify);\r\n   *\r\n   * onFlex(button, 'click', handler);\r\n   * onFlex('click', handler, button);\r\n   * onFlex('click', handler)(button);\r\n   *\r\n   * modifyFlex(button, { text: 'Save' });\r\n   * modifyFlex({ text: 'Save' }, '#save');\r\n   * ```\r\n   */\r\n  flexEl: (() => {\r\n    const isElementInput = (value: unknown): value is ElementInput => {\r\n      if (value === null || value === undefined) return true;\r\n      if (typeof value === 'string') return true;\r\n      if (typeof value === 'function') return true;\r\n      return value instanceof Element;\r\n    };\r\n\r\n    const wrapper = (...fns: any[]) => fns.map(fn => Fn.flex(fn, isElementInput)) as any;\r\n\r\n    return wrapper as FlexElFn;\r\n  })(),\r\n\r\n  /**\r\n   * (C-Combinator) Swaps the arguments of a curried function.\r\n   * Transforms `fn(config)(target)` into `fn(target)(config)`.\r\n   * \r\n   * Essential for using config-first functions (like `cls.add`) in contexts \r\n   * like `Array.map` that provide the target first.\r\n   * \r\n   * @param fn - The curried function to swap.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, findAll, cls } from '@doeixd/dom';\r\n   * \r\n   * const buttons = findAll('button');\r\n   * const addActiveClass = Fn.swap(cls.add)('is-active');\r\n   * \r\n   * buttons.forEach(addActiveClass); // point-free style\r\n   * ```\r\n   */\r\n  swap: <A, B, R>(fn: (a: A) => (b: B) => R): (b: B) => (a: A) => R => (b) => (a) => fn(a)(b),\r\n\r\n  /**\r\n   * Flips the arguments of a non-curried binary function.\r\n   * Transforms `fn(a, b)` into `fn(b, a)`.\r\n   * \r\n   * @param fn - The binary function to flip.\r\n   */\r\n  flip: <A, B, R>(fn: (a: A, b: B) => R): (b: B, a: A) => R => (b, a) => fn(a, b),\r\n\r\n  /**\r\n   * (K-Combinator) Executes a side-effect function with a value, then returns the value.\r\n   * Essential for debugging (`console.log`) or executing void-returning functions\r\n   * inside a `pipe` chain without breaking it.\r\n   * \r\n   * @param fn - The side-effect function.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, modify, find } from '@doeixd/dom';\r\n   * \r\n   * const processEl = Fn.pipe(\r\n   *   modify({ text: 'Processed' }),\r\n   *   Fn.tap(el => console.log('Element after modify:', el)),\r\n   *   el => el.dataset.id\r\n   * );\r\n   * \r\n   * const id = processEl(find('#my-el'));\r\n   * ```\r\n   */\r\n  tap: <T>(fn: (x: T) => void) => (x: T): T => {\r\n    fn(x);\r\n    return x;\r\n  },\r\n\r\n  /**\r\n   * Creates a function that executes only if its input is not `null` or `undefined`.\r\n   * Safely wraps functions that would otherwise throw errors on nullish inputs.\r\n   * \r\n   * @param fn - The function to protect.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, find } from '@doeixd/dom';\r\n   * \r\n   * const el = find('.maybe-missing');\r\n   * const safeFocus = Fn.maybe(focus());\r\n   * \r\n   * safeFocus(el); // No crash if el is null\r\n   * ```\r\n   */\r\n  maybe: <T, R>(fn: (x: T) => R) => (x: T | null | undefined): R | null => {\r\n    return (x === null || x === undefined) ? null : fn(x);\r\n  },\r\n\r\n  /**\r\n   * (W-Combinator / Converge) Applies multiple functions to the same input,\r\n   * then passes their results to a final combining function.\r\n   * `converge(h, f, g)(x)` is equivalent to `h(f(x), g(x))`.\r\n   * \r\n   * @param h - The final function that accepts the results.\r\n   * @param fns - The functions to apply to the input.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, attr, prop } from '@doeixd/dom';\r\n   * \r\n   * const logData = (id, value) => console.log({ id, value });\r\n   * \r\n   * const logInputState = Fn.converge(\r\n   *   logData,\r\n   *   attr('data-id'),\r\n   *   prop('value')\r\n   * );\r\n   * \r\n   * logInputState(myInputElement); // Logs { id: '...', value: '...' }\r\n   * ```\r\n   */\r\n  converge: <T, O>(h: (...args: any[]) => O, ...fns: Array<(x: T) => any>) => (x: T): O => {\r\n    return h(...fns.map(f => f(x)));\r\n  },\r\n\r\n  /**\r\n   * Creates a function that executes one of two functions based on a predicate.\r\n   * \r\n   * @param predicate - A function that returns a boolean.\r\n   * @param ifTrue - The function to call if the predicate is true.\r\n   * @param ifFalse - The function to call if the predicate is false.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, cls } from '@doeixd/dom';\r\n   * \r\n   * const hasValue = (el: HTMLInputElement) => el.value.length > 0;\r\n   * \r\n   * const toggleValidClass = Fn.ifElse(\r\n   *   hasValue,\r\n   *   cls.add('is-valid'),\r\n   *   cls.remove('is-valid')\r\n   * );\r\n   * \r\n   * toggleValidClass(myInputElement);\r\n   * ```\r\n   */\r\n  ifElse: <T, R1, R2>(\r\n    predicate: (x: T) => boolean,\r\n    ifTrue: (x: T) => R1,\r\n    ifFalse: (x: T) => R2\r\n  ) => (x: T): R1 | R2 => predicate(x) ? ifTrue(x) : ifFalse(x),\r\n\r\n  /**\r\n   * \"Thunks\" a function, creating a nullary (zero-argument) function that\r\n   * calls the original with pre-filled arguments.\r\n   * \r\n   * Useful for event handlers that don't need the event object.\r\n   * \r\n   * @param fn - The function to thunk.\r\n   * @param args - The arguments to pre-fill.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, on } from '@doeixd/dom';\r\n   * \r\n   * const increment = (amount: number) => console.log(amount + 1);\r\n   * \r\n   * on(button)('click', Fn.thunk(increment, 5)); // Logs 6 on click\r\n   * ```\r\n   */\r\n  thunk: <A extends any[], R>(fn: (...args: A) => R, ...args: A): () => R => () => fn(...args),\r\n\r\n  /**\r\n   * (I-Combinator) Returns the value it was given.\r\n   * Useful as a default or placeholder in functional compositions.\r\n   */\r\n  identity: <T>(x: T): T => x,\r\n\r\n  /**\r\n   * A function that does nothing and returns nothing.\r\n   * Useful for providing a default no-op callback.\r\n   */\r\n  noop: () => { },\r\n\r\n  /**\r\n   * Converts an element-first function into an element-last (chainable) function.\r\n   * Perfect for use with `chain()` and functional pipelines.\r\n   *\r\n   * Takes a function `(element, ...args) => result` and converts it to\r\n   * `(...args) => (element) => element`, allowing it to be used in chains.\r\n   *\r\n   * @template T - The element type\r\n   * @template A - The argument types tuple\r\n   * @param fn - The element-first function to convert\r\n   * @returns A curried, chainable version that returns the element\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, chain, find } from '@doeixd/dom';\r\n   *\r\n   * // Original element-first function\r\n   * function setTextColor(el: HTMLElement, color: string) {\r\n   *   el.style.color = color;\r\n   * }\r\n   *\r\n   * // Convert to chainable\r\n   * const withTextColor = Fn.chainable(setTextColor);\r\n   *\r\n   * // Now use in chain!\r\n   * chain(\r\n   *   find('#app'),\r\n   *   withTextColor('red'),        // Returns (el) => el\r\n   *   withTextColor('blue'),       // Can chain multiple\r\n   *   cls.add('styled')            // Mix with other chainables\r\n   * );\r\n   *\r\n   * // Works with multiple arguments\r\n   * function setAttrs(el: HTMLElement, name: string, value: string) {\r\n   *   el.setAttribute(name, value);\r\n   * }\r\n   * const withAttr = Fn.chainable(setAttrs);\r\n   *\r\n   * chain(\r\n   *   element,\r\n   *   withAttr('data-id', '123'),\r\n   *   withAttr('aria-label', 'Button')\r\n   * );\r\n   *\r\n   * // Reusable transformers\r\n   * const makeButton = [\r\n   *   withTextColor('white'),\r\n   *   Fn.chainable((el: HTMLElement, size: string) => {\r\n   *     el.style.padding = size === 'large' ? '20px' : '10px';\r\n   *   })('large'),\r\n   *   cls.add('btn')\r\n   * ];\r\n   *\r\n   * findAll('button').forEach(btn => chain(btn, ...makeButton));\r\n   * ```\r\n   */\r\n  chainable: <T extends HTMLElement, A extends any[]>(\r\n    fn: (element: T, ...args: A) => any\r\n  ) => (...args: A) => (element: T): T => {\r\n    fn(element, ...args);\r\n    return element;\r\n  },\r\n\r\n  /**\r\n   * Like `chainable`, but preserves the function's return value instead of\r\n   * returning the element. Useful when you need the result of the operation.\r\n   *\r\n   * @template T - The element type\r\n   * @template A - The argument types tuple\r\n   * @template R - The return type\r\n   * @param fn - The element-first function to convert\r\n   * @returns A curried version that returns the function's result\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn } from '@doeixd/dom';\r\n   *\r\n   * // Function that returns a value\r\n   * function getComputedWidth(el: HTMLElement, includeMargin: boolean): number {\r\n   *   const styles = window.getComputedStyle(el);\r\n   *   const width = parseFloat(styles.width);\r\n   *   if (!includeMargin) return width;\r\n   *   const marginLeft = parseFloat(styles.marginLeft);\r\n   *   const marginRight = parseFloat(styles.marginRight);\r\n   *   return width + marginLeft + marginRight;\r\n   * }\r\n   *\r\n   * const getWidth = Fn.chainableWith(getComputedWidth);\r\n   *\r\n   * const element = find('#box');\r\n   * const totalWidth = getWidth(true)(element);  // Returns number\r\n   * console.log('Total width:', totalWidth);\r\n   *\r\n   * // Use in Fn.pipe when you need the value\r\n   * const processElement = Fn.pipe(\r\n   *   find('#container'),\r\n   *   getWidth(false),\r\n   *   width => console.log('Width:', width)\r\n   * );\r\n   * ```\r\n   */\r\n  chainableWith: <T extends HTMLElement, A extends any[], R>(\r\n    fn: (element: T, ...args: A) => R\r\n  ) => (...args: A) => (element: T): R => {\r\n    return fn(element, ...args);\r\n  },\r\n\r\n  /**\r\n   * Transforms an element-accepting function to also accept string selectors\r\n   * or functions that return elements. Preserves dual-mode API like def().\r\n   *\r\n   * Supports ParseSelector type inference for string literal selectors,\r\n   * enabling type-safe selector resolution with automatic element type inference.\r\n   *\r\n   * @template T - Element type\r\n   * @template A - Arguments tuple\r\n   * @template R - Return type\r\n   * @param fn - Original element-accepting function\r\n   * @param root - Root element for scoped searches (default: document)\r\n   * @returns Function that accepts ElementInput with dual-mode support\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * import { Fn, cls, css, modify, find } from '@doeixd/dom';\r\n   *\r\n   * // Transform existing functions\r\n   * const clsAdd = Fn.withSelector((el: HTMLElement | null, ...classes: string[]) => {\r\n   *   if (!el) return null;\r\n   *   cls.add(el)(...classes);\r\n   *   return el;\r\n   * });\r\n   *\r\n   * // Use with selectors (dual-mode)\r\n   * clsAdd('button', 'active', 'btn');           // Immediate: HTMLButtonElement | null\r\n   * clsAdd('button')('active', 'btn');           // Curried: HTMLButtonElement | null\r\n   * clsAdd('#app', 'container');                 // ID selector: HTMLElement | null\r\n   * clsAdd('svg')('icon');                       // SVG: SVGSVGElement | null\r\n   *\r\n   * // Use with function getters (lazy evaluation)\r\n   * clsAdd(() => find('.dynamic'))('highlight'); // Function: HTMLElement | null\r\n   *\r\n   * // Use with direct elements\r\n   * const button = find('button');\r\n   * clsAdd(button)('active');\r\n   *\r\n   * // Null-safe by design\r\n   * clsAdd(null)('active');         // Returns null, no error\r\n   * clsAdd('.missing')('active');   // Returns null if not found\r\n   *\r\n   * // Type inference preserved\r\n   * const btn = clsAdd('button')('active'); // Type: HTMLButtonElement | null\r\n   * const div = clsAdd('div')('card');      // Type: HTMLDivElement | null\r\n   *\r\n   * // Scoped to component\r\n   * const container = find('#container');\r\n   * const scopedAdd = Fn.withSelector(\r\n   *   (el: HTMLElement | null, ...classes: string[]) => {\r\n   *     if (!el) return null;\r\n   *     cls.add(el)(...classes);\r\n   *     return el;\r\n   *   },\r\n   *   container // Scoped root\r\n   * );\r\n   * scopedAdd('button')('btn'); // Searches within container only\r\n   *\r\n   * // Create reusable selector-enabled utilities\r\n   * const cssSelector = Fn.withSelector((el: HTMLElement | null, styles: Partial<CSSStyleDeclaration>) => {\r\n   *   if (!el) return null;\r\n   *   css(el)(styles);\r\n   *   return el;\r\n   * });\r\n   *\r\n   * cssSelector('.card', { padding: '20px' });\r\n   * cssSelector('.card')({ padding: '20px' });\r\n   * ```\r\n   */\r\n  withSelector: <T extends HTMLElement, A extends any[], R>(\r\n    fn: (element: T | null, ...args: A) => R,\r\n    root: ParentNode = document\r\n  ): SelectorFunction<T, A, R> => {\r\n    function wrapper<S extends string>(\r\n      input: ElementInput<S>,\r\n      ...args: any[]\r\n    ): any {\r\n      // Resolve input to element\r\n      let element: T | null = null;\r\n\r\n      if (input === null || input === undefined) {\r\n        element = null;\r\n      } else if (typeof input === 'string') {\r\n        element = root.querySelector(input) as unknown as T | null;\r\n      } else if (typeof input === 'function') {\r\n        element = input() as unknown as T | null;\r\n      } else {\r\n        element = input as unknown as T | null;\r\n      }\r\n\r\n      // Apply original function with dual-mode support\r\n      if (args.length > 0) {\r\n        // Immediate mode: all arguments provided\r\n        return fn(element, ...args as A);\r\n      } else {\r\n        // Curried mode: return function accepting remaining arguments\r\n        return (...lateArgs: A) => fn(element, ...lateArgs);\r\n      }\r\n    }\r\n\r\n    return wrapper as SelectorFunction<T, A, R>;\r\n  },\r\n};\r\n\r\n/**\r\n * Selector-enabled versions of common DOM utilities.\r\n *\r\n * These wrap the original functions with `Fn.withSelector` for convenience,\r\n * allowing you to pass string selectors, function getters, or direct elements.\r\n *\r\n * All functions support dual-mode API (immediate and curried) and preserve\r\n * type inference via ParseSelector.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { $sel, find } from '@doeixd/dom';\r\n *\r\n * // Add classes using selector\r\n * $sel.addClass('button', 'active', 'btn');\r\n * $sel.addClass('button')('active', 'btn'); // Curried\r\n *\r\n * // Apply CSS\r\n * $sel.css('.card', { padding: '20px' });\r\n * $sel.css('.card')({ padding: '20px' });\r\n *\r\n * // Modify elements\r\n * $sel.modify('#app', { text: 'Hello', disabled: false });\r\n *\r\n * // Attach events\r\n * $sel.on('button', 'click', (e) => console.log('Clicked!'));\r\n *\r\n * // Function getters for dynamic elements\r\n * $sel.focus(() => find('.modal input'))();\r\n *\r\n * // Type inference preserved\r\n * const btn = $sel.addClass('button')('active'); // HTMLButtonElement | null\r\n * const svg = $sel.css('svg')({ fill: 'red' });  // SVGSVGElement | null\r\n * ```\r\n */\r\nexport const $sel = {\r\n  /**\r\n   * Add classes using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  addClass: Fn.withSelector((el: Element | null, ...classes: string[]) => {\r\n    if (!el) return null;\r\n    cls.add(el, ...classes);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Remove classes using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  removeClass: Fn.withSelector((el: Element | null, ...classes: string[]) => {\r\n    if (!el) return null;\r\n    cls.remove(el, ...classes);\r\n    return el;\r\n  }),\r\n\r\n  /**\r\n   * Toggle class using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  toggleClass: Fn.withSelector((el: Element | null, className: string, force?: boolean) => {\r\n    if (!el) return null;\r\n    return cls.toggle(el)(className, force);\r\n  }),\r\n\r\n  /**\r\n   * Apply CSS styles using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  css: Fn.withSelector((el: HTMLElement | null, styles: Partial<CSSStyleDeclaration>) => {\r\n    if (!el) return null;\r\n    return css(el)(styles);\r\n  }),\r\n\r\n  /**\r\n   * Modify element properties using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  modify: Fn.withSelector(<T extends HTMLElement>(el: T | null, props: ElementProps) => {\r\n    if (!el) return null;\r\n    return modify(el)(props) as T | null;\r\n  }),\r\n\r\n  /**\r\n   * Attach event listener using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   * Returns unsubscribe function for cleanup.\r\n   */\r\n  on: Fn.withSelector(<K extends keyof HTMLElementEventMap>(\r\n    el: HTMLElement | null,\r\n    event: K,\r\n    handler: (e: HTMLElementEventMap[K]) => void,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): Unsubscribe => {\r\n    if (!el) return () => { };\r\n    return on(el)(event, handler, options);\r\n  }),\r\n\r\n  /**\r\n   * Focus element using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  focus: Fn.withSelector((el: HTMLElement | null, options?: FocusOptions) => {\r\n    if (!el) return null;\r\n    return focus(el)(options);\r\n  }),\r\n\r\n  /**\r\n   * Blur element using selector or element.\r\n   * Returns the element for chaining.\r\n   */\r\n  blur: Fn.withSelector((el: HTMLElement | null) => {\r\n    if (!el) return null;\r\n    return blur(el);\r\n  }),\r\n\r\n  /**\r\n   * Scroll element into view using selector or element.\r\n   * Supports dual-mode: immediate and curried.\r\n   */\r\n  scrollInto: Fn.withSelector((el: Element | null, options?: ScrollIntoViewOptions) => {\r\n    if (!el) return null;\r\n    return scrollInto(el)(options);\r\n  }),\r\n\r\n  /**\r\n   * Get element's bounding rect using selector or element.\r\n   */\r\n  rect: Fn.withSelector((el: Element | null): DOMRect | null => {\r\n    if (!el) return null;\r\n    return rect(el);\r\n  }),\r\n\r\n  /**\r\n   * Remove element from DOM using selector or element.\r\n   */\r\n  remove: Fn.withSelector((el: Element | null) => {\r\n    if (!el) return null;\r\n    return remove(el);\r\n  }),\r\n\r\n  /**\r\n   * Empty element (remove all children) using selector or element.\r\n   */\r\n  empty: Fn.withSelector((el: Element | null) => {\r\n    if (!el) return null;\r\n    return empty(el);\r\n  })\r\n};\r\n\r\n// =============================================================================\r\n// 37. ERROR HANDLING (RESULT & OPTION)\r\n// =============================================================================\r\n\r\n/**\r\n * Represents a successful computation.\r\n */\r\nexport type Ok<T> = { ok: true; val: T; err: null };\r\n\r\n/**\r\n * Represents a failed computation.\r\n */\r\nexport type Err<E> = { ok: false; val: null; err: E };\r\n\r\n/**\r\n * A Result type (inspired by Rust) that is either Ok or Err.\r\n * Forces you to check `.ok` before accessing the value.\r\n */\r\nexport type Result<T, E = Error> = Ok<T> | Err<E>;\r\n\r\nexport const Result = {\r\n  /** Creates a success result. */\r\n  ok: <T>(val: T): Ok<T> => ({ ok: true, val, err: null }),\r\n\r\n  /** Creates a failure result. */\r\n  err: <E>(err: E): Err<E> => ({ ok: false, val: null, err }),\r\n\r\n  /**\r\n   * Wraps a synchronous function that might throw.\r\n   * Returns a Result object instead of throwing.\r\n   * \r\n   * @example\r\n   * const res = Result.try(() => JSON.parse(badString));\r\n   * if (!res.ok) console.error(res.err);\r\n   */\r\n  try: <T>(fn: () => T): Result<T, Error> => {\r\n    try {\r\n      return Result.ok(fn());\r\n    } catch (e) {\r\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Wraps a Promise that might reject.\r\n   * Returns a Promise<Result>.\r\n   * \r\n   * @example\r\n   * const { ok, val, err } = await Result.async(() => fetch('/api'));\r\n   */\r\n  async: async <T>(fn: () => Promise<T>): Promise<Result<T, Error>> => {\r\n    try {\r\n      const val = await fn();\r\n      return Result.ok(val);\r\n    } catch (e) {\r\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Unwraps a Result. Returns value if Ok, throws if Err.\r\n   */\r\n  unwrap: <T, E>(res: Result<T, E>): T => {\r\n    if (res.ok) return res.val;\r\n    throw res.err;\r\n  },\r\n\r\n  /**\r\n   * Unwraps a Result with a fallback value.\r\n   */\r\n  unwrapOr: <T, E>(res: Result<T, E>, fallback: T): T => {\r\n    return res.ok ? res.val : fallback;\r\n  },\r\n\r\n  /**\r\n   * Maps the value if Ok, ignores if Err.\r\n   */\r\n  map: <T, U, E>(res: Result<T, E>, fn: (v: T) => U): Result<U, E> => {\r\n    return res.ok ? Result.ok(fn(res.val)) : res as unknown as Err<E>;\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 38. OPTION (NULLABLE HANDLING)\r\n// =============================================================================\r\n\r\n/**\r\n * Functional wrapper for nullable values.\r\n */\r\nexport const Option = {\r\n  /**\r\n   * Creates an Option from a nullable value.\r\n   */\r\n  from: <T>(val: T | null | undefined) => ({\r\n    val,\r\n    isSome: val !== null && val !== undefined,\r\n    isNone: val === null || val === undefined\r\n  }),\r\n\r\n  /**\r\n   * Returns the value or a fallback.\r\n   * @example Option.unwrapOr(input, 'default');\r\n   */\r\n  unwrapOr: <T>(val: T | null | undefined, fallback: T): T => {\r\n    return (val !== null && val !== undefined) ? val : fallback;\r\n  },\r\n\r\n  /**\r\n   * Maps the value if it exists, returns null otherwise.\r\n   * @example const len = Option.map(str, s => s.length);\r\n   */\r\n  map: <T, R>(val: T | null | undefined, fn: (v: T) => R): R | null => {\r\n    return (val !== null && val !== undefined) ? fn(val) : null;\r\n  },\r\n\r\n  /**\r\n   * Executes side-effect if value exists.\r\n   * @example Option.then(element, el => el.remove());\r\n   */\r\n  then: <T>(val: T | null | undefined, fn: (v: T) => void): void => {\r\n    if (val !== null && val !== undefined) fn(val);\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 39. REACTIVE BINDINGS (\"THE HARD WAY\" HELPERS)\r\n// =============================================================================\r\n\r\n/**\r\n * A Setter function that updates the DOM only if the value has changed.\r\n */\r\nexport type Setter<T> = (newValue: T) => void;\r\n\r\nexport const bind = {\r\n  /**\r\n   * Generic value binder with diffing.\r\n   * \r\n   * @example\r\n   * const setScore = bind.val(0, (n) => div.innerText = n);\r\n   */\r\n  val: <T>(initial: T, effect: (val: T) => void): Setter<T> => {\r\n    let current = initial;\r\n    return (next: T) => {\r\n      if (!Object.is(current, next)) {\r\n        current = next;\r\n        effect(next);\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds textContent.\r\n   * @example const setText = bind.text(h1); setText('Hello');\r\n   */\r\n  text: (el: HTMLElement | null): Setter<string> => {\r\n    let current: string | undefined;\r\n    return (text: string) => {\r\n      if (el && current !== text) {\r\n        current = text;\r\n        el.textContent = text;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds innerHTML.\r\n   */\r\n  html: (el: HTMLElement | null): Setter<string> => {\r\n    let current: string | undefined;\r\n    return (html: string) => {\r\n      if (el && current !== html) {\r\n        current = html;\r\n        el.innerHTML = html;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds an attribute.\r\n   * Supports optional currying: `attr(name, el)` or `attr(name)(el)`.\r\n   * \r\n   * @example\r\n   * const setId = bind.attr('id', div); \r\n   * setId(123);\r\n   */\r\n  attr: (name: string, el?: HTMLElement | null) => {\r\n    const createSetter = (target: HTMLElement | null): Setter<string | number | boolean | null> => {\r\n      let current: any;\r\n      return (val) => {\r\n        if (!target || current === val) return;\r\n        current = val;\r\n        if (val === null || val === false) target.removeAttribute(name);\r\n        else target.setAttribute(name, String(val));\r\n      };\r\n    };\r\n    // Handle optional currying\r\n    return el !== undefined ? createSetter(el) : createSetter;\r\n  },\r\n\r\n  /**\r\n   * Binds a class toggle.\r\n   * Supports optional currying.\r\n   * \r\n   * @example const toggleActive = bind.toggle('active', div);\r\n   */\r\n  toggle: (className: string, el?: HTMLElement | null) => {\r\n    const createSetter = (target: HTMLElement | null): Setter<boolean> => {\r\n      let current: boolean | undefined;\r\n      return (active) => {\r\n        if (!target || current === active) return;\r\n        current = active;\r\n        target.classList.toggle(className, active);\r\n      };\r\n    };\r\n    return el !== undefined ? createSetter(el) : createSetter;\r\n  },\r\n\r\n  /**\r\n   * Binds a list to a container.\r\n   * Replaces children only if array reference changes.\r\n   * \r\n   * @example \r\n   * const updateList = bind.list(ul, (user, i) => el('li')({ text: user.name })());\r\n   * updateList(users);\r\n   */\r\n  list: <T>(container: HTMLElement | null, renderItem: (item: T, index: number) => Node) => {\r\n    let currentData: T[] | undefined;\r\n\r\n    return (data: T[]) => {\r\n      if (!container) return;\r\n      if (data === currentData) return; // Ref check\r\n\r\n      currentData = data;\r\n\r\n      // Optimization: fast clear if empty\r\n      if (data.length === 0) {\r\n        if (container.firstChild) container.replaceChildren();\r\n        return;\r\n      }\r\n\r\n      const fragment = document.createDocumentFragment();\r\n      data.forEach((item, i) => fragment.appendChild(renderItem(item, i)));\r\n      container.replaceChildren(fragment);\r\n    };\r\n  },\r\n\r\n  /** \r\n * Binds to inline styles. \r\n * @example bind.style(el, 'width') // expects string like \"100px\"\r\n */\r\n  style: (el: HTMLElement | null, property: string) => {\r\n    let current: string | undefined;\r\n    return (value: string | number) => {\r\n      if (!el || current === value) return;\r\n      current = String(value);\r\n      el.style[property as any] = current;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds to CSS Variables.\r\n   * @example bind.cssVar(el, '--progress')\r\n   */\r\n  cssVar: (el: HTMLElement | null, varName: string) => {\r\n    let current: string | undefined;\r\n    return (value: string | number) => {\r\n      if (!el || current === value) return;\r\n      current = String(value);\r\n      el.style.setProperty(varName, current);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds to an element property.\r\n   * @example bind.prop('disabled')(button)\r\n   */\r\n  prop: <K extends keyof HTMLElement>(propName: K, el?: HTMLElement | null) => {\r\n    const createSetter = (target: HTMLElement | null): Setter<HTMLElement[K]> => {\r\n      let current: any;\r\n      return (value: HTMLElement[K]) => {\r\n        if (!target || current === value) return;\r\n        current = value;\r\n        target[propName] = value;\r\n      };\r\n    };\r\n    return el !== undefined ? createSetter(el) : createSetter;\r\n  },\r\n\r\n  /**\r\n   * Binds to multiple CSS classes with boolean toggles.\r\n   * @example bind.classes(el)({ active: true, disabled: false })\r\n   */\r\n  classes: (el: HTMLElement | null): Setter<Record<string, boolean>> => {\r\n    return (classMap: Record<string, boolean>) => {\r\n      if (!el) return;\r\n      Object.entries(classMap).forEach(([className, isActive]) => {\r\n        el.classList.toggle(className, isActive);\r\n      });\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds to form input value.\r\n   * @example const setValue = bind.value(input); setValue('hello');\r\n   */\r\n  value: (el: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null): Setter<string | number> => {\r\n    let current: string | undefined;\r\n    return (value: string | number) => {\r\n      if (!el) return;\r\n      const stringValue = String(value);\r\n      if (current !== stringValue) {\r\n        current = stringValue;\r\n        el.value = stringValue;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds to element visibility (display none/block).\r\n   * Preserves original display value when showing.\r\n   * @example const toggleVis = bind.show(el); toggleVis(false);\r\n   */\r\n  show: (el: HTMLElement | null): Setter<boolean> => {\r\n    if (!el) return () => {};\r\n    let originalDisplay: string | null = null;\r\n\r\n    return (visible: boolean) => {\r\n      if (visible) {\r\n        if (el.style.display === 'none') {\r\n          el.style.display = originalDisplay || '';\r\n        }\r\n      } else {\r\n        if (el.style.display !== 'none') {\r\n          originalDisplay = el.style.display || null;\r\n          el.style.display = 'none';\r\n        }\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Creates an enhanced binder with type-safe setters and batch updates.\r\n *\r\n * Integrates with the existing `bind` primitives to provide a declarative way\r\n * to bind data to DOM elements extracted via refs. Define a schema mapping\r\n * refs to setter functions, then update multiple refs with a single data object.\r\n *\r\n * **Features**:\r\n * - **Type-safe**: TypeScript infers data shape from schema\r\n * - **Batch updates**: Group multiple changes into single operation\r\n * - **Partial updates**: Only provide changed values\r\n * - **Null-safe**: Handles missing refs gracefully\r\n *\r\n * **Integration**: Uses existing `bind` primitives (text, value, prop, toggle, etc.)\r\n *\r\n * @template R - The refs shape\r\n * @param refsObj - Object containing refs to bind\r\n * @param schema - Optional schema defining how refs map to setters (defaults to text binding)\r\n * @returns Enhanced binder instance\r\n *\r\n * @example\r\n * ```typescript\r\n * import { createBinder, bind, viewRefs, h } from '@doeixd/dom';\r\n *\r\n * interface FormRefs {\r\n *   nameInput: HTMLInputElement;\r\n *   emailInput: HTMLInputElement;\r\n *   submitBtn: HTMLButtonElement;\r\n *   errorMsg: HTMLElement;\r\n * }\r\n *\r\n * const Form = viewRefs<FormRefs>(({ refs }) =>\r\n *   h.form({}, [\r\n *     h.input({ dataRef: 'nameInput', attr: { type: 'text' } }),\r\n *     h.input({ dataRef: 'emailInput', attr: { type: 'email' } }),\r\n *     h.button({ dataRef: 'submitBtn' }, ['Submit']),\r\n *     h.div({ dataRef: 'errorMsg', class: { error: true } })\r\n *   ])\r\n * );\r\n *\r\n * const { element, refs } = Form();\r\n *\r\n * // Create binder with schema using existing bind primitives\r\n * const ui = createBinder(refs, {\r\n *   nameInput: bind.value,\r\n *   emailInput: bind.value,\r\n *   submitBtn: bind.prop('disabled'),\r\n *   errorMsg: bind.text\r\n * });\r\n *\r\n * // Update multiple refs at once (type-safe!)\r\n * ui({\r\n *   nameInput: 'John Doe',\r\n *   emailInput: 'john@example.com',\r\n *   submitBtn: false\r\n * });\r\n *\r\n * // Batch updates for performance\r\n * ui.batch(() => {\r\n *   ui({ nameInput: '' });\r\n *   ui({ emailInput: '' });\r\n *   ui({ errorMsg: 'Please fill all fields' });\r\n * });\r\n *\r\n * // Access individual setters\r\n * ui.set.errorMsg('Invalid email format');\r\n *\r\n * // Partial updates\r\n * ui({ submitBtn: true }); // Only updates submit button\r\n * ```\r\n */\r\nexport function createBinder<R extends Record<string, HTMLElement>>(\r\n  refsObj: R,\r\n  schema?: Partial<BinderSchema<R>>\r\n): EnhancedBinder<R> {\r\n  // Build complete schema (default to text binding)\r\n  const completeSchema: BinderSchema<R> = {} as BinderSchema<R>;\r\n\r\n  for (const key in refsObj) {\r\n    if (schema && key in schema) {\r\n      // Use provided schema setter\r\n      completeSchema[key] = (schema[key] as any)(refsObj[key]);\r\n    } else {\r\n      // Default to text binding\r\n      completeSchema[key] = bind.text(refsObj[key]) as any;\r\n    }\r\n  }\r\n\r\n  // Batching state\r\n  let isBatching = false;\r\n  const pendingUpdates = new Map<keyof R, any>();\r\n\r\n  /**\r\n   * Flushes pending updates in batch mode.\r\n   */\r\n  const flush = (): void => {\r\n    if (!isBatching) {\r\n      pendingUpdates.forEach((value, key) => {\r\n        completeSchema[key](value);\r\n      });\r\n      pendingUpdates.clear();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Updates a single ref.\r\n   */\r\n  const updateRef = <K extends keyof R>(key: K, value: any): void => {\r\n    if (isBatching) {\r\n      pendingUpdates.set(key, value);\r\n    } else {\r\n      completeSchema[key](value);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Main binder function - updates multiple refs from data object.\r\n   */\r\n  const binderFn = (data: Partial<InferBinderData<BinderSchema<R>>>): void => {\r\n    Object.entries(data).forEach(([key, value]) => {\r\n      if (key in completeSchema) {\r\n        updateRef(key as keyof R, value);\r\n      }\r\n    });\r\n\r\n    if (!isBatching) {\r\n      flush();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Batch multiple updates into single operation.\r\n   */\r\n  binderFn.batch = (fn: () => void): void => {\r\n    const wasBatching = isBatching;\r\n    isBatching = true;\r\n\r\n    try {\r\n      fn();\r\n    } finally {\r\n      isBatching = wasBatching;\r\n      if (!wasBatching) {\r\n        flush();\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Individual setter functions.\r\n   */\r\n  binderFn.set = completeSchema;\r\n\r\n  /**\r\n   * Get current refs object.\r\n   */\r\n  binderFn.refs = (): R => refsObj;\r\n\r\n  return binderFn as EnhancedBinder<R>;\r\n}\r\n\r\n/**\r\n * Creates a lightweight, pure JavaScript observable store.\r\n * Unlike `store()`, this does NOT write to the DOM.\r\n */\r\nexport const createStore = <T extends Record<string, any>>(initialState: T) => {\r\n  let state = { ...initialState };\r\n  const listeners = new Set<(s: T) => void>();\r\n\r\n  return {\r\n    /** Get current state snapshot */\r\n    get: () => state,\r\n\r\n    /** Update state (partial updates merged) */\r\n    set: (update: Partial<T> | ((prev: T) => Partial<T>)) => {\r\n      const newVals = typeof update === 'function' ? update(state) : update;\r\n      state = { ...state, ...newVals };\r\n      listeners.forEach(fn => fn(state));\r\n    },\r\n\r\n    /** Subscribe to changes */\r\n    subscribe: (fn: (s: T) => void): Unsubscribe => {\r\n      listeners.add(fn);\r\n      fn(state); // Fire immediately\r\n      return () => listeners.delete(fn);\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 40. VIEW FACTORY & BINDER GENERATOR\r\n// =============================================================================\r\n/**\r\n * Attaches multiple event listeners to a set of DOM references in one go.\r\n * \r\n * Returns a single **Unsubscribe** function that cleans up all listeners created \r\n * by this call.\r\n * \r\n * **Features:**\r\n * - **Deep Typing:** Infers event types based on event names (e.g., 'click' -> `MouseEvent`).\r\n * - **Cleanup:** Returns a batch unsubscribe function to prevent memory leaks.\r\n * - **Target-First:** Supports `bindEvents(refs, map)` or `bindEvents(refs)(map)`.\r\n * \r\n * @template R - The Refs object type (Record of HTMLElements).\r\n * @template M - The Event Map definition.\r\n * \r\n * @param refs - The object containing DOM elements (usually from `createView()`).\r\n * @param map - A nested object mapping `RefKey -> EventName -> Handler`.\r\n * @returns A function that removes all attached listeners.\r\n * \r\n * @example\r\n * ```typescript\r\n * // 1. Immediate Usage\r\n * const cleanup = bindEvents(refs, {\r\n *   btn: { \r\n *     // 'e' is inferred as MouseEvent, 'el' as HTMLButtonElement\r\n *     click: (e, el) => console.log('Clicked', el) \r\n *   },\r\n *   input: { \r\n *     // 'e' is inferred as InputEvent\r\n *     input: (e) => updateState(e.target.value),\r\n *     keydown: (e) => handleEnter(e)\r\n *   }\r\n * });\r\n * \r\n * // Later: remove all listeners\r\n * cleanup();\r\n * \r\n * // 2. Curried Usage (useful for defining behavior separate from refs)\r\n * const attachListeners = bindEvents(refs);\r\n * \r\n * const cleanup = attachListeners({\r\n *   btn: { click: handleClick }\r\n * });\r\n * ```\r\n */\r\nexport function bindEvents<\r\n  R extends Record<string, HTMLElement>\r\n>(\r\n  refs: R\r\n): (map: EventSchema<R>) => Unsubscribe;\r\n\r\nexport function bindEvents<\r\n  R extends Record<string, HTMLElement>\r\n>(\r\n  refs: R,\r\n  map: EventSchema<R>\r\n): Unsubscribe;\r\n\r\nexport function bindEvents(refs: any, map?: any) {\r\n  const exec = (m: any): Unsubscribe => {\r\n    const unsubs: Unsubscribe[] = [];\r\n\r\n    Object.entries(m).forEach(([refKey, events]) => {\r\n      const el = refs[refKey];\r\n      if (!el) return;\r\n\r\n      Object.entries(events as Record<string, any>).forEach(([evtName, handler]) => {\r\n        // Uses fdom 'on' which returns an Unsubscribe\r\n        unsubs.push(\r\n          on(el)(evtName as any, (e) => handler(e, el))\r\n        );\r\n      });\r\n    });\r\n\r\n    // Return batch cleanup\r\n    return () => unsubs.forEach(fn => fn());\r\n  };\r\n\r\n  if (map !== undefined) {\r\n    return exec(map);\r\n  }\r\n\r\n  return (lateMap: any) => exec(lateMap);\r\n}\r\n\r\n/**\r\n * Helper type to map Refs to Event Handlers.\r\n * - Matches keys from Refs.\r\n * - Provides autocomplete for standard DOM events (click, input, etc).\r\n * - Allows custom events (strings).\r\n */\r\nexport type EventSchema<R extends Record<string, HTMLElement>> = {\r\n  [K in keyof R]?: {\r\n    // Standard Events\r\n    [E in keyof HTMLElementEventMap]?: (e: HTMLElementEventMap[E], el: R[K]) => void;\r\n  } & {\r\n    // Custom Events\r\n    [customEvent: string]: (e: any, el: R[K]) => void;\r\n  };\r\n};\r\n\r\n/**\r\n * Defines the shape of the Refs object returned by `view()`.\r\n * Use a generic to specify keys: `view<'title' | 'button'>`\r\n */\r\nexport type Refs<K extends string> = Record<K, HTMLElement>;\r\n\r\n/**\r\n * A factory for creating maintainable \"Hard Way\" views.\r\n * \r\n * @template K - The names of the data-ref attributes in the HTML.\r\n * @param htmlString - The HTML template string.\r\n */\r\nexport const view = <K extends string = string>(htmlString: string) => {\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = htmlString.trim();\r\n\r\n  /**\r\n   * Instantiates the view.\r\n   * @returns {{ root: HTMLElement | DocumentFragment, refs: Refs<K> }}\r\n   */\r\n  return () => {\r\n    const root = document.importNode(tpl.content, true);\r\n    const refs = {} as Refs<K>;\r\n\r\n    root.querySelectorAll('[data-ref]').forEach(el => {\r\n      const key = (el as HTMLElement).dataset.ref;\r\n      if (key) refs[key as K] = el as HTMLElement;\r\n    });\r\n\r\n    // Determine if we return a single root element or the fragment\r\n    const rootEl = (root.children.length === 1 ? root.firstElementChild : root) as HTMLElement | DocumentFragment;\r\n\r\n    return { root: rootEl, refs };\r\n  };\r\n};\r\n\r\n/**\r\n * Generates a strongly-typed object of UI updaters from a set of DOM references.\r\n * \r\n * This utility acts as a **Schema Definition** for your view. It maps specific DOM elements \r\n * (from `refs`) to specific behaviors (from `bind` primitives), returning an object of \r\n * setter functions ready to accept data.\r\n * \r\n * **Features:**\r\n * - **Type Safety:** Schema keys must exist in the provided `refs`.\r\n * - **Inference:** The returned setters preserve the input types of the binders (e.g., `bind.text` -> `string`).\r\n * - **Target-First:** Supports `binder(refs, schema)` or `binder(refs)(schema)`.\r\n * \r\n * @template R - The Refs object type (Record of HTMLElements).\r\n * @template S - The Schema type mapping ref keys to binder factories.\r\n * \r\n * @param refs - The object containing DOM elements (usually from `createView()`).\r\n * @param schema - A map defining how each ref should be bound (e.g., `{ title: bind.text }`).\r\n * @returns An object where keys match the schema and values are the bound setter functions.\r\n * \r\n * @example\r\n * ```typescript\r\n * // 1. Immediate Usage\r\n * const ui = binder(refs, {\r\n *   title: bind.text,                // (val: string) => void\r\n *   avatar: bind.attr('src'),        // (val: string | null) => void\r\n *   isAdmin: bind.toggle('admin')    // (val: boolean) => void\r\n * });\r\n * \r\n * ui.title('Welcome'); // Type-safe\r\n * \r\n * // 2. Curried Usage (useful for pipelines or delayed definition)\r\n * const bindToView = binder(refs);\r\n * \r\n * const ui = bindToView({\r\n *   title: bind.text\r\n * });\r\n * ```\r\n */\r\nexport function binder<\r\n  R extends Record<string, HTMLElement>\r\n>(\r\n  refs: R\r\n): <\r\n  S extends Partial<{ [K in keyof R]: (el: any) => (val: any) => void }>\r\n>(schema: S) => { [K in keyof S]: S[K] extends (el: any) => infer Fn ? Fn : never };\r\n\r\nexport function binder<\r\n  R extends Record<string, HTMLElement>,\r\n  S extends Partial<{ [K in keyof R]: (el: any) => (val: any) => void }>\r\n>(\r\n  refs: R,\r\n  schema: S\r\n): { [K in keyof S]: S[K] extends (el: any) => infer Fn ? Fn : never };\r\n\r\nexport function binder(refs: any, schema?: any) {\r\n  const exec = (s: any) => {\r\n    const binders: any = {};\r\n    for (const key in s) {\r\n      if (refs[key]) {\r\n        binders[key] = s[key](refs[key]);\r\n      }\r\n    }\r\n    return binders;\r\n  };\r\n\r\n  if (schema !== undefined) {\r\n    return exec(schema);\r\n  }\r\n\r\n  return (lateSchema: any) => exec(lateSchema);\r\n}\r\n\r\n/** \r\n * Helper type to constrain the setters object. \r\n */\r\ntype SetterMap = Record<string, (val: any) => void>;\r\n\r\n/** \r\n * Helper type to infer the data shape from the setters.\r\n * Converts { name: (s: string) => void } into { name?: string } \r\n */\r\ntype InferData<S extends SetterMap> = Partial<{\r\n  [K in keyof S]: Parameters<S[K]>[0]\r\n}>;\r\n\r\n/**\r\n * Connects a data object to a map of UI setter functions.\r\n * \r\n * This utility eliminates the boilerplate of manually calling updaters like \r\n * `if (data.name) ui.name(data.name)`. It iterates through the `data` object \r\n * and invokes the corresponding setter for each key found in the `setters` map.\r\n * \r\n * **Behaviors:**\r\n * - **Partial Updates:** Keys in `data` that are `undefined` are ignored, allowing for partial state updates.\r\n * - **Null Support:** Keys set to `null` are passed through (useful for clearing attributes or text).\r\n * - **Type Inference:** The input `data` shape is strictly inferred from the `setters` definition.\r\n * \r\n * **Usage Patterns:**\r\n * 1. **Immediate (`apply(ui, data)`):** Apply changes instantly. Useful for one-off updates.\r\n * 2. **Curried (`apply(ui)`):** Returns a reusable update function typed to accept your data. \r\n *    This is the recommended pattern for the component `update` return value.\r\n * \r\n * @template S - The shape of the Setters object (inferred automatically).\r\n * @param setters - The schema of updater functions (created via `binder()`).\r\n * @param data - The data object to apply. Keys missing from `setters` are safely ignored.\r\n * @returns \r\n * - If `data` is provided: `void` (updates run immediately).\r\n * - If `data` is omitted: A function `(data: T) => void` for future updates.\r\n * \r\n * @example\r\n * ```typescript\r\n * // 1. Define the UI Schema\r\n * const ui = binder(refs, {\r\n *   title: bind.text,                // (val: string) => void\r\n *   isVisible: bind.toggle('show')   // (val: boolean) => void\r\n * });\r\n * \r\n * // 2. Immediate Usage\r\n * apply(ui, { title: 'Hello', isVisible: true });\r\n * \r\n * // 3. Curried Usage (The \"Hard Way\" Component Pattern)\r\n * export default function init() {\r\n *   const { root, refs } = createView();\r\n *   const ui = binder(refs, { ... });\r\n * \r\n *   // Create a pre-bound update function\r\n *   // 'update' is now typed as: (data: { title?: string, isVisible?: boolean }) => void\r\n *   const update = apply(ui);\r\n * \r\n *   return (props) => {\r\n *     update(props);\r\n *     return root;\r\n *   };\r\n * }\r\n * ```\r\n */\r\nexport function apply<S extends SetterMap>(\r\n  setters: S\r\n): (data: InferData<S>) => void;\r\n\r\nexport function apply<S extends SetterMap>(\r\n  setters: S,\r\n  data: InferData<S>\r\n): void;\r\n\r\nexport function apply<S extends SetterMap>(\r\n  setters: S,\r\n  data?: InferData<S>\r\n) {\r\n  // Shared logic execution\r\n  const exec = (d: InferData<S>) => {\r\n    for (const key in d) {\r\n      const val = d[key];\r\n      // Check undefined to allow null values if the setter accepts them\r\n      if (val !== undefined) {\r\n        const setter = setters[key];\r\n        if (setter) setter(val);\r\n      }\r\n    }\r\n  };\r\n\r\n  // 1. Immediate execution\r\n  if (data !== undefined) {\r\n    return exec(data);\r\n  }\r\n\r\n  // 2. Partial application (Curried)\r\n  return (lateData: InferData<S>) => exec(lateData);\r\n}\r\n\r\n// =============================================================================\r\n// 40.5 ELEMENT TRANSFORMATION UTILITIES\r\n// =============================================================================\r\n\r\n/**\r\n * Applies multiple pre-configured element transformers to an element.\r\n *\r\n * This utility takes an element and applies a sequence of curried functions to it.\r\n * Each function should be a pre-configured transformer that expects an element\r\n * (like `cls.add('active')`, `css({...})`, `modify({...})`).\r\n *\r\n * Returns the element for further chaining.\r\n *\r\n * @template T - The element type\r\n * @param element - The target element (null-safe)\r\n * @param transforms - Pre-configured element transformers\r\n * @returns The element (or null if input was null)\r\n *\r\n * @example\r\n * ```typescript\r\n * import { chain, find, cls, css, modify, attr } from '@doeixd/dom';\r\n *\r\n * // Configure a button with multiple operations\r\n * const button = chain(\r\n *   find('#submit'),\r\n *   cls.add('btn', 'btn-primary'),\r\n *   css({ padding: '10px 20px', borderRadius: '4px' }),\r\n *   modify({ text: 'Submit', disabled: false }),\r\n *   attr.set('data-action', 'submit')\r\n * );\r\n *\r\n * // Reusable configuration\r\n * const cardStyle = [\r\n *   cls.add('card', 'shadow'),\r\n *   css({ margin: '10px', padding: '15px' })\r\n * ];\r\n *\r\n * const cards = findAll('.card-container > div');\r\n * cards.forEach(card => chain(card, ...cardStyle));\r\n *\r\n * // With Fn.pipe for element creation\r\n * const createButton = Fn.pipe(\r\n *   el('button'),\r\n *   btn => chain(btn,\r\n *     cls.add('btn'),\r\n *     css({ padding: '10px' }),\r\n *     modify({ text: 'Click me' })\r\n *   )\r\n * );\r\n * ```\r\n */\r\nexport function chain<T extends HTMLElement>(\r\n  element: T | null,\r\n  ...transforms: Array<(el: T) => any>\r\n): T | null {\r\n  if (!element) return null;\r\n  transforms.forEach(transform => transform(element));\r\n  return element;\r\n}\r\n\r\n/**\r\n * Executes multiple callback functions on an element.\r\n *\r\n * Similar to `chain`, but accepts direct callback functions instead of\r\n * pre-configured transformers. Each callback receives the element as its\r\n * first argument.\r\n *\r\n * This is more flexible for operations that need runtime values or complex logic.\r\n * Returns the element for further chaining.\r\n *\r\n * @template T - The element type\r\n * @param element - The target element (null-safe)\r\n * @param operations - Callback functions that receive the element\r\n * @returns The element (or null if input was null)\r\n *\r\n * @example\r\n * ```typescript\r\n * import { exec, find, cls, css, on } from '@doeixd/dom';\r\n *\r\n * // Execute multiple operations with runtime values\r\n * const isActive = true;\r\n * const theme = 'dark';\r\n *\r\n * exec(\r\n *   find('#app'),\r\n *   el => cls.add(el)('app-container'),\r\n *   el => cls.toggle(el)('is-active', isActive),\r\n *   el => cls.add(el)(`theme-${theme}`),\r\n *   el => css(el)({\r\n *     backgroundColor: theme === 'dark' ? '#333' : '#fff'\r\n *   }),\r\n *   el => on(el)('click', () => console.log('Clicked!', el)),\r\n *   el => console.log('Element configured:', el)\r\n * );\r\n *\r\n * // Conditional operations\r\n * const config = getUserConfig();\r\n * exec(\r\n *   element,\r\n *   el => config.showBorder && cls.add(el)('bordered'),\r\n *   el => config.animated && attr.set(el)('data-animated', 'true'),\r\n *   el => config.onInit?.(el)\r\n * );\r\n *\r\n * // Mix with other operations\r\n * const buttons = findAll('button');\r\n * buttons.forEach((btn, index) =>\r\n *   exec(\r\n *     btn,\r\n *     el => modify(el)({ text: `Button ${index + 1}` }),\r\n *     el => on(el)('click', () => handleClick(index)),\r\n *     el => el.dataset.index = String(index)\r\n *   )\r\n * );\r\n * ```\r\n */\r\nexport function exec<T extends HTMLElement>(\r\n  element: T | null,\r\n  ...operations: Array<(el: T) => any>\r\n): T | null {\r\n  if (!element) return null;\r\n  operations.forEach(operation => operation(element));\r\n  return element;\r\n}\r\n\r\n\r\n// =============================================================================\r\n// 41. HTTP FACTORY (TYPE-SAFE, FLEXIBLE, WITH DEFAULTS)\r\n// =============================================================================\r\n\r\n/**\r\n * HTTP request method type.\r\n */\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\r\n\r\n/**\r\n * HTTP response status code.\r\n */\r\nexport type HttpStatus = 200 | 201 | 204 | 400 | 401 | 403 | 404 | 405 | 409 | 422 | 429 | 500 | 502 | 503 | (number & {});\r\n\r\n/**\r\n * Flexible request init configuration.\r\n * Supports any standard Fetch API options plus custom extensions.\r\n * \r\n * @template T - Custom header type overrides\r\n */\r\nexport interface HttpRequestInit extends Omit<RequestInit, 'body'> {\r\n  /** Request body - auto-stringified if object */\r\n  body?: BodyInit | Record<string, any> | null;\r\n  /** Base URL to prepend (overrides Http defaults) */\r\n  baseURL?: string;\r\n  /** Query parameters to append */\r\n  params?: Record<string, string | number | boolean | null | undefined>;\r\n  /** Custom timeout in ms (0 = no timeout) */\r\n  timeout?: number;\r\n  /** Retry count on network failure (default: 0) */\r\n  retries?: number;\r\n  /** Delay between retries in ms (default: 1000) */\r\n  retryDelay?: number;\r\n  /** Transform response before returning */\r\n  transform?: (data: any) => any;\r\n  /** Enable abortable requests (returns promise + abort). */\r\n  abortable?: boolean;\r\n}\r\n\r\n/**\r\n * HTTP response wrapper with metadata.\r\n * \r\n * @template T - The response data type\r\n * \r\n * @example\r\n * ```typescript\r\n * const res: HttpResponse<User> = await http.get('/users/1')({});\r\n * if (res.ok) console.log(res.data); // User\r\n * else console.error(res.statusText, res.error);\r\n * ```\r\n */\r\nexport interface HttpResponse<T = any> {\r\n  /** True if status is 2xx */\r\n  ok: boolean;\r\n  /** HTTP status code */\r\n  status: HttpStatus;\r\n  /** Status text (e.g., \"OK\", \"Not Found\") */\r\n  statusText: string;\r\n  /** Response data (parsed JSON, text, blob, etc.) */\r\n  data: T | null;\r\n  /** Error object if request failed */\r\n  error: Error | null;\r\n  /** Raw Fetch Response object */\r\n  response: globalThis.Response;\r\n}\r\n\r\n/**\r\n * Optional interceptor hooks for HTTP clients.\r\n */\r\nexport interface HttpInterceptors {\r\n  /** Runs before request execution. */\r\n  request?: (init: HttpRequestInit) => HttpRequestInit | Promise<HttpRequestInit>;\r\n  /** Runs after response creation (for both ok and error responses). */\r\n  response?: <T = any>(res: HttpResponse<T>) => HttpResponse<T> | Promise<HttpResponse<T>>;\r\n  /** Runs when response is not ok or network failure occurs. */\r\n  error?: <T = any>(res: HttpResponse<T>) => HttpResponse<T> | Promise<HttpResponse<T>>;\r\n}\r\n\r\n/**\r\n * HTTP client configuration.\r\n * Defines defaults for all requests made by this client.\r\n * \r\n * @template H - Custom header keys type\r\n */\r\nexport interface HttpConfig<H extends string = string> {\r\n  /** Base URL for all requests (e.g., \"https://api.example.com\") */\r\n  baseURL?: string;\r\n  /** Default headers for all requests */\r\n  headers?: Record<H | string, string>;\r\n  /** Default timeout in ms (0 = no timeout) */\r\n  timeout?: number;\r\n  /** Retry policy for network failures */\r\n  retries?: number;\r\n  /** Delay between retries */\r\n  retryDelay?: number;\r\n  /** Request interceptor (runs before fetch). */\r\n  interceptRequest?: (init: HttpRequestInit) => HttpRequestInit | Promise<HttpRequestInit>;\r\n  /** Response interceptor (runs after fetch). */\r\n  interceptResponse?: <T = any>(res: HttpResponse<T>) => HttpResponse<T> | Promise<HttpResponse<T>>;\r\n  /** Interceptors grouped by lifecycle stage. */\r\n  interceptors?: HttpInterceptors;\r\n}\r\n\r\nexport type HttpAbortController<T = any> = {\r\n  promise: Promise<HttpResponse<T>>;\r\n  abort: () => void;\r\n};\r\n\r\nexport type HttpRequestResult<T = any> = Promise<HttpResponse<T>> | HttpAbortController<T>;\r\n\r\n\r\n/**\r\n * Merges two header objects with type safety.\r\n * @internal\r\n */\r\nconst _mergeHeaders = (\r\n  base: Record<string, string> | undefined,\r\n  override: Record<string, string> | undefined\r\n): Record<string, string> => {\r\n  return { ...base, ...override };\r\n};\r\n\r\n/**\r\n * Builds a full URL with optional base and params.\r\n * @internal\r\n */\r\nconst _buildUrl = (path: string, baseURL?: string, params?: Record<string, any>): string => {\r\n  let url = baseURL ? `${baseURL}${path}` : path;\r\n\r\n  if (params) {\r\n    const search = new URLSearchParams();\r\n    for (const [key, val] of Object.entries(params)) {\r\n      if (val !== null && val !== undefined) {\r\n        search.set(key, String(val));\r\n      }\r\n    }\r\n    const qs = search.toString();\r\n    if (qs) url += `${url.includes('?') ? '&' : '?'}${qs}`;\r\n  }\r\n\r\n  return url;\r\n};\r\n\r\n/**\r\n * Converts body to RequestInit.body format.\r\n * @internal\r\n */\r\nconst _encodeBody = (body: any): BodyInit | null => {\r\n  if (body === null || body === undefined) return null;\r\n  if (typeof body === 'string') return body;\r\n  if (body instanceof Blob) return body;\r\n  if (body instanceof FormData) return body;\r\n  if (body instanceof ArrayBuffer) return body;\r\n  // Object: serialize to JSON\r\n  return JSON.stringify(body);\r\n};\r\n\r\n/**\r\n * Parses response based on content-type.\r\n * @internal\r\n */\r\nconst _parseResponse = async (response: globalThis.Response, transform?: (data: any) => any): Promise<any> => {\r\n  const contentType = response.headers.get('content-type') || '';\r\n\r\n  let data: any;\r\n  if (contentType.includes('application/json')) {\r\n    try {\r\n      data = await response.json();\r\n    } catch {\r\n      data = await response.text();\r\n    }\r\n  } else if (contentType.includes('text')) {\r\n    data = await response.text();\r\n  } else if (contentType.includes('image') || contentType.includes('video') || contentType.includes('audio')) {\r\n    data = await response.blob();\r\n  } else {\r\n    data = await response.arrayBuffer();\r\n  }\r\n\r\n  return transform ? transform(data) : data;\r\n};\r\n\r\n/**\r\n * Executes a fetch request with retry logic.\r\n * @internal\r\n */\r\nconst _fetchWithRetry = async (\r\n  url: string,\r\n  init: RequestInit,\r\n  retries: number = 0,\r\n  retryDelay: number = 1000,\r\n  timeout: number = 0\r\n): Promise<globalThis.Response> => {\r\n  const controller = new AbortController();\r\n  const timeoutId = timeout > 0 ? setTimeout(() => controller.abort(), timeout) : undefined;\r\n\r\n  try {\r\n    return await fetch(url, { ...init, signal: controller.signal });\r\n  } catch (error) {\r\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\r\n\r\n    // Retry on network error (not on HTTP error like 404)\r\n    if (retries > 0 && (error instanceof TypeError || error instanceof DOMException)) {\r\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n      return _fetchWithRetry(url, init, retries - 1, retryDelay, timeout);\r\n    }\r\n\r\n    throw error;\r\n  } finally {\r\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a type-safe HTTP client with flexible configuration.\r\n * \r\n * Advanced HTTP factory with full control: configure defaults per client,\r\n * override per-request, automatic retries, timeouts, interceptors, and more.\r\n * \r\n * Features:\r\n * - Fully type-safe with generics for request/response\r\n * - Automatic JSON serialization/deserialization\r\n * - Query parameter support with smart merging\r\n * - Configurable defaults (baseURL, headers, timeout, retries)\r\n * - Request/response interceptors (async support)\r\n * - Timeout support with AbortController\r\n * - Automatic retry on network failure\r\n * - Content-type detection (JSON, text, blob, etc.)\r\n * - Returns typed response object with metadata + helper methods\r\n * \r\n * @template H - Custom header keys (e.g., 'Authorization', 'X-Custom')\r\n * @param config - HTTP client configuration\r\n * @returns A configured Http client factory with GET, POST, PUT, DELETE, PATCH methods\r\n * \r\n * @example\r\n * ```typescript\r\n * // ===== BASIC SETUP =====\r\n * const api = HttpFactory.create({\r\n *   baseURL: 'https://api.example.com',\r\n *   headers: { 'X-API-Key': 'secret' },\r\n *   timeout: 5000,\r\n *   retries: 2\r\n * });\r\n * \r\n * // ===== TYPE-SAFE REQUESTS =====\r\n * interface User { id: number; name: string }\r\n * interface CreateUserPayload { name: string; email: string }\r\n * \r\n * // GET with automatic type inference\r\n * const res = await api.get<User>('/users/123')({});\r\n * if (res.ok) console.log(res.data.id); // data is User\r\n * \r\n * // POST with body and query params\r\n * const created = await api.post<User>('/users')({\r\n *   body: { name: 'Alice', email: 'alice@example.com' },\r\n *   params: { notify: true },\r\n *   timeout: 3000\r\n * });\r\n * \r\n * // ===== PER-REQUEST OVERRIDES =====\r\n * // Override baseURL for specific request\r\n * await api.get('/status')({\r\n *   baseURL: 'https://status.example.com'\r\n * });\r\n * \r\n * // Override timeout for slow endpoint\r\n * await api.get<Data>('/expensive-operation')({\r\n *   timeout: 30000,\r\n *   retries: 3\r\n * });\r\n * \r\n * // ===== INTERCEPTORS (AUTH, LOGGING, ERROR HANDLING) =====\r\n * const api = HttpFactory.create({\r\n *   baseURL: 'https://api.example.com',\r\n *   interceptRequest: async (init) => {\r\n *     // Add auth token dynamically\r\n *     const token = await getAuthToken();\r\n *     return {\r\n *       ...init,\r\n *       headers: {\r\n *         ...init.headers,\r\n *         'Authorization': `Bearer ${token}`\r\n *       }\r\n *     };\r\n *   },\r\n *   interceptResponse: async (res) => {\r\n *     // Global error handling\r\n *     if (res.status === 401) {\r\n *       await refreshAuth();\r\n *       // Retry logic would go here\r\n *     }\r\n *     return res;\r\n *   }\r\n * });\r\n * \r\n * // ===== RESPONSE HELPERS =====\r\n * const res = await api.get<User[]>('/users')({});\r\n * \r\n * // Check success\r\n * if (api.isOk(res)) {\r\n *   console.log(res.data); // Narrowed to User[]\r\n * }\r\n * \r\n * // Unwrap or throw\r\n * const users = api.unwrap(res); // throws if not ok\r\n * \r\n * // Unwrap with fallback\r\n * const users = api.unwrapOr(res, []); // returns [] if error\r\n * \r\n * // ===== TRANSFORMATION =====\r\n * await api.get<string[]>('/tags')({\r\n *   transform: (data) => data.map((t: any) => t.name) // Transform JSON before returning\r\n * });\r\n * ```\r\n */\r\nexport const Http = {\r\n  /**\r\n   * Creates a configured HTTP client with defaults.\r\n   * \r\n   * Use this for applications that need centralized configuration, interceptors,\r\n   * or per-client defaults (baseURL, timeout, retries, custom headers).\r\n   * Supports grouped interceptors (`interceptors.request/response/error`) and\r\n   * per-request abort controls via `abortable: true`.\r\n\r\n   * \r\n   * For simple one-off requests, use the static methods: Http.get, Http.post, etc.\r\n   * \r\n   * @template H - Custom header keys type\r\n   * @param config - Client configuration\r\n   * @returns An Http client factory\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const api = Http.create({\r\n   *   baseURL: 'https://api.example.com',\r\n   *   headers: { 'X-API-Key': 'secret' },\r\n   *   timeout: 5000,\r\n   *   retries: 2,\r\n   *   interceptRequest: async (init) => {\r\n   *     const token = await getAuthToken();\r\n   *     return {\r\n   *       ...init,\r\n   *       headers: { ...init.headers, 'Authorization': `Bearer ${token}` }\r\n   *     };\r\n   *   }\r\n   * });\r\n   * \r\n   * const user = await api.get<User>('/users/123')({});\r\n   * ```\r\n   */\r\n  create: <H extends string = string>(config: HttpConfig<H> = {}) => {\r\n      const {\r\n        baseURL: defaultBaseURL,\r\n        headers: defaultHeaders,\r\n        timeout: defaultTimeout = 0,\r\n        retries: defaultRetries = 0,\r\n        retryDelay: defaultRetryDelay = 1000,\r\n        interceptRequest,\r\n        interceptResponse,\r\n        interceptors\r\n      } = config;\r\n\r\n\r\n      const applyRequestInterceptors = async (init: HttpRequestInit) => {\r\n        let nextInit = init;\r\n        if (interceptRequest) {\r\n          nextInit = await interceptRequest(nextInit);\r\n        }\r\n        if (interceptors?.request) {\r\n          nextInit = await interceptors.request(nextInit);\r\n        }\r\n        return nextInit;\r\n      };\r\n\r\n      const applyResponseInterceptors = async <T = any>(res: HttpResponse<T>) => {\r\n        let nextRes = interceptResponse ? await interceptResponse(res) : res;\r\n        if (interceptors?.response) {\r\n          nextRes = await interceptors.response(nextRes);\r\n        }\r\n        if (!nextRes.ok && interceptors?.error) {\r\n          nextRes = await interceptors.error(nextRes);\r\n        }\r\n        return nextRes;\r\n      };\r\n\r\n      /**\r\n       * Executes an HTTP request.\r\n       * @internal\r\n       */\r\n      const _request = async <T = any>(\r\n\r\n      method: HttpMethod,\r\n      path: string,\r\n      init: HttpRequestInit = {}\r\n    ): Promise<HttpResponse<T>> => {\r\n      const requestInit = await applyRequestInterceptors(init);\r\n      const {\r\n        body,\r\n        baseURL = defaultBaseURL,\r\n        params,\r\n        timeout = defaultTimeout,\r\n        retries = defaultRetries,\r\n        retryDelay = defaultRetryDelay,\r\n        transform,\r\n        abortable: _abortable,\r\n        ...restInit\r\n      } = requestInit;\r\n\r\n      // Merge headers (default + request-specific)\r\n      const headers = _mergeHeaders(\r\n        defaultHeaders as Record<string, string> | undefined,\r\n        restInit.headers as Record<string, string> | undefined\r\n      );\r\n\r\n      // Auto-set Content-Type for JSON bodies\r\n      if (body && typeof body === 'object' && !Array.isArray(body) && !(body instanceof FormData)) {\r\n        headers['Content-Type'] = 'application/json';\r\n      }\r\n\r\n      // Build fetch init\r\n      const fetchInit: RequestInit = {\r\n        ...restInit,\r\n        method,\r\n        headers\r\n      };\r\n\r\n      // Encode body\r\n      if (body !== undefined && body !== null) {\r\n        fetchInit.body = _encodeBody(body);\r\n      }\r\n\r\n      // Build full URL with params\r\n      const url = _buildUrl(path, baseURL, params);\r\n\r\n\r\n      // Execute fetch with retry logic\r\n      let response: globalThis.Response;\r\n      try {\r\n        response = await _fetchWithRetry(url, fetchInit, retries, retryDelay, timeout);\r\n      } catch (error) {\r\n        const httpRes: HttpResponse<T> = {\r\n          ok: false,\r\n          status: 0,\r\n          statusText: 'Network Error',\r\n          data: null,\r\n          error: error instanceof Error ? error : new Error(String(error)),\r\n          response: null as any\r\n        };\r\n        return applyResponseInterceptors(httpRes);\r\n      }\r\n\r\n\r\n      // Parse response data\r\n      let data: T | null = null;\r\n      try {\r\n        data = await _parseResponse(response, transform);\r\n      } catch (error) {\r\n        console.error('Failed to parse response:', error);\r\n      }\r\n\r\n      // Build response wrapper\r\n      const httpRes: HttpResponse<T> = {\r\n        ok: response.ok,\r\n        status: response.status as HttpStatus,\r\n        statusText: response.statusText,\r\n        data,\r\n        error: null,\r\n        response\r\n      };\r\n\r\n      // Run response interceptor\r\n      return applyResponseInterceptors(httpRes);\r\n    };\r\n\r\n    const requestWithAbort = <T = any>(\r\n      method: HttpMethod,\r\n      path: string,\r\n      init: HttpRequestInit = {}\r\n    ): HttpRequestResult<T> => {\r\n      const { abortable, ...restInit } = init;\r\n      if (abortable) {\r\n        const controller = new AbortController();\r\n        const signal = restInit.signal ?? controller.signal;\r\n        const promise = _request<T>(method, path, { ...restInit, signal });\r\n        return {\r\n          promise,\r\n          abort: () => controller.abort()\r\n        };\r\n      }\r\n\r\n      return _request<T>(method, path, restInit);\r\n    };\r\n\r\n    return {\r\n      /**\r\n       * Performs a GET request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path (e.g., '/users/123')\r\n       * @returns A curried function that accepts request config\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.get<User>('/users/123')({});\r\n       *\r\n       * const { promise, abort } = http.get<User>('/users/123')({ abortable: true });\r\n       * abort();\r\n       * ```\r\n       */\r\n      get: <T = any>(path: string) => (init: HttpRequestInit = {}) => requestWithAbort<T>('GET', path, init),\r\n\r\n      /**\r\n       * Performs a POST request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.post<Created>('/users')({\r\n       *   body: { name: 'John' }\r\n       * });\r\n       * ```\r\n       */\r\n      post: <T = any>(path: string) => (init: HttpRequestInit = {}) => requestWithAbort<T>('POST', path, init),\r\n\r\n      /**\r\n       * Performs a PUT request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       */\r\n      put: <T = any>(path: string) => (init: HttpRequestInit = {}) => requestWithAbort<T>('PUT', path, init),\r\n\r\n      /**\r\n       * Performs a DELETE request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config\r\n       */\r\n      delete: <T = any>(path: string) => (init: HttpRequestInit = {}) => requestWithAbort<T>('DELETE', path, init),\r\n\r\n      /**\r\n       * Performs a PATCH request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       */\r\n      patch: <T = any>(path: string) => (init: HttpRequestInit = {}) => requestWithAbort<T>('PATCH', path, init),\r\n\r\n      /**\r\n       * Checks if an HTTP response is successful (2xx).\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.get('/users')({});\r\n       * if (http.isOk(res)) {\r\n       *   // res.data is guaranteed to be of the generic type\r\n       * }\r\n       * ```\r\n       */\r\n      isOk: <T = any>(res: HttpResponse<T>): res is HttpResponse<T> & { data: T } => res.ok,\r\n\r\n      /**\r\n       * Unwraps response data or throws on error.\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const users = http.unwrap(await http.get<User[]>('/users')({}));\r\n       * ```\r\n       */\r\n      unwrap: <T = any>(res: HttpResponse<T>): T => {\r\n        if (!res.ok) throw res.error || new Error(`HTTP ${res.status}: ${res.statusText}`);\r\n        return res.data as T;\r\n      },\r\n\r\n      /**\r\n       * Unwraps response data or returns fallback on error.\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const users = http.unwrapOr(\r\n       *   await http.get<User[]>('/users')({}),\r\n       *   []\r\n       * );\r\n       * ```\r\n       */\r\n      unwrapOr: <T = any>(res: HttpResponse<T>, fallback: T): T => {\r\n        return res.ok ? (res.data as T) : fallback;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Performs a simple GET request without client configuration.\r\n   * \r\n   * Throws an error if the response is not ok (non-2xx status).\r\n   * \r\n   * **Error Handling**: Error message includes status code and text.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to fetch from\r\n   * @param headers - Optional request headers\r\n   * @returns Promise resolving to parsed JSON response\r\n   * @throws Error if response is not ok\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic GET\r\n   * const users = await Http.get<User[]>('/api/users');\r\n   * \r\n   * // With custom headers\r\n   * const data = await Http.get<Data>('/api/data', {\r\n   *   'Authorization': 'Bearer token',\r\n   *   'Accept-Language': 'en-US'\r\n   * });\r\n   * \r\n   * // Error handling\r\n   * try {\r\n   *   const user = await Http.get<User>('/api/user/999');\r\n   * } catch (error) {\r\n   *   // Error message: \"Http.get 404: Not Found\"\r\n   *   console.error(error);\r\n   * }\r\n   * ```\r\n   */\r\n  get: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, { headers });\r\n    if (!res.ok) throw new Error(`Http.get ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple POST request without client configuration.\r\n   * \r\n   * **Curried API**: url -> body -> headers for composition and reusability.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to post to\r\n   * @returns A curried function accepting body then headers\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic POST\r\n   * const user = await Http.post('/api/users')\r\n   *   ({ name: 'John', email: 'john@example.com' })\r\n   *   ();\r\n   * \r\n   * // With auth headers\r\n   * const response = await Http.post('/api/login')\r\n   *   ({ username: 'admin', password: 'secret' })\r\n   *   ({ 'X-CSRF-Token': csrfToken });\r\n   * \r\n   * // Partial application\r\n   * const createUser = Http.post('/api/users');\r\n   * const user1 = await createUser({ name: 'Alice' })();\r\n   * const user2 = await createUser({ name: 'Bob' })();\r\n   * ```\r\n   */\r\n  post: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json', ...headers },\r\n      body: JSON.stringify(body)\r\n    });\r\n    if (!res.ok) throw new Error(`Http.post ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple PUT request without client configuration.\r\n   * \r\n   * **Curried API**: url -> body -> headers for composition and reusability.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to put to\r\n   * @returns A curried function accepting body then headers\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Update resource\r\n   * const updated = await Http.put('/api/users/123')\r\n   *   ({ name: 'John Updated', email: 'new@example.com' })\r\n   *   ({ 'Authorization': `Bearer ${token}` });\r\n   * \r\n   * // Partial application\r\n   * const updateUser = (id: number) => Http.put(`/api/users/${id}`);\r\n   * await updateUser(123)({ name: 'Alice' })();\r\n   * ```\r\n   */\r\n  put: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, {\r\n      method: 'PUT',\r\n      headers: { 'Content-Type': 'application/json', ...headers },\r\n      body: JSON.stringify(body)\r\n    });\r\n    if (!res.ok) throw new Error(`Http.put ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple DELETE request without client configuration.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type (often void or { success: boolean })\r\n   * @param url - The URL to delete\r\n   * @param headers - Optional request headers\r\n   * @returns Promise resolving to parsed JSON response\r\n   * @throws Error if response is not ok\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Delete resource\r\n   * await Http.delete('/api/users/123', {\r\n   *   'Authorization': `Bearer ${token}`\r\n   * });\r\n   * \r\n   * // With confirmation\r\n   * const result = await Http.delete<{ success: boolean }>(\r\n   *   '/api/posts/456',\r\n   *   { 'Authorization': `Bearer ${token}` }\r\n   * );\r\n   * if (result.success) {\r\n   *   remove(postElement);\r\n   * }\r\n   * ```\r\n   */\r\n  delete: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, { method: 'DELETE', headers });\r\n    if (!res.ok) throw new Error(`Http.delete ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  }\r\n};\r\n\r\n/**\r\n * Narrows an element to a more specific type using a CSS selector.\r\n *\r\n * Usage:\r\n *   const input = cast(\"input[type=email]\")(el);\r\n *\r\n * Returns:\r\n *   - el (narrowed) if it matches\r\n *   - null otherwise\r\n */\r\nexport function cast<S extends string>(selector: S) {\r\n  return <T extends Element>(el: T | null): ParseSelector<S> | null => {\r\n    if (!el) return null;\r\n    return el.matches(selector)\r\n      ? (el as unknown as ParseSelector<S>)\r\n      : null;\r\n  };\r\n}\r\n\r\n/**\r\n * Type guard: checks if a node is an Element.\r\n */\r\nexport function isElement(node: Node | null): node is Element {\r\n  return node instanceof Element;\r\n}\r\n\r\n/**\r\n * Type guard: narrows an element to a specific tag type based on tag name.\r\n *\r\n * Example:\r\n *   nodes.filter(isTag(\"button\")) // HTMLButtonElement[]\r\n */\r\nexport function isTag<K extends keyof HTMLElementTagNameMap>(tag: K) {\r\n  return (el: Element | null): el is HTMLElementTagNameMap[K] => {\r\n    return !!el && el.tagName.toLowerCase() === tag.toLowerCase();\r\n  };\r\n}\r\n\r\n/**\r\n * Checks whether an element is visible within the viewport or a custom scroll root.\r\n *\r\n * **Usage styles:**\r\n *\r\n * **1. Element-first**\r\n * ```ts\r\n * const visible = isInViewport(myDiv);\r\n * ```\r\n *\r\n * **2. Selector-first**\r\n * ```ts\r\n * const visible = isInViewport(\".item\");\r\n * ```\r\n *\r\n * **3. Curried**\r\n * ```ts\r\n * const check = isInViewport(\".item\");\r\n * const visible = check({ partial: true });\r\n * ```\r\n *\r\n * **4. Fully-Curried (element first, options later)**\r\n * ```ts\r\n * const withOptions = isInViewport(myDiv);\r\n * const visible = withOptions({ threshold: 0.5 });\r\n * ```\r\n *\r\n * ---\r\n *\r\n * **Visibility semantics**\r\n *\r\n * The function defaults to **full visibility**, meaning the element must be\r\n * entirely inside the bounding box of the viewport (or of `root`, if provided).\r\n *  \r\n * Use options to relax or refine the check:\r\n *\r\n * - `partial?: boolean` â€” true if **any part** intersects the root.\r\n * - `threshold?: number` â€” percentage of the element that must be visible (0â€“1).\r\n *   Overrides `partial`/`full` semantics.\r\n * - `margin?: number | { top?: number; right?: number; bottom?: number; left?: number }`\r\n *   â€” expands or contracts the root bounds.\r\n * - `root?: Element | Document` â€” custom scroll container; defaults to viewport.\r\n *\r\n * ---\r\n *\r\n * **Selector behavior**\r\n *\r\n * When passed a string selector, the function queries the element from\r\n * `document`. If the selector does not match anything, the function returns\r\n * `false`.\r\n *\r\n * ---\r\n *\r\n * **Examples**\r\n *\r\n * **Check if fully visible**\r\n * ```ts\r\n * isInViewport(myDiv); // true or false\r\n * ```\r\n *\r\n * **Check if partially visible**\r\n * ```ts\r\n * isInViewport(myDiv, { partial: true });\r\n * ```\r\n *\r\n * **Require at least 60% visibility**\r\n * ```ts\r\n * isInViewport(myDiv, { threshold: 0.6 });\r\n * ```\r\n *\r\n * **Use margin to treat near-visibility as visible**\r\n * ```ts\r\n * isInViewport(myDiv, { margin: 50 });\r\n * ```\r\n *\r\n * **Use another scroll root**\r\n * ```ts\r\n * const scroller = document.querySelector(\".scroll-area\")!;\r\n * isInViewport(myDiv, { root: scroller });\r\n * ```\r\n *\r\n * @template S - CSS selector literal used to type-narrow elements when\r\n *               calling with a selector string.\r\n */\r\nexport function isInViewport<S extends string>(\r\n  elOrSelector?: Element | null | S\r\n):\r\n  | boolean\r\n  | ((\r\n    options?: {\r\n      /**\r\n       * Allow partial visibility.  \r\n       * default: false (element must be fully inside)\r\n       */\r\n      partial?: boolean;\r\n\r\n      /**\r\n       * Percentage of element that must be visible (0â€“1).  \r\n       * Overrides `partial`. default: 1 (fully visible)\r\n       */\r\n      threshold?: number;\r\n\r\n      /**\r\n       * Custom viewport root (e.g., a scroll container).\r\n       * default: window viewport\r\n       */\r\n      root?: Element | null;\r\n\r\n      /**\r\n       * Margin (CSS margin syntax: \"10px\", \"10px 20px\", etc.)\r\n       * Expands or contracts the effective viewport.\r\n       */\r\n      margin?: string;\r\n    }\r\n  ) => boolean) {\r\n  // --- Selector-first mode ---\r\n  if (typeof elOrSelector === \"string\") {\r\n    const el = document.querySelector(elOrSelector);\r\n    if (!el) return false;\r\n    return inViewport(el, {});\r\n  }\r\n\r\n  // --- Element-first or null-safe curried ---\r\n  const el = elOrSelector ?? null;\r\n\r\n  return (options?: {\r\n    partial?: boolean;\r\n    threshold?: number;\r\n    root?: Element | null;\r\n    margin?: string;\r\n  }): boolean => {\r\n    if (!el) return false;\r\n    return inViewport(el, options ?? {});\r\n  };\r\n}\r\n\r\n/**\r\n * Internal utility performing the actual visibility check.\r\n */\r\nfunction inViewport(\r\n  el: Element,\r\n  {\r\n    partial = false,\r\n    threshold,\r\n    root = null,\r\n    margin\r\n  }: {\r\n    partial?: boolean;\r\n    threshold?: number;\r\n    root?: Element | null;\r\n    margin?: string;\r\n  }\r\n): boolean {\r\n  const rect = el.getBoundingClientRect();\r\n\r\n  // Parse margin offsets\r\n  const margins = parseMargin(margin);\r\n\r\n  // Viewport or custom root bounds\r\n  const containerRect = root\r\n    ? root.getBoundingClientRect()\r\n    : {\r\n      top: 0,\r\n      left: 0,\r\n      right: window.innerWidth,\r\n      bottom: window.innerHeight\r\n    };\r\n\r\n  // Apply margin adjustments\r\n  const vp = {\r\n    top: containerRect.top + margins.top,\r\n    left: containerRect.left + margins.left,\r\n    right: containerRect.right - margins.right,\r\n    bottom: containerRect.bottom - margins.bottom\r\n  };\r\n\r\n  const elementArea = rect.width * rect.height;\r\n  if (elementArea === 0) return false;\r\n\r\n  const intersection = {\r\n    top: Math.max(rect.top, vp.top),\r\n    left: Math.max(rect.left, vp.left),\r\n    right: Math.min(rect.right, vp.right),\r\n    bottom: Math.min(rect.bottom, vp.bottom)\r\n  };\r\n\r\n  const intersectWidth = intersection.right - intersection.left;\r\n  const intersectHeight = intersection.bottom - intersection.top;\r\n\r\n  if (intersectWidth <= 0 || intersectHeight <= 0) return false;\r\n\r\n  const visibleArea = intersectWidth * intersectHeight;\r\n\r\n  // Threshold overrides all other options\r\n  if (typeof threshold === \"number\") {\r\n    return visibleArea / elementArea >= threshold;\r\n  }\r\n\r\n  // Full visibility (default)\r\n  if (!partial) {\r\n    return (\r\n      rect.top >= vp.top &&\r\n      rect.left >= vp.left &&\r\n      rect.right <= vp.right &&\r\n      rect.bottom <= vp.bottom\r\n    );\r\n  }\r\n\r\n  // Partial visibility\r\n  return visibleArea > 0;\r\n}\r\n\r\n/**\r\n * Parses CSS-like margin strings (\"10px 20px\").\r\n */\r\nfunction parseMargin(input?: string) {\r\n  if (!input) return { top: 0, left: 0, right: 0, bottom: 0 };\r\n\r\n  const parts = input.split(/\\s+/).map(p => parseInt(p, 10) || 0);\r\n\r\n  switch (parts.length) {\r\n    case 1:\r\n      return { top: parts[0], right: parts[0], bottom: parts[0], left: parts[0] };\r\n    case 2:\r\n      return { top: parts[0], right: parts[1], bottom: parts[0], left: parts[1] };\r\n    case 3:\r\n      return { top: parts[0], right: parts[1], bottom: parts[2], left: parts[1] };\r\n    case 4:\r\n    default:\r\n      return {\r\n        top: parts[0],\r\n        right: parts[1],\r\n        bottom: parts[2],\r\n        left: parts[3]\r\n      };\r\n  }\r\n}\r\n\r\n/* --------------------------------------------------------\r\n * Animation Helpers\r\n * -------------------------------------------------------- */\r\n/**\r\n * Animate an element using Web Animations API.\r\n *\r\n * Supports:\r\n * - Selector or element input\r\n * - Curried: animate(el)(keyframes, options)\r\n *\r\n * @example\r\n * ```ts\r\n * await animate(\".box\", { opacity: [0,1] }, { duration: 300 });\r\n * await animate(document.querySelector(\".box\"))({ transform: [\"scale(0)\",\"scale(1)\"] }, { duration: 500 });\r\n * ```\r\n */\r\nexport function animate(elOrSelector?: Element | string | null) {\r\n  if (typeof elOrSelector === \"string\") {\r\n    const el = document.querySelector(elOrSelector);\r\n    return (keyframes: Keyframe[], options?: KeyframeAnimationOptions) => el ? el.animate(keyframes, options).finished : Promise.resolve();\r\n  }\r\n  const el = elOrSelector ?? null;\r\n  return (keyframes: Keyframe[], options?: KeyframeAnimationOptions) => el ? el.animate(keyframes, options).finished : Promise.resolve();\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Sanitizes HTML by removing dangerous tags and attributes to prevent XSS.\r\n * \r\n * **Safety Features**:\r\n * - Removes `<script>`, `<iframe>`, `<object>`, `<embed>` tags.\r\n * - Removes all `on*` attributes (inline event handlers like `onclick`).\r\n * - Removes `javascript:` URIs in `href` and `src` attributes.\r\n * \r\n * **SECURITY WARNING**: While significantly safer than a raw innerHTML, this function \r\n * is lightweight and may not catch every sophisticated XSS vector. \r\n * For high-risk inputs (e.g., public comments, rich text from untrusted users), \r\n * use a dedicated library like DOMPurify.\r\n * \r\n * @template T - The return type (defaults to string, can be cast to TrustedHTML etc.)\r\n * @param html - The HTML string to sanitize\r\n * @returns The sanitized HTML string\r\n * \r\n * @example\r\n * ```typescript\r\n * // Removes scripts and handlers\r\n * const safe = sanitizeHTMLSimple('<div onclick=\"alert(1)\">Hello</div><script>...</script>');\r\n * // Result: \"<div>Hello</div>\"\r\n * \r\n * // Removes dangerous protocols\r\n * const safeLink = sanitizeHTMLSimple('<a href=\"javascript:alert(1)\">Link</a>');\r\n * // Result: \"<a>Link</a>\"\r\n * ```\r\n */\r\nexport function sanitizeHTMLSimple<T = string>(html: string): T {\r\n  const template = document.createElement('template');\r\n  template.innerHTML = html;\r\n\r\n  const dangerousTags = ['script', 'iframe', 'object', 'embed'];\r\n\r\n  // 1. Remove dangerous tags\r\n  template.content.querySelectorAll(dangerousTags.join(',')).forEach(node => node.remove());\r\n\r\n  // 2. Sanitize attributes on all remaining elements\r\n  template.content.querySelectorAll('*').forEach(el => {\r\n    const attrs = el.getAttributeNames();\r\n    for (const attr of attrs) {\r\n      // Remove event handlers\r\n      if (attr.startsWith('on')) {\r\n        el.removeAttribute(attr);\r\n      }\r\n      // Remove javascript: protocol\r\n      else if (attr === 'href' || attr === 'src') {\r\n        const value = el.getAttribute(attr) || '';\r\n        if (value.toLowerCase().trim().startsWith('javascript:')) {\r\n          el.removeAttribute(attr);\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return template.innerHTML as unknown as T;\r\n}\r\n\r\n/**\r\n * Extracts text content from an HTML string, removing all tags.\r\n * \r\n * Useful for:\r\n * - Generating plain text previews\r\n * - SEO descriptions\r\n * - Accessibility labels\r\n * - Safe text display\r\n * \r\n * @template T - The return type (defaults to string)\r\n * @param html - The HTML string to parse\r\n * @returns The plain text content\r\n * \r\n * @example\r\n * ```typescript\r\n * const text = sanitizeHTMLTextOnly('<h1>Hello <b>World</b></h1>');\r\n * // Result: \"Hello World\"\r\n * \r\n * // Handles entities\r\n * const decoded = sanitizeHTMLTextOnly('Fish &amp; Chips');\r\n * // Result: \"Fish & Chips\"\r\n * ```\r\n */\r\nexport function sanitizeHTMLTextOnly<T = string>(html: string): T {\r\n  const template = document.createElement('template');\r\n  template.innerHTML = html;\r\n  return (template.content.textContent || '') as unknown as T;\r\n}\r\n\r\n\r\n// =============================================================================\r\n// 42. COMPONENT ARCHITECTURE (Release Candidate)\r\n// =============================================================================\r\n\r\n/**\r\n * Context object passed to the component setup function.\r\n * Provides a scoped, auto-cleaning sandbox for the component's logic.\r\n */\r\nexport interface ComponentContext<\r\n  Refs extends Record<string, HTMLElement> = any,\r\n  Groups extends Record<string, HTMLElement[]> = any,\r\n  State extends Record<string, any> = Record<string, any>\r\n> {\r\n  /** The root element of the component */\r\n  root: HTMLElement;\r\n\r\n  /** \r\n   * Map of single elements with `data-ref` attributes.\r\n   * Scoped to this component instance.\r\n   */\r\n  refs: Refs;\r\n\r\n  /** \r\n   * Map of element arrays with `data-ref` attributes.\r\n   * Useful for lists (e.g. `groups.items.forEach(...)`).\r\n   */\r\n  groups: Groups;\r\n\r\n  /**\r\n   * Reactive Proxy for the root element's dataset.\r\n   * - Reading `state.foo` reads `data-foo` from the DOM.\r\n   * - Writing `state.foo = x` updates `data-foo` and triggers watchers.\r\n   */\r\n  state: State;\r\n\r\n  /**\r\n   * Creates a lightweight, reactive store for component-local state.\r\n   * Unlike `state`, this does NOT sync with DOM attributes - it's pure JS.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const userStore = ctx.store({ name: '', email: '' });\r\n   *\r\n   * // Subscribe to changes\r\n   * userStore.subscribe((state) => console.log('User:', state));\r\n   *\r\n   * // Update state\r\n   * userStore.set({ name: 'Alice' });\r\n   *\r\n   * // Get current state\r\n   * console.log(userStore.get());\r\n   * ```\r\n   */\r\n  store: typeof createStore;\r\n\r\n  /**\r\n   * Scoped element finder (querySelector within root).\r\n   */\r\n  find: (selector: string) => HTMLElement | null;\r\n\r\n  /**\r\n   * Scoped element finder (querySelectorAll within root).\r\n   */\r\n  findAll: (selector: string) => HTMLElement[];\r\n\r\n  /**\r\n   * Generates a strongly-typed object of UI updaters based on the component's Refs.\r\n   * @see binder\r\n   */\r\n  binder: <S extends Partial<{ [K in keyof Refs]: (el: any) => (val: any) => void }>>(schema: S) =>\r\n    { [K in keyof S]: S[K] extends (el: any) => infer Fn ? Fn : never };\r\n\r\n  /**\r\n   * Attaches multiple event listeners to the component's Refs with automatic cleanup.\r\n   * @see bindEvents\r\n   */\r\n  bindEvents: (map: EventSchema<Refs>) => void;\r\n\r\n  /**\r\n   * Watches a specific key in the component's state (DOM attributes) for changes.\r\n   * Fires immediately with current value, then on every change.\r\n   * Auto-cleans up on destroy.\r\n   */\r\n  watch: (key: keyof State & string, handler: (val: any) => void) => void;\r\n\r\n  /**\r\n   * Registers a cleanup function to run when the component is destroyed.\r\n   * (Equivalent to React's useEffect return function).\r\n   */\r\n  effect: (fn: Unsubscribe) => void;\r\n\r\n  /**\r\n   * Attaches an event listener to an element with automatic cleanup.\r\n   * Returns an unsubscribe function for manual cleanup if needed.\r\n   *\r\n   * @param event - The event name (e.g., 'click', 'input').\r\n   * @param element - The target element or selector (resolved via ctx.find).\r\n   * @param handler - The event handler function.\r\n   * @param options - Optional event listener options.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * ctx.on('click', ctx.refs.btn, () => console.log('Clicked'));\r\n   * ctx.on('input', 'input[name=\"search\"]', (e) => handleSearch(e));\r\n   * ```\r\n   */\r\n  on: <K extends keyof HTMLElementEventMap>(\r\n    event: K,\r\n    element: HTMLElement | string,\r\n    handler: (e: HTMLElementEventMap[K]) => void,\r\n    options?: boolean | AddEventListenerOptions\r\n  ) => Unsubscribe;\r\n\r\n  /**\r\n   * Prebound bind utilities for easy DOM updates with selector resolution.\r\n   * All methods accept either an HTMLElement or a selector string.\r\n   */\r\n  bind: {\r\n    /**\r\n     * Two-way binding between an input element and a state key.\r\n     * Automatically syncs input value â†” state.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * ctx.bind.input('input[name=\"username\"]', 'username');\r\n     * // Now ctx.state.username updates the input, and input changes update state\r\n     * ```\r\n     */\r\n    input: (inputOrSelector: HTMLInputElement | string, stateKey: keyof State & string) => void;\r\n\r\n    /** Binds textContent to an element. */\r\n    text: (elOrSelector: HTMLElement | string | null) => Setter<string>;\r\n\r\n    /** Binds innerHTML to an element. */\r\n    html: (elOrSelector: HTMLElement | string | null) => Setter<string>;\r\n\r\n    /** Binds an attribute to an element. */\r\n    attr: (name: string, elOrSelector?: HTMLElement | string | null) => Setter<string | number | boolean | null> | ((el?: HTMLElement | string | null) => Setter<string | number | boolean | null>);\r\n\r\n    /** Binds a class toggle to an element. */\r\n    toggle: (className: string, elOrSelector?: HTMLElement | string | null) => Setter<boolean> | ((el?: HTMLElement | string | null) => Setter<boolean>);\r\n\r\n    /** Generic value binder with diffing. */\r\n    val: <T>(initial: T, effect: (val: T) => void) => Setter<T>;\r\n\r\n    /** Binds inline styles to an element. */\r\n    style: (elOrSelector: HTMLElement | string | null, property: string) => Setter<string | number>;\r\n\r\n    /** Binds CSS variables to an element. */\r\n    cssVar: (elOrSelector: HTMLElement | string | null, varName: string) => Setter<string | number>;\r\n\r\n    /** Binds a list to a container element. */\r\n    list: <T>(containerOrSelector: HTMLElement | string | null, renderItem: (item: T, index: number) => Node) => Setter<T[]>;\r\n  };\r\n\r\n  /**\r\n   * Observer utilities with automatic cleanup on component destroy.\r\n   */\r\n  observe: {\r\n    /**\r\n     * Creates an IntersectionObserver for an element.\r\n     * Auto-disconnects on component destroy.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * ctx.observe.intersection('.lazy-image', (entry) => {\r\n     *   if (entry.isIntersecting) loadImage(entry.target);\r\n     * });\r\n     * ```\r\n     */\r\n    intersection: (\r\n      elementOrSelector: HTMLElement | string,\r\n      callback: (entry: IntersectionObserverEntry) => void,\r\n      options?: IntersectionObserverInit\r\n    ) => void;\r\n\r\n    /**\r\n     * Creates a ResizeObserver for an element.\r\n     * Auto-disconnects on component destroy.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * ctx.observe.resize('.resizable', (entry) => {\r\n     *   console.log('New size:', entry.contentRect);\r\n     * });\r\n     * ```\r\n     */\r\n    resize: (\r\n      elementOrSelector: HTMLElement | string,\r\n      callback: (entry: ResizeObserverEntry) => void\r\n    ) => void;\r\n  };\r\n\r\n  /**\r\n   * Creates a computed property that derives its value from state keys.\r\n   * Re-computes whenever any dependency changes.\r\n   *\r\n   * @param deps - Array of state keys to watch.\r\n   * @param compute - Function to compute the derived value.\r\n   * @returns Object with current value and onChange subscription.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const fullName = ctx.computed(['firstName', 'lastName'], () =>\r\n   *   `${ctx.state.firstName} ${ctx.state.lastName}`\r\n   * );\r\n   *\r\n   * fullName.onChange((name) => console.log('Full name:', name));\r\n   * ```\r\n   */\r\n  computed: <T>(\r\n    deps: Array<keyof State & string>,\r\n    compute: () => T\r\n  ) => {\r\n    value: T;\r\n    onChange: (callback: (val: T) => void) => void;\r\n  };\r\n\r\n  /**\r\n   * Executes a function immediately after the component setup completes.\r\n   * Useful for initialization that needs the full context to be ready.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * ctx.onMount(() => {\r\n   *   console.log('Component mounted');\r\n   *   fetchInitialData();\r\n   * });\r\n   * ```\r\n   */\r\n  onMount: (fn: () => void) => void;\r\n\r\n  /**\r\n   * Registers a cleanup function to run when the component is destroyed.\r\n   * Alias for `effect()` with a clearer name for lifecycle clarity.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * ctx.onUnmount(() => {\r\n   *   console.log('Component unmounting');\r\n   *   saveState();\r\n   * });\r\n   * ```\r\n   */\r\n  onUnmount: (fn: () => void) => void;\r\n\r\n  /**\r\n   * Applies multiple pre-configured element transformers to an element.\r\n   * Accepts string selectors (resolved within component root) or HTMLElements.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * ctx.chain(\r\n   *   '.submit-btn',\r\n   *   cls.add('btn', 'btn-primary'),\r\n   *   css({ padding: '10px' }),\r\n   *   modify({ text: 'Submit' })\r\n   * );\r\n   *\r\n   * // Or with refs\r\n   * ctx.chain(\r\n   *   ctx.refs.button,\r\n   *   cls.add('active'),\r\n   *   attr.set('disabled', false)\r\n   * );\r\n   * ```\r\n   */\r\n  chain: <T extends HTMLElement>(\r\n    elementOrSelector: T | string,\r\n    ...transforms: Array<(el: T) => any>\r\n  ) => T | null;\r\n\r\n  /**\r\n   * Executes multiple callback functions on an element.\r\n   * Accepts string selectors (resolved within component root) or HTMLElements.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const theme = ctx.state.theme;\r\n   * ctx.exec(\r\n   *   '.app-container',\r\n   *   el => cls.add(el)(`theme-${theme}`),\r\n   *   el => on(el)('click', handleClick),\r\n   *   el => console.log('Configured:', el)\r\n   * );\r\n   * ```\r\n   */\r\n  exec: <T extends HTMLElement>(\r\n    elementOrSelector: T | string,\r\n    ...operations: Array<(el: T) => any>\r\n  ) => T | null;\r\n}\r\n\r\n/**\r\n * Context returned by `domCtx`.\r\n * Provides the same scoped toolkit as `defineComponent` plus a destroy method.\r\n */\r\nexport type DomContext<\r\n  Refs extends Record<string, HTMLElement> = any,\r\n  Groups extends Record<string, HTMLElement[]> = any,\r\n  State extends Record<string, any> = Record<string, any>\r\n> = ComponentContext<Refs, Groups, State> & {\r\n  /** Destroys the context, removing listeners and observers. */\r\n  destroy: () => void;\r\n};\r\n\r\n/**\r\n * The public interface returned by a component instance.\r\n */\r\nexport type ComponentInstance<API> = API & {\r\n  /** The root element */\r\n  root: HTMLElement;\r\n  /** Destroys the component, removing all listeners and observers */\r\n  destroy: () => void;\r\n};\r\n\r\nconst createComponentContext = <\r\n  R extends Record<string, HTMLElement> = any,\r\n  G extends Record<string, HTMLElement[]> = any,\r\n  S extends Record<string, any> = any\r\n>(root: HTMLElement) => {\r\n  const hooks = createListenerGroup();\r\n  const mountCallbacks: Array<() => void> = [];\r\n  let hasMounted = false;\r\n\r\n  const scopedRefs = refs(root) as R;\r\n  const scopedGroups = groupRefs(root) as G;\r\n\r\n  const resolveElement = (elOrSelector: HTMLElement | string | null): HTMLElement | null => {\r\n    if (typeof elOrSelector === 'string') {\r\n      return find(root)(elOrSelector);\r\n    }\r\n    return elOrSelector;\r\n  };\r\n\r\n  const ctx: ComponentContext<R, G, S> = {\r\n    root,\r\n    refs: scopedRefs,\r\n    groups: scopedGroups,\r\n    state: store<S>(root),\r\n    store: createStore,\r\n\r\n    find: find(root),\r\n    findAll: findAll(root),\r\n\r\n    binder: (schema) => binder(scopedRefs, schema),\r\n\r\n    bindEvents: (map) => {\r\n      hooks.add(bindEvents(scopedRefs, map));\r\n    },\r\n\r\n    watch: (key, handler) => {\r\n      hooks.add(Data.bind(root)(key, handler));\r\n    },\r\n\r\n    effect: (fn) => hooks.add(fn),\r\n\r\n    on: (event, element, handler, options) => {\r\n      const target = resolveElement(element);\r\n      const unsubscribe = on(target)(event, handler as any, options);\r\n      hooks.add(unsubscribe);\r\n      return unsubscribe;\r\n    },\r\n\r\n    bind: {\r\n      input: (inputOrSelector, stateKey) => {\r\n        const input = (typeof inputOrSelector === 'string'\r\n          ? find(root)(inputOrSelector)\r\n          : inputOrSelector) as HTMLInputElement;\r\n\r\n        if (!input) return;\r\n\r\n        const inputType = input.type?.toLowerCase() || 'text';\r\n        const isCheckbox = inputType === 'checkbox';\r\n        const isRadio = inputType === 'radio';\r\n\r\n        const updateInput = (val: any) => {\r\n          if (isCheckbox) {\r\n            input.checked = !!val;\r\n          } else if (isRadio) {\r\n            input.checked = input.value === String(val);\r\n          } else {\r\n            input.value = val ?? '';\r\n          }\r\n        };\r\n\r\n        const updateState = () => {\r\n          if (isCheckbox) {\r\n            ctx.state[stateKey] = input.checked as any;\r\n          } else if (isRadio) {\r\n            if (input.checked) {\r\n              ctx.state[stateKey] = input.value as any;\r\n            }\r\n          } else {\r\n            ctx.state[stateKey] = input.value as any;\r\n          }\r\n        };\r\n\r\n        updateInput(ctx.state[stateKey]);\r\n        ctx.watch(stateKey, updateInput);\r\n\r\n        const eventName = isCheckbox || isRadio ? 'change' : 'input';\r\n        hooks.add(on(input)(eventName as any, updateState));\r\n      },\r\n\r\n      text: (elOrSelector) => bind.text(resolveElement(elOrSelector)),\r\n      html: (elOrSelector) => bind.html(resolveElement(elOrSelector)),\r\n\r\n      attr: ((name: string, elOrSelector?: HTMLElement | string | null) => {\r\n        if (elOrSelector === undefined) {\r\n          return (el?: HTMLElement | string | null) => bind.attr(name, resolveElement(el || null));\r\n        }\r\n        return bind.attr(name, resolveElement(elOrSelector));\r\n      }) as any,\r\n\r\n      toggle: ((className: string, elOrSelector?: HTMLElement | string | null) => {\r\n        if (elOrSelector === undefined) {\r\n          return (el?: HTMLElement | string | null) => bind.toggle(className, resolveElement(el || null));\r\n        }\r\n        return bind.toggle(className, resolveElement(elOrSelector));\r\n      }) as any,\r\n\r\n      val: bind.val,\r\n\r\n      style: (elOrSelector, property) => bind.style(resolveElement(elOrSelector), property),\r\n      cssVar: (elOrSelector, varName) => bind.cssVar(resolveElement(elOrSelector), varName),\r\n      list: (containerOrSelector, renderItem) => bind.list(resolveElement(containerOrSelector), renderItem)\r\n    },\r\n\r\n    observe: {\r\n      intersection: (elementOrSelector, callback, options) => {\r\n        const element = resolveElement(elementOrSelector);\r\n        if (!element) return;\r\n\r\n        const observer = new IntersectionObserver((entries) => {\r\n          entries.forEach(callback);\r\n        }, options);\r\n\r\n        observer.observe(element);\r\n        hooks.add(() => observer.disconnect());\r\n      },\r\n\r\n      resize: (elementOrSelector, callback) => {\r\n        const element = resolveElement(elementOrSelector);\r\n        if (!element) return;\r\n\r\n        const observer = new ResizeObserver((entries) => {\r\n          entries.forEach(callback);\r\n        });\r\n\r\n        observer.observe(element);\r\n        hooks.add(() => observer.disconnect());\r\n      }\r\n    },\r\n\r\n    computed: (deps, compute) => {\r\n      let currentValue = compute();\r\n      const listeners = new Set<(val: any) => void>();\r\n\r\n      deps.forEach((dep) => {\r\n        ctx.watch(dep, () => {\r\n          const newValue = compute();\r\n          if (!Object.is(currentValue, newValue)) {\r\n            currentValue = newValue;\r\n            listeners.forEach((fn) => fn(newValue));\r\n          }\r\n        });\r\n      });\r\n\r\n      return {\r\n        get value() { return currentValue; },\r\n        onChange: (callback) => {\r\n          listeners.add(callback);\r\n          callback(currentValue);\r\n        }\r\n      };\r\n    },\r\n\r\n    onMount: (fn) => {\r\n      if (hasMounted) {\r\n        fn();\r\n        return;\r\n      }\r\n      mountCallbacks.push(fn);\r\n    },\r\n\r\n    onUnmount: (fn) => hooks.add(fn),\r\n\r\n    chain: (<T extends HTMLElement>(elementOrSelector: T | string, ...transforms: Array<(el: T) => any>): T | null => {\r\n      const element = (typeof elementOrSelector === 'string'\r\n        ? find(root)(elementOrSelector)\r\n        : elementOrSelector) as T | null;\r\n      return chain(element, ...transforms);\r\n    }) as any,\r\n\r\n    exec: (<T extends HTMLElement>(elementOrSelector: T | string, ...operations: Array<(el: T) => any>): T | null => {\r\n      const element = (typeof elementOrSelector === 'string'\r\n        ? find(root)(elementOrSelector)\r\n        : elementOrSelector) as T | null;\r\n      return exec(element, ...operations);\r\n    }) as any\r\n  };\r\n\r\n  const runMountCallbacks = () => {\r\n    if (hasMounted) return;\r\n    hasMounted = true;\r\n    mountCallbacks.forEach((fn) => fn());\r\n  };\r\n\r\n  return {\n    ctx,\n    auto: hooks.auto,\n    destroy: () => hooks.clear(),\n    runMountCallbacks\n  };\n};\r\n\r\n/**\r\n * Creates a component-like context for a root element.\r\n *\r\n * Returns a scoped toolkit matching `defineComponent` without creating a full\r\n * component instance. Includes automatic cleanup via `destroy()`.\r\n *\r\n * @template R - The shape of `refs` (elements marked with `data-ref=\"name\"`).\r\n * @template G - The shape of `groups` (lists marked with `data-ref=\"name\"`).\r\n * @template S - The shape of `state` (reactive `data-*` attributes).\r\n * @param target - DOM element or selector to scope the context to.\r\n * @returns A domCtx context or null if target not found.\r\n *\r\n * @example\r\n * ```typescript\r\n * const ctx = domCtx('#card');\r\n * if (ctx) {\r\n *   ctx.on('click', ctx.refs.button, () => alert('Clicked'));\r\n * }\r\n *\r\n * const root = document.querySelector('#panel');\r\n * const ctx2 = domCtx(root);\r\n * ctx2?.on('click', ctx2.refs.button, () => alert('Clicked'));\r\n * ```\r\n */\r\nexport const domCtx = <\r\n  R extends Record<string, HTMLElement> = any,\r\n  G extends Record<string, HTMLElement[]> = any,\r\n  S extends Record<string, any> = any\r\n>(target: string | HTMLElement | null): DomContext<R, G, S> | null => {\r\n  const root = (typeof target === 'string' ? find(document)(target) : target) as HTMLElement;\r\n  if (!root) return null;\r\n\r\n  const { ctx, destroy, runMountCallbacks } = createComponentContext<R, G, S>(root);\r\n  runMountCallbacks();\r\n\r\n  return Object.assign(ctx, { destroy });\r\n};\r\n\r\n/**\r\n * Creates a reactive, self-cleaning component instance on a DOM element.\r\n\r\n * \r\n * Applies the **Setup Pattern** (similar to Vue 3 Composition API) to Vanilla DOM.\r\n * It binds a logic closure to a root element and provides a scoped `Context` toolkit.\r\n * \r\n * ðŸ§  **Key Features:**\r\n * 1. **Auto-Cleanup**: All listeners (`bindEvents`), watchers (`watch`), and effects \r\n *    attached via the context are automatically removed when `destroy()` is called.\r\n * 2. **Scoped Access**: `refs`, `groups`, `binder`, `find` are scoped to the component root.\r\n * 3. **DOM-as-State**: `ctx.state` proxies `data-*` attributes for simple reactivity.\r\n * 4. **Composition**: The `setup` function allows for composing reusable logic.\r\n * \r\n * @template API - The public methods/properties returned by the component.\r\n * @template R - The shape of `refs` (elements marked with `data-ref=\"name\"`).\r\n * @template G - The shape of `groups` (lists marked with `data-ref=\"name\"`).\r\n * @template S - The shape of `state` (reactive `data-*` attributes).\r\n * \r\n * @param target - The DOM element or CSS selector to mount the component on.\r\n * @param setup - Initialization function. Receives `ComponentContext` and `auto` cleanup helper.\n\n * @returns The initialized component instance, or `null` if the target was not found.\r\n * \r\n * @example\r\n\r\n * ```typescript\r\n * // 1. Define Types\r\n * interface CounterRefs { display: HTMLElement; btn: HTMLButtonElement; }\r\n * interface CounterGroups { items: HTMLElement[]; }\r\n * interface CounterState { count: number; }\r\n * \r\n * // 2. Component Definition\r\n * const Counter = defineComponent<any, CounterRefs, CounterGroups, CounterState>('#app', (ctx) => {\r\n *   \r\n *   // Initialize State in DOM\r\n *   ctx.state.count = 0;\r\n * \r\n *   // Output Schema (Data -> DOM)\r\n *   const ui = ctx.binder({\r\n *     display: bind.text\r\n *   });\r\n * \r\n *   // Input Handling (DOM -> Logic)\r\n *   ctx.bindEvents({\r\n *     btn: {\r\n *       click: () => ctx.state.count++\r\n *     }\r\n *   });\r\n * \r\n *   // Working with Groups (Lists)\r\n *   ctx.groups.items.forEach((item, index) => {\r\n *      modify(item)({ text: `Item ${index}` });\r\n *   });\r\n * \r\n *   // Reactivity (State -> Output)\r\n *   ctx.watch('count', (val) => {\r\n *     ui.display(String(val));\r\n *   });\r\n * });\r\n * \r\n * // 3. Usage\r\n * // ... later ...\r\n * Counter.destroy();\r\n * ```\r\n */\r\nexport const defineComponent = <\r\n  API extends Record<string, any> = {},\r\n  R extends Record<string, HTMLElement> = any,\r\n  G extends Record<string, HTMLElement[]> = any,\r\n  S extends Record<string, any> = any\r\n>(\r\n  target: string | HTMLElement | null,\r\n  setup: (ctx: ComponentContext<R, G, S>, auto: AutoCleanup) => API | void\r\n): ComponentInstance<API> | null => {\r\n  const root = (typeof target === 'string' ? find(document)(target) : target) as HTMLElement;\r\n  if (!root) return null;\r\n\r\n  const { ctx, destroy, runMountCallbacks, auto } = createComponentContext<R, G, S>(root);\n\n  const api = setup(ctx, auto) || {} as API;\n  runMountCallbacks();\r\n\r\n  return {\r\n    ...api,\r\n    root,\r\n    destroy\r\n  };\r\n};\r\n\r\n\r\n\r\n/**\r\n * Spawns a component dynamically.\r\n * Useful for Modals, Toasts, or dynamic lists.\r\n * \r\n * @param templateFn - The view factory (from `view()`)\r\n * @param componentFn - The logic factory (from `defineComponent`)\r\n * @param target - Where to append the result\r\n * @param props - Initial props\r\n * \r\n * @example\r\n * ```typescript\r\n * // 1. Define the template\r\n * const ModalTemplate = view(({ title, message }) => html`\r\n *   <div class=\"modal\" data-ref=\"modal\">\r\n *     <div class=\"modal-content\">\r\n *       <h2 data-ref=\"title\">${title}</h2>\r\n *       <p data-ref=\"message\">${message}</p>\r\n *       <button data-ref=\"closeBtn\">Close</button>\r\n *     </div>\r\n *   </div>\r\n * `);\r\n * \r\n * // 2. Define the component logic\r\n * const ModalComponent = (root: HTMLElement) => defineComponent(root, (ctx) => {\r\n *   ctx.bindEvents({\r\n *     closeBtn: {\r\n *       click: () => instance.destroy()\r\n *     }\r\n *   });\r\n * \r\n *   return {\r\n *     setTitle: (title: string) => modify(ctx.refs.title)({ text: title }),\r\n *     setMessage: (msg: string) => modify(ctx.refs.message)({ text: msg })\r\n *   };\r\n * });\r\n * \r\n * // 3. Spawn the modal\r\n * const instance = mountComponent(\r\n *   () => ModalTemplate({ title: 'Alert', message: 'Hello World!' }),\r\n *   ModalComponent,\r\n *   document.body\r\n * );\r\n * \r\n * // 4. Use the API\r\n * instance.setTitle('New Title');\r\n * \r\n * // 5. Cleanup when done\r\n * instance.destroy(); // Removes DOM and cleans up listeners\r\n * ```\r\n */\r\nexport const mountComponent = <API>(\r\n  templateFn: () => { root: HTMLElement | DocumentFragment },\r\n  componentFn: (root: HTMLElement) => ComponentInstance<API> | null,\r\n  target: HTMLElement,\r\n  _props?: any\r\n) => {\r\n  // 1. Create DOM\r\n  const { root } = templateFn();\r\n  const rootEl = (root instanceof DocumentFragment ? root.firstElementChild : root) as HTMLElement;\r\n\r\n  // 2. Append to DOM (must happen before logic if logic needs measurements)\r\n  target.appendChild(root);\r\n\r\n  // 3. Initialize Logic\r\n  // We explicitly pass the element we just created\r\n  const instance = componentFn(rootEl);\r\n\r\n  if (!instance) {\r\n    rootEl.remove();\r\n    throw new Error('Failed to init component');\r\n  }\r\n\r\n  // 4. Return wrapper with destroy that cleans DOM too\r\n  return {\r\n    ...instance,\r\n    destroy: () => {\r\n      instance.destroy();\r\n      rootEl.remove();\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Control object passed to wrapped functions for fine-grained update control.\r\n *\r\n * @template R - The return/result type used for updates\r\n *\r\n * @example\r\n * ```typescript\r\n * const loadItems = sync((control) => {\r\n *   control(0); // Immediate update: \"Loading 0%\"\r\n *\r\n *   for (let i = 0; i < items.length; i++) {\r\n *     processItem(items[i]);\r\n *     control((i + 1) / items.length * 100); // Progress updates\r\n *   }\r\n *\r\n *   control.skip(); // Skip final auto-update (we already updated)\r\n *   return items.length;\r\n * });\r\n * ```\r\n */\r\ninterface UpdateControl<R> {\r\n  /**\r\n   * Trigger an immediate update with the given value.\r\n   * Useful for progress indicators, intermediate states, or streaming updates.\r\n   *\r\n   * @param value - The value to pass to the updater function\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const processFiles = sync((control) => {\r\n   *   files.forEach((file, i) => {\r\n   *     process(file);\r\n   *     control({ current: i + 1, total: files.length });\r\n   *   });\r\n   *   return files.length;\r\n   * });\r\n   * ```\r\n   */\r\n  (value: R): void;\r\n\r\n  /**\r\n   * Skip the automatic update that normally runs after function completion.\r\n   * Call this when you've handled updates manually and don't need a final one.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const manualUpdate = sync((control) => {\r\n   *   const result = compute();\r\n   *   control(result); // Manual update\r\n   *   control.skip();  // Don't update again with return value\r\n   *   return result;\r\n   * });\r\n   * ```\r\n   */\r\n  skip(): void;\r\n\r\n  /**\r\n   * Queue an update to run asynchronously (next microtask).\r\n   * Multiple queued updates within the same task are batched into one.\r\n   *\r\n   * @param value - The value to pass to the updater function\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const batchedOps = sync((control) => {\r\n   *   control.queue(1); // Queued\r\n   *   control.queue(2); // Replaces previous (batched)\r\n   *   control.queue(3); // Replaces previous (batched)\r\n   *   // Only one update runs with value 3\r\n   *   return 3;\r\n   * });\r\n   * ```\r\n   */\r\n  queue(value: R): void;\r\n\r\n  /**\r\n   * Force all queued updates to run immediately.\r\n   * Useful when you need to ensure DOM is updated before continuing.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const withFlush = sync((control) => {\r\n   *   control.queue(intermediateValue);\r\n   *   control.flush(); // Force update now\r\n   *   measureDOM();    // Safe to measure after flush\r\n   *   return finalValue;\r\n   * });\r\n   * ```\r\n   */\r\n  flush(): void;\r\n}\r\n\r\n/**\r\n * Updater function called when updates are triggered.\r\n *\r\n * @template T - The element type\r\n * @template R - The result type from wrapped functions\r\n *\r\n * @param el - The target element\r\n * @param result - The return value from the wrapped function (undefined on initial call)\r\n *\r\n * @example\r\n * ```typescript\r\n * // Simple text updater\r\n * const textUpdater: Updater<HTMLElement, number> = (el, result) => {\r\n *   el.textContent = result !== undefined ? String(result) : '0';\r\n * };\r\n *\r\n * // Progress bar updater\r\n * const progressUpdater: Updater<HTMLElement, number> = (el, percent) => {\r\n *   el.style.width = `${percent ?? 0}%`;\r\n *   el.setAttribute('aria-valuenow', String(percent ?? 0));\r\n * };\r\n * ```\r\n */\r\ntype Updater<T extends Element, R = unknown> = (el: T, result: R | undefined) => void;\r\n\r\n/**\r\n * Function signature for wrapped functions that receive update control.\r\n *\r\n * @template Args - Argument types for the function\r\n * @template R - Return type of the function\r\n */\r\ntype ControlledFn<Args extends any[], R> = (control: UpdateControl<R>, ...args: Args) => R;\r\n\r\n/**\r\n * Function signature for simple wrapped functions without control.\r\n *\r\n * @template Args - Argument types for the function\r\n * @template R - Return type of the function\r\n */\r\ntype SimpleFn<Args extends any[], R> = (...args: Args) => R;\r\n\r\n/**\r\n * The resulting wrapped function type.\r\n *\r\n * @template Args - Argument types for the function\r\n * @template R - Return type of the function\r\n */\r\ntype WrappedFn<Args extends any[], R> = (...args: Args) => R;\r\n\r\n/**\r\n * Helper type to extract wrapped function types from a record.\r\n */\r\ntype WrapAll<T extends Record<string, ControlledFn<any[], any>>> = {\r\n  [K in keyof T]: T[K] extends ControlledFn<infer Args, infer R>\r\n  ? WrappedFn<Args, R>\r\n  : never;\r\n};\r\n\r\n/**\r\n * Helper type for simple function wrapping.\r\n */\r\ntype WrapAllSimple<T extends Record<string, SimpleFn<any[], any>>> = {\r\n  [K in keyof T]: T[K] extends SimpleFn<infer Args, infer R>\r\n  ? WrappedFn<Args, R>\r\n  : never;\r\n};\r\n\r\n/**\r\n * The update wrapper interface with all utilities.\r\n *\r\n * @template T - The target element type\r\n *\r\n * @example\r\n * ```typescript\r\n * let count = 0;\r\n * const sync: UpdateWrapper<HTMLElement> = createUpdateAfter(\r\n *   countEl,\r\n *   (el, result) => { el.textContent = String(result ?? count); }\r\n * );\r\n *\r\n * // Use various wrapper methods\r\n * const increment = sync((ctrl) => ++count);\r\n * const add = sync((ctrl, n: number) => count += n);\r\n * const reset = sync.simple(() => count = 0);\r\n * ```\r\n */\r\ninterface UpdateWrapper<T extends Element> {\r\n  /**\r\n   * Wrap a function that receives update control.\r\n   * The updater automatically runs after function completion with its return value.\r\n   *\r\n   * @template Args - The function's argument types\r\n   * @template R - The function's return type\r\n   * @param fn - Function receiving UpdateControl as first argument, followed by any args\r\n   * @returns A wrapped function with the same signature (minus control)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const sync = createUpdateAfter(el, (el, count) => {\r\n   *   el.textContent = `Count: ${count}`;\r\n   * });\r\n   *\r\n   * // With control for intermediate updates\r\n   * const incrementBy = sync((control, amount: number) => {\r\n   *   for (let i = 0; i < amount; i++) {\r\n   *     count++;\r\n   *     control(count); // Update after each increment\r\n   *   }\r\n   *   return count;\r\n   * });\r\n   *\r\n   * incrementBy(5); // Updates 5 times during, once after\r\n   * ```\r\n   */\r\n  <Args extends any[], R>(fn: ControlledFn<Args, R>): WrappedFn<Args, R>;\r\n\r\n  /**\r\n   * Wrap a simple function without update control.\r\n   * Convenient when you don't need intermediate updates.\r\n   *\r\n   * @template Args - The function's argument types\r\n   * @template R - The function's return type\r\n   * @param fn - Simple function to wrap\r\n   * @returns A wrapped function with identical signature\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const increment = sync.simple(() => ++count);\r\n   * const add = sync.simple((n: number) => count += n);\r\n   * const reset = sync.simple(() => count = 0);\r\n   *\r\n   * increment();  // Updates with new count\r\n   * add(5);       // Updates with new count\r\n   * reset();      // Updates with 0\r\n   * ```\r\n   */\r\n  simple<Args extends any[], R>(fn: SimpleFn<Args, R>): WrappedFn<Args, R>;\r\n\r\n  /**\r\n   * Wrap multiple controlled functions at once.\r\n   *\r\n   * @template A - Record of controlled functions\r\n   * @param actions - Object mapping names to controlled functions\r\n   * @returns Object with same keys but wrapped functions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const actions = sync.all({\r\n   *   increment: (ctrl) => ++count,\r\n   *   decrement: (ctrl) => --count,\r\n   *   add: (ctrl, n: number) => count += n,\r\n   *   reset: (ctrl) => count = 0\r\n   * });\r\n   *\r\n   * actions.increment();  // Updates\r\n   * actions.add(10);      // Updates\r\n   * actions.reset();      // Updates\r\n   * ```\r\n   */\r\n  all<A extends Record<string, ControlledFn<any[], any>>>(actions: A): WrapAll<A>;\r\n\r\n  /**\r\n   * Wrap multiple simple functions at once.\r\n   *\r\n   * @template A - Record of simple functions\r\n   * @param actions - Object mapping names to simple functions\r\n   * @returns Object with same keys but wrapped functions\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const actions = sync.allSimple({\r\n   *   increment: () => ++count,\r\n   *   decrement: () => --count,\r\n   *   double: () => count *= 2\r\n   * });\r\n   *\r\n   * actions.increment();\r\n   * actions.double();\r\n   * ```\r\n   */\r\n  allSimple<A extends Record<string, SimpleFn<any[], any>>>(actions: A): WrapAllSimple<A>;\r\n\r\n  /**\r\n   * Batch multiple operations, running only ONE update at the end.\r\n   * All wrapped function calls inside the batch are executed,\r\n   * but their individual updates are suppressed until the batch completes.\r\n   *\r\n   * @template R - Return type of the batch function\r\n   * @param fn - Function containing multiple wrapped calls\r\n   * @returns The return value of fn\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Without batch: 3 DOM updates\r\n   * increment(); increment(); increment();\r\n   *\r\n   * // With batch: 1 DOM update\r\n   * sync.batch(() => {\r\n   *   increment();\r\n   *   increment();\r\n   *   increment();\r\n   * });\r\n   *\r\n   * // Batch with return value\r\n   * const finalCount = sync.batch(() => {\r\n   *   increment();\r\n   *   increment();\r\n   *   return count;\r\n   * });\r\n   * ```\r\n   */\r\n  batch<R>(fn: () => R): R;\r\n\r\n  /**\r\n   * Manually trigger an update with a specific value.\r\n   * Useful for forcing updates outside of wrapped functions.\r\n   *\r\n   * @template R - The value type\r\n   * @param value - Value to pass to the updater\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Force update with specific value\r\n   * sync.update(42);\r\n   *\r\n   * // Update after external change\r\n   * count = someExternalValue;\r\n   * sync.update(count);\r\n   * ```\r\n   */\r\n  update<R>(value: R): void;\r\n\r\n  /**\r\n   * Trigger an update with undefined (same as initial update).\r\n   * Useful when the updater reads from external state.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const sync = createUpdateAfter(el, (el) => {\r\n   *   el.textContent = String(count); // Reads from closure\r\n   * });\r\n   *\r\n   * count = 100;\r\n   * sync.refresh(); // Updates to show 100\r\n   * ```\r\n   */\r\n  refresh(): void;\r\n\r\n  /**\r\n   * Check if currently inside a batch operation.\r\n   */\r\n  readonly isBatching: boolean;\r\n\r\n  /**\r\n   * The target element (may be null if element wasn't found).\r\n   */\r\n  readonly el: T | null;\r\n}\r\n\r\n\r\n/**\r\n * Stage 1: Only element provided, waiting for updater.\r\n */\r\ntype ElementStage<T extends Element> = {\r\n  <R>(updater: Updater<T, R>): UpdateWrapper<T>;\r\n  <R>(updater: Updater<T, R>, initialValue: R): UpdateWrapper<T>;\r\n};\r\n\r\n// ============================================================================\r\n// OVERLOADS\r\n// ============================================================================\r\n\r\n/**\r\n * Creates an update wrapper that syncs DOM state after function execution.\r\n *\r\n * This utility bridges imperative state changes with DOM updates by:\r\n * 1. Running an initial update immediately (optional)\r\n * 2. Wrapping functions to trigger updates after they complete\r\n * 3. Passing return values to the updater for reactive-style updates\r\n * 4. Supporting intermediate updates, batching, and async operations\r\n *\r\n * @template T - The target element type (inferred from selector/element)\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic counter with automatic DOM sync\r\n * let count = 0;\r\n * const countEl = find('#count');\r\n *\r\n * const sync = createUpdateAfter(countEl, (el, result) => {\r\n *   el.textContent = String(result ?? count);\r\n * });\r\n *\r\n * const increment = sync.simple(() => ++count);\r\n * const decrement = sync.simple(() => --count);\r\n *\r\n * increment(); // DOM shows 1\r\n * increment(); // DOM shows 2\r\n * decrement(); // DOM shows 1\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Progress indicator with intermediate updates\r\n * const progressBar = find('.progress-bar');\r\n *\r\n * const sync = createUpdateAfter(progressBar, (el, percent) => {\r\n *   el.style.width = `${percent ?? 0}%`;\r\n *   el.textContent = `${percent ?? 0}%`;\r\n * });\r\n *\r\n * const processFiles = sync(async (control, files: File[]) => {\r\n *   for (let i = 0; i < files.length; i++) {\r\n *     await uploadFile(files[i]);\r\n *     control(Math.round((i + 1) / files.length * 100));\r\n *   }\r\n *   return 100;\r\n * });\r\n *\r\n * await processFiles(myFiles); // Progress updates during upload\r\n * ```\r\n *\r\n * @example\r\n * ```typescript\r\n * // Batching multiple updates\r\n * const sync = createUpdateAfter(el, (el, value) => {\r\n *   el.textContent = String(value);\r\n * });\r\n *\r\n * const inc = sync.simple(() => ++count);\r\n *\r\n * // Without batch: 3 DOM updates\r\n * inc(); inc(); inc();\r\n *\r\n * // With batch: 1 DOM update at the end\r\n * sync.batch(() => {\r\n *   inc(); inc(); inc();\r\n * });\r\n * ```\r\n */\r\n// Overload 1: Just element -> returns function waiting for updater\r\nexport function createUpdateAfter<T extends Element>(\r\n  el: T | null\r\n): ElementStage<T>;\r\n\r\n// Overload 2: Element + updater -> returns wrapper\r\nexport function createUpdateAfter<T extends Element, R = unknown>(\r\n  el: T | null,\r\n  updater: Updater<T, R>\r\n): UpdateWrapper<T>;\r\n\r\n// Overload 3: Element + updater + initial value -> returns wrapper (runs initial update with value)\r\nexport function createUpdateAfter<T extends Element, R>(\r\n  el: T | null,\r\n  updater: Updater<T, R>,\r\n  initialValue: R\r\n): UpdateWrapper<T>;\r\n\r\n// ============================================================================\r\n// IMPLEMENTATION\r\n// ============================================================================\r\n\r\nexport function createUpdateAfter<T extends Element, R = unknown>(\r\n  el: T | null,\r\n  updater?: Updater<T, R>,\r\n  initialValue?: R\r\n): ElementStage<T> | UpdateWrapper<T> {\r\n  /**\r\n   * Core factory that creates the wrapper given an updater.\r\n   */\r\n  const createWrapper = <Result>(\r\n    update: Updater<T, Result>,\r\n    initial?: Result\r\n  ): UpdateWrapper<T> => {\r\n    // Batching state\r\n    let isBatching = false;\r\n    let batchedValue: Result | undefined;\r\n    let hasBatchedValue = false;\r\n\r\n    // Queued update state (for microtask batching)\r\n    let queuedValue: Result | undefined;\r\n    let hasQueuedUpdate = false;\r\n    let queuedMicrotask: Promise<void> | null = null;\r\n\r\n    /**\r\n     * Execute the updater if element exists.\r\n     */\r\n    const runUpdate = (value: Result | undefined): void => {\r\n      if (!el) return;\r\n\r\n      if (isBatching) {\r\n        // Store for batch completion\r\n        batchedValue = value;\r\n        hasBatchedValue = true;\r\n        return;\r\n      }\r\n\r\n      update(el, value);\r\n    };\r\n\r\n    /**\r\n     * Process queued updates (runs as microtask).\r\n     */\r\n    const flushQueue = (): void => {\r\n      if (!hasQueuedUpdate) return;\r\n\r\n      const value = queuedValue;\r\n      queuedValue = undefined;\r\n      hasQueuedUpdate = false;\r\n      queuedMicrotask = null;\r\n\r\n      runUpdate(value);\r\n    };\r\n\r\n    /**\r\n     * Queue an update for the next microtask.\r\n     */\r\n    const queueUpdate = (value: Result): void => {\r\n      queuedValue = value;\r\n      hasQueuedUpdate = true;\r\n\r\n      if (!queuedMicrotask) {\r\n        queuedMicrotask = Promise.resolve().then(flushQueue);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Create the UpdateControl object for a wrapped function.\r\n     */\r\n    const createControl = (): UpdateControl<Result> & { _skip: boolean } => {\r\n      let shouldSkip = false;\r\n\r\n      const control = ((value: Result) => {\r\n        runUpdate(value);\r\n      }) as UpdateControl<Result> & { _skip: boolean };\r\n\r\n      control.skip = () => {\r\n        shouldSkip = true;\r\n      };\r\n\r\n      control.queue = (value: Result) => {\r\n        queueUpdate(value);\r\n      };\r\n\r\n      control.flush = () => {\r\n        flushQueue();\r\n      };\r\n\r\n      Object.defineProperty(control, '_skip', {\r\n        get: () => shouldSkip\r\n      });\r\n\r\n      return control;\r\n    };\r\n\r\n    /**\r\n     * Wrap a controlled function.\r\n     */\r\n    const wrapControlled = <Args extends any[], Ret>(\r\n      fn: ControlledFn<Args, Ret>\r\n    ): WrappedFn<Args, Ret> => {\r\n      return (...args: Args): Ret => {\r\n        const control = createControl() as unknown as UpdateControl<Ret> & { _skip: boolean };\r\n        const result = fn(control, ...args);\r\n\r\n        // Handle async functions\r\n        if (result instanceof Promise) {\r\n          return result.then((resolved) => {\r\n            if (!control._skip) {\r\n              runUpdate(resolved as unknown as Result);\r\n            }\r\n            return resolved;\r\n          }) as Ret;\r\n        }\r\n\r\n        // Sync: update after unless skipped\r\n        if (!control._skip) {\r\n          runUpdate(result as unknown as Result);\r\n        }\r\n\r\n        return result;\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Wrap a simple function (no control).\r\n     */\r\n    const wrapSimple = <Args extends any[], Ret>(\r\n      fn: SimpleFn<Args, Ret>\r\n    ): WrappedFn<Args, Ret> => {\r\n      return (...args: Args): Ret => {\r\n        const result = fn(...args);\r\n\r\n        // Handle async\r\n        if (result instanceof Promise) {\r\n          return result.then((resolved) => {\r\n            runUpdate(resolved as unknown as Result);\r\n            return resolved;\r\n          }) as Ret;\r\n        }\r\n\r\n        runUpdate(result as unknown as Result);\r\n        return result;\r\n      };\r\n    };\r\n\r\n    // Run initial update\r\n    if (el) {\r\n      update(el, initial);\r\n    }\r\n\r\n    // Build the wrapper object\r\n    const wrapper = (<Args extends any[], Ret>(\r\n      fn: ControlledFn<Args, Ret>\r\n    ): WrappedFn<Args, Ret> => {\r\n      return wrapControlled(fn);\r\n    }) as UpdateWrapper<T>;\r\n\r\n    wrapper.simple = wrapSimple;\r\n\r\n    wrapper.all = <A extends Record<string, ControlledFn<any[], any>>>(\r\n      actions: A\r\n    ): WrapAll<A> => {\r\n      return Object.fromEntries(\r\n        Object.entries(actions).map(([key, fn]) => [key, wrapControlled(fn)])\r\n      ) as WrapAll<A>;\r\n    };\r\n\r\n    wrapper.allSimple = <A extends Record<string, SimpleFn<any[], any>>>(\r\n      actions: A\r\n    ): WrapAllSimple<A> => {\r\n      return Object.fromEntries(\r\n        Object.entries(actions).map(([key, fn]) => [key, wrapSimple(fn)])\r\n      ) as WrapAllSimple<A>;\r\n    };\r\n\r\n    wrapper.batch = <Ret>(fn: () => Ret): Ret => {\r\n      const wasBatching = isBatching;\r\n      isBatching = true;\r\n      hasBatchedValue = false;\r\n\r\n      const result = fn();\r\n\r\n      // Handle async batch\r\n      if (result instanceof Promise) {\r\n        return result.then((resolved) => {\r\n          isBatching = wasBatching;\r\n          if (hasBatchedValue && !wasBatching) {\r\n            runUpdate(batchedValue);\r\n          }\r\n          return resolved;\r\n        }) as Ret;\r\n      }\r\n\r\n      // Sync batch: restore state and flush\r\n      isBatching = wasBatching;\r\n      if (hasBatchedValue && !wasBatching) {\r\n        runUpdate(batchedValue);\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    wrapper.update = <Ret>(value: Ret): void => {\r\n      runUpdate(value as unknown as Result);\r\n    };\r\n\r\n    wrapper.refresh = (): void => {\r\n      runUpdate(undefined);\r\n    };\r\n\r\n    Object.defineProperty(wrapper, 'isBatching', {\r\n      get: () => isBatching\r\n    });\r\n\r\n    Object.defineProperty(wrapper, 'el', {\r\n      value: el,\r\n      writable: false\r\n    });\r\n\r\n    return wrapper;\r\n  };\r\n\r\n  // Route based on arguments\r\n  if (updater === undefined) {\r\n    // Stage 1: Return function waiting for updater\r\n    return (<Result>(upd: Updater<T, Result>, init?: Result) => {\r\n      return createWrapper(upd, init);\r\n    }) as ElementStage<T>;\r\n  }\r\n\r\n  // Stage 2+: Create wrapper directly\r\n  return createWrapper(updater, initialValue);\r\n}"],
  "mappings": "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",
  "names": ["require", "el", "node", "element", "options", "attr", "index", "parent", "next", "prev", "kids", "sibs", "prop", "path", "fallback", "obj", "current", "value", "chain", "_a", "_b", "on", "matcher", "apply", "h", "html", "refs", "exec", "httpRes", "rect"]
}
