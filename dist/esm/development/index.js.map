{
  "version": 3,
  "sources": ["../../../src/index.ts"],
  "sourcesContent": ["/**\n * fdom (Functional DOM) - v2.0.0\n * ==========================================\n * A production-grade, target-first, type-safe DOM library.\n *\n * -----------------------------------------------------------------------------\n * üß† DESIGN PHILOSOPHY\n * -----------------------------------------------------------------------------\n * 1. Target-First: `Action(Element)(Config)` pattern for intuitive chaining.\n * 2. Curried: Functions return closures for composition/piping.\n * 3. Null-Safe: All functions fail gracefully on `null`/`undefined` targets.\n * 4. Type-Safe: Full Generics for HTML Elements, Events, and Return types.\n *\n * -----------------------------------------------------------------------------\n * üìö API DIRECTORY (27 MODULES)\n * -----------------------------------------------------------------------------\n *\n * üü¢ DOM CORE\n  *    1. Querying ......... find, findAll, closest\n  *    2. Events ........... on, onDelegated, dispatch\n  *    3. Manipulation ..... modify, css, tempStyle\n  *    4. Structure ........ append, prepend, after, before, remove, wrap, mount\n  *    5. Creation ......... el, html, htmlMany, clone\n *\n * üîµ STATE & ATTRIBUTES\n *    6. Classes .......... cls (add/remove/toggle), watchClass\n *    7. Attributes ....... Data (get/set/read/bind), watchAttr, watchText\n *    12. Objects ......... Obj (clone, isEqual, pick, omit)\n *    14. Refs ............ refs, groupRefs (data-ref handling)\n *    16. Cycling ......... cycleClass (State machines)\n *\n * üü° LIFECYCLE & OBSERVATION\n *    8. Lifecycle ........ onReady, onMount, waitFor\n *    17. Cleanup ......... stripListeners, instantiate, cloneMany\n *    20. Timing .......... debounce, throttle\n *    25. Groups .......... createListenerGroup (Batch cleanup)\n *    26. Signals ......... Signal (AbortController wrappers)\n *\n * üü£ LAYOUT & NAVIGATION\n *    10. Navigation ...... Traverse (parent, children, siblings, next, prev, parents, nextAll, prevAll, closestAll)\n *    11. CSS Utils ....... CssVar, computed, injectStyles, waitTransition\n *    15. Color ........... toColorSpace (Color mix utils)\n *    18. Geometry ........ rect, offset, isVisible\n *    19. Scroll/Focus .... scrollInto, focus, blur\n *\n * üü† DATA & NETWORK\n *    9. URL/Form ......... Params, Form (serialize/populate)\n *    13. Collections ..... batch, groupBy\n *    21. Storage ......... Local, Session (Typed wrappers)\n *    22. Cookies ......... Cookie (get/set/remove)\n *    23. Network ......... Http (get/post/put/delete)\n *    24. PWA ............. SW (Service Worker reg/post)\n *    27. Pub/Sub ......... createBus (Typed Event Emitter)\n *\n * @module fdom\n * @author Patrick Glenn\n * @license MIT\n */\n\n// =============================================================================\n// 0. TYPES & HELPERS\n// =============================================================================\n\n/**\n * Infers a DOM element type from a CSS selector string.\n * \n * Supports:\n * - Tag names: `'div'` ‚Üí `HTMLDivElement`\n * - SVG tags: `'svg'` ‚Üí `SVGSVGElement`\n * - ID selectors: `'#app'` ‚Üí `HTMLElement`\n * - Class selectors: `'.card'` ‚Üí `HTMLElement`\n * - Complex selectors: `'div.card'` ‚Üí `HTMLElement`\n * \n * @template S - The selector string literal type\n * \n * @example\n * ```typescript\n * type ButtonEl = ParseSelector<'button'>; // HTMLButtonElement\n * type AnchorEl = ParseSelector<'a'>; // HTMLAnchorElement\n * type SvgEl = ParseSelector<'svg'>; // SVGSVGElement\n * ```\n */\nexport type ParseSelector<S extends string> =\n  S extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[S]\n  : S extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[S]\n  : S extends `#${string}` ? HTMLElement\n  : S extends `.${string}` ? HTMLElement\n  : HTMLElement;\n\n/**\n * A cleanup/unsubscribe function returned by event listeners and subscriptions.\n * \n * Call this function to remove the listener and free resources.\n * \n * @example\n * ```typescript\n * const cleanup = on(button)('click', handler);\n * // Later...\n * cleanup(); // Removes the event listener\n * ```\n */\nexport type Unsubscribe = () => void;\n\n/**\n * Event map for HTML elements, extensible for custom events.\n * \n * @template T - Additional custom event mappings\n * \n * @example\n * ```typescript\n * type MyEvents = EventMap<{\n *   'custom:save': CustomEvent<{ id: number }>;\n *   'custom:delete': CustomEvent<{ id: number }>;\n * }>;\n * ```\n */\nexport type EventMap<T extends Record<string, Event> = {}> = HTMLElementEventMap & T;\n\n/**\n * Extracts the detail type from a CustomEvent.\n * \n * @template T - The CustomEvent type\n * \n * @example\n * ```typescript\n * type SaveEvent = CustomEvent<{ id: number }>;\n * type Detail = ExtractEventDetail<SaveEvent>; // { id: number }\n * ```\n */\nexport type ExtractEventDetail<T> = T extends CustomEvent<infer D> ? D : never;\n\n/**\n * Properties for creating/modifying elements.\n * \n * Supports declarative configuration of:\n * - Text content\n * - HTML content\n * - Inline styles\n * - Data attributes\n * - CSS classes\n * - HTML attributes\n * - Form element properties\n * \n * @example\n * ```typescript\n * const props: ElementProps = {\n *   text: 'Click me',\n *   class: { active: true, disabled: false },\n *   dataset: { userId: 123, role: 'admin' },\n *   style: { color: 'red', fontSize: '16px' },\n *   attr: { 'aria-label': 'Submit button' }\n * };\n * ```\n */\nexport interface ElementProps {\n  /** Sets innerText (safer than html) */\n  text?: string;\n  /** Sets innerHTML (use with caution - XSS risk) */\n  html?: string;\n  /** Inline CSS styles */\n  style?: Partial<CSSStyleDeclaration>;\n  /** Data attributes (data-*) - auto-converts to kebab-case */\n  dataset?: Record<string, string | number | boolean | null | undefined>;\n  /** CSS classes with boolean toggles */\n  class?: Record<string, boolean>;\n  /** HTML attributes */\n  attr?: Record<string, string | number | boolean | null | undefined>;\n  /** Value for form inputs */\n  value?: string | number;\n  /** Disabled state for form inputs */\n  disabled?: boolean;\n}\n\n/**\n * Strict element properties with element-specific validation.\n * \n * Provides better type safety by constraining properties based on element type.\n * \n * @template T - The HTML element type\n * \n * @example\n * ```typescript\n * const inputProps: StrictElementProps<HTMLInputElement> = {\n *   value: 'test',\n *   disabled: true,\n *   attr: { type: 'text', placeholder: 'Enter name' }\n * };\n * ```\n */\nexport type StrictElementProps<T extends HTMLElement> = ElementProps & {\n  value?: T extends HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement ? string | number : never;\n  disabled?: T extends HTMLInputElement | HTMLButtonElement | HTMLSelectElement | HTMLTextAreaElement ? boolean : never;\n};\n\n/**\n * Makes all properties in T deeply readonly.\n * \n * @template T - The type to make readonly\n */\nexport type DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\n/**\n * Makes all properties in T deeply partial.\n * \n * @template T - The type to make partial\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Internal: Normalizes content into an array of Nodes.\n * \n * Handles:\n * - Flattening nested arrays\n * - Filtering out null/undefined/false\n * - Converting strings to text nodes\n * - Preserving existing Node instances\n * \n * @internal\n */\nconst _nodes = (args: any[]): Node[] =>\n  args.flat()\n    .filter(x => x != null && x !== false)\n    .map(x => x instanceof Node ? x : document.createTextNode(String(x)));\n\n/**\n * Hybrid Function Builder.\n * Creates a function that supports both Curried and Imperative usage.\n * \n * @template T - The Target type (Element, string, etc)\n * @template A - The Arguments tuple type\n * @template R - The Return type\n * \n * @example\n * const add = def((el: HTMLElement, cls: string) => el.classList.add(cls));\n * \n * // Usage 1: Imperative (Cleaner DX)\n * add(div, 'active');\n * \n * // Usage 2: Curried (Pipeline friendly)\n * pipe(\n *   find('.btn'),\n *   el => add(el)('active')\n * );\n */\nexport const def = <T, A extends any[], R>(\n  // The implementation function takes target + args all at once\n  fn: (target: T | null, ...args: A) => R\n) => {\n  // Overload 1: Called with arguments -> Execute immediately\n  function wrapper(target: T | null, ...args: A): R;\n\n  // Overload 2: Called with just target -> Return curried function\n  function wrapper(target: T | null): (...args: A) => R;\n\n  // Implementation\n  function wrapper(target: T | null, ...args: any[]) {\n    // If we have extra args, run immediately\n    if (args.length > 0) {\n      // @ts-ignore - spread is safe here due to generics\n      return fn(target, ...args);\n    }\n    // Otherwise return the closure\n    return (...lateArgs: A) => fn(target, ...lateArgs);\n  }\n\n  return wrapper;\n};\n\n// =============================================================================\n// 1. QUERYING\n// =============================================================================\n\n\n\n/**\n * Finds the first element matching the selector.\n *\n * Overloads allow calling in two ways:\n * 1. `find(root)(selector)` ‚Äî search within a specific root (default: document)\n * 2. `find(selector)` ‚Äî root is implicitly `document`\n *\n * @template S - CSS selector (literal string for best inference)\n *\n * @overload\n * @param selector - The selector to search for within `document`\n * @returns The matched element or `null`, inferred from selector\n *\n * @example\n * // String-first API\n * const btn = find(\"button\");   // HTMLButtonElement | null\n * const app = find(\"#app\");     // HTMLElement | null\n *\n * @overload\n * @param root - The root to search within (defaults to document)\n * @returns A function that accepts a selector and returns the matched element\n *\n * @example\n * // Curried API\n * const findIn = find(document.querySelector(\".card\")!);\n * const title = findIn(\"h1\");   // HTMLHeadingElement | null\n */\nexport function find<S extends string>(\n  selector: S\n): ParseSelector<S> | null;\n\nexport function find(root?: ParentNode):\n  <S extends string>(selector: S) => ParseSelector<S> | null;\n\nexport function find(arg: any) {\n  // Case 1: string passed ‚Äî treat as selector with implicit document root\n  if (typeof arg === \"string\") {\n    const selector = arg;\n    return document.querySelector(selector) as any;\n  }\n\n  // Case 2: root passed ‚Äî return curried selector function\n  const root: ParentNode = arg ?? document;\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\n    return root.querySelector(selector) as ParseSelector<S> | null;\n  };\n}\n\n/**\n * Finds an element or throws if not found.\n * \n * @template S - CSS selector\n * @param selector - The selector to search for\n * @param root - The root to search within (default: document)\n * @returns The matched element\n * @throws Error if element not found\n */\nexport function require<S extends string>(selector: S, root: ParentNode = document): ParseSelector<S> {\n  const el = root.querySelector(selector);\n  if (!el) throw new Error(`Element not found: ${selector}`);\n  return el as ParseSelector<S>;\n}\n\n\n/**\n * Finds all elements matching the selector.\n *\n * Supports two call styles:\n * 1. `findAll(selector)` ‚Äî searches `document`\n * 2. `findAll(root)(selector)` ‚Äî searches a specific root\n *\n * @template S - CSS selector (literal string for best inference)\n *\n * @overload\n * @param selector - Selector to search for within `document`\n * @returns Array of matched elements (empty if none)\n *\n * @example\n * const items = findAll(\"li\");   // HTMLLIElement[]\n *\n * @overload\n * @param root - The root to search within (defaults to document)\n * @returns Function that accepts a selector and returns an array of elements\n *\n * @example\n * const findInside = findAll(container);\n * const inputs = findInside(\"input\");  // HTMLInputElement[]\n */\nexport function findAll<S extends string>(\n  selector: S\n): ParseSelector<S>[];\n\nexport function findAll(root?: ParentNode):\n  <S extends string>(selector: S) => ParseSelector<S>[];\n\nexport function findAll(arg: any) {\n  if (typeof arg === \"string\") {\n    const selector = arg;\n    return Array.from(document.querySelectorAll(selector)) as any[];\n  }\n\n  const root: ParentNode = arg ?? document;\n  return <S extends string>(selector: S): ParseSelector<S>[] => {\n    return Array.from(root.querySelectorAll(selector)) as ParseSelector<S>[];\n  };\n}\n\n\n/**\n * Finds the closest ancestor (including self) matching the selector.\n *\n * Supports:\n * 1. `closest(selector)` ‚Äî uses `document.documentElement` as the starting point\n * 2. `closest(element)(selector)` ‚Äî starts from a specific element\n *\n * Note: Using `closest(selector)` alone is rarely useful unless you\n * intentionally want to search from the root element.\n *\n * @template S - CSS selector (literal type for best inference)\n *\n * @overload\n * @param selector - Selector to match when starting at `document.documentElement`\n * @returns The matched ancestor or `null`\n *\n * @example\n * const htmlOrNull = closest(\"html\");\n *\n * @overload\n * @param element - Starting element (null-safe)\n * @returns Function accepting a selector that returns the matched ancestor\n *\n * @example\n * const card = closest(button)(\".card\"); // HTMLElement | null\n */\nexport function closest<S extends string>(\n  selector: S\n): ParseSelector<S> | null;\n\nexport function closest(element: Element | null):\n  <S extends string>(selector: S) => ParseSelector<S> | null;\n\nexport function closest(arg: any) {\n  if (typeof arg === \"string\") {\n    const selector = arg;\n    return document.documentElement.closest(selector) as any;\n  }\n\n  const element: Element | null = arg;\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\n    return element?.closest(selector) as ParseSelector<S> | null;\n  };\n}\n\n\n/**\n * Checks whether an element matching the selector exists.\n *\n * Overloads:\n * 1. `exists(selector)` ‚Äî searches `document`\n * 2. `exists(root)(selector)` ‚Äî searches within a specific root\n *\n * @template S - CSS selector (literal for best inference)\n *\n * @overload\n * @param selector - Selector to test within `document`\n * @returns `true` if a matching element exists, otherwise `false`\n *\n * @example\n * exists(\"button\");    // boolean\n * exists(\"#app\");      // boolean\n */\nexport function exists<S extends string>(\n  selector: S\n): boolean;\n\nexport function exists(root?: ParentNode):\n  <S extends string>(selector: S) => boolean;\n\nexport function exists(arg: any) {\n  if (typeof arg === \"string\") {\n    return document.querySelector(arg) !== null;\n  }\n\n  const root: ParentNode = arg ?? document;\n  return <S extends string>(selector: S): boolean => {\n    return root.querySelector(selector) !== null;\n  };\n}\n\n/**\n * Returns all siblings of an element (excluding the element itself).\n *\n * Overloads:\n * 1. `siblings(node)` ‚Äî returns its siblings\n * 2. `siblings(root)(node)` ‚Äî sibling list relative to a specific parent\n *\n * Null-safe: returns an empty array if `node` or parent is null.\n *\n * @example\n * const btn = document.querySelector(\"button\");\n * const sibs = siblings(btn);   // Element[]\n *\n * @example\n * const list = document.querySelector(\"ul\");\n * const sibsOf = siblings(list);\n * sibsOf(list.querySelector(\"li\"));\n */\nexport function siblings(node: Element | null): Element[];\n\nexport function siblings(root: ParentNode | null):\n  (node: Element | null) => Element[];\n\nexport function siblings(arg: any): any {\n  if (!(arg instanceof Element) && arg !== null) {\n    const root: ParentNode | null = arg;\n    return (node: Element | null): Element[] => {\n      if (!root || !node) return [];\n      return Array.from(root.children).filter(el => el !== node);\n    };\n  }\n\n  const node: Element | null = arg;\n  if (!node || !node.parentElement) return [];\n  return Array.from(node.parentElement.children).filter(el => el !== node);\n}\n\n\n/**\n * Checks whether a given element contains a descendant matching the selector.\n *\n * Overloads:\n * 1. `has(selector)` ‚Äî checks within `document`\n * 2. `has(element)(selector)` ‚Äî checks within a given element\n *\n * Null-safe: Passing `null` returns a function that always returns false.\n *\n * @template S - CSS selector string\n *\n * @overload\n * @param selector - Selector checked inside `document`\n * @returns `true` if a match exists, otherwise `false`\n *\n * @example\n * has(\".card\");  // boolean\n *\n * @overload\n * @param element - Element to test within (null-safe)\n * @returns Function testing a selector inside that element\n *\n * @example\n * const card = document.querySelector(\".card\");\n * const result = has(card)(\"button\");\n */\nexport function has<S extends string>(\n  selector: S\n): boolean;\n\nexport function has(element: ParentNode | null):\n  <S extends string>(selector: S) => boolean;\n\nexport function has(arg: any) {\n  if (typeof arg === \"string\") {\n    return document.querySelector(arg) !== null;\n  }\n\n  const root: ParentNode | null = arg;\n  return <S extends string>(selector: S): boolean => {\n    if (!root) return false;\n    return root.querySelector(selector) !== null;\n  };\n}\n\n/**\n * Returns the index of a node among its siblings.\n *\n * Overloads:\n * 1. `index(node)` ‚Äî returns the node's index or -1\n * 2. `index(root)(node)` ‚Äî curries the \"list parent\" (rare but consistent)\n *\n * Note: When called as `index(node)`, the parent is automatically the node's\n * actual parent element.\n *\n * @example\n * const item = document.querySelector(\"li\");\n * index(item);  // 0, 1, 2, ...\n *\n * @example\n * // Curried\n * const list = document.querySelector(\"ul\");\n * index(list)(someLi);\n */\nexport function index(node: Element | null): number;\n\nexport function index(root: ParentNode | null):\n  (node: Element | null) => number;\n\nexport function index(arg: any): any {\n  // Case: Direct index(node)\n  if (!(arg instanceof Element) && arg !== null) {\n    // Treat as curried root\n    const root: ParentNode | null = arg;\n    return (node: Element | null): number => {\n      if (!root || !node) return -1;\n      const children = Array.from(root.children);\n      return children.indexOf(node);\n    };\n  }\n\n  // Direct element case\n  const node: Element | null = arg;\n  if (!node || !node.parentElement) return -1;\n  return Array.from(node.parentElement.children).indexOf(node);\n}\n\n\n\n// =============================================================================\n// 2. EVENTS\n// =============================================================================\n\n/**\n * Attaches an event listener to the target element.\n *\n * Returns a cleanup function to remove the listener. Supports all standard\n * DOM events with full type inference. The handler receives both the event\n * and the target element for convenience.\n *\n * @template T - The event target type (EventTarget or more specific)\n * @template K - The event type key from HTMLElementEventMap\n * @param target - The element to attach the listener to (null-safe)\n * @returns A curried function that accepts event type, handler, and options\n *\n * @example\n * ```typescript\n * // Basic click handler\n * const button = document.querySelector('button');\n * const cleanup = on(button)('click', (e, target) => {\n *   console.log('Clicked!', target); // target is typed as the button\n *   e.preventDefault();\n * });\n *\n * // Later: remove the listener\n * cleanup();\n *\n * // Input events with type inference\n * const input = document.querySelector('input');\n * on(input)('input', (e) => {\n *   console.log(e.target.value); // e is InputEvent\n * });\n *\n * // Keyboard events\n * on(document)('keydown', (e) => {\n *   if (e.key === 'Escape') {\n *     console.log('Escape pressed');\n *   }\n * });\n *\n * // With options (capture, once, passive)\n * on(window)('scroll', handler, { passive: true });\n * on(button)('click', handler, { once: true });\n *\n * // Null-safe: returns no-op cleanup if target is null\n * const missing = document.querySelector('.missing');\n * const noop = on(missing)('click', handler); // Safe, returns () => {}\n * ```\n */\nexport const on = <T extends EventTarget = EventTarget>(target: T | null) => {\n  return <K extends keyof HTMLElementEventMap>(\n    eventType: K,\n    handler: (event: HTMLElementEventMap[K], target: T) => void,\n    options: boolean | AddEventListenerOptions = false\n  ): Unsubscribe => {\n    if (!target) return () => { };\n\n    const listener = (e: Event) => handler(e as HTMLElementEventMap[K], target);\n    target.addEventListener(eventType, listener, options);\n    return () => target.removeEventListener(eventType, listener, options);\n  };\n};\n\n/**\n * Attaches a **Delegated Event Listener** using event bubbling.\n * \n * üß† **Architecture**: `Root -> Selector -> Event`\n * This ordering allows you to group interactions by the target element type.\n * \n * üõ°Ô∏è **Type Safety**:\n * - The `match` argument is inferred from the CSS selector (e.g. `'button'` -> `HTMLButtonElement`).\n * - The `event` argument is inferred from the event name (e.g. `'click'` -> `MouseEvent`).\n * \n * @param root - The container element (e.g. `<ul>`, `form`, `document`).\n * \n * @example\n * ```typescript\n * // 1. Define the scope (e.g. a User Table)\n * const table = find(document)('#user-table');\n * const onTable = onDelegated(table);\n * \n * // 2. Define interactions for specific child elements\n * // Type inference knows 'tr' is HTMLTableRowElement\n * const onRow = onTable('tr');\n * \n * onRow('click', (e, row) => {\n *   console.log('Row clicked', row.dataset.id);\n *   cls.toggle(row)('selected');\n * });\n * \n * // 3. Define interactions for buttons\n * // Type inference knows 'button.delete' is HTMLButtonElement\n * onTable('button.delete')('click', (e, btn) => {\n *   e.stopPropagation();\n *   const id = btn.dataset.id;\n *   api.delete(id);\n * });\n * ```\n */\nexport const onDelegated = (root: ParentNode | null = document) => {\n  /**\n   * @param selector - CSS Selector to match target elements against (e.g. 'li', '.btn')\n   */\n  return <S extends string>(selector: S) => {\n    /**\n     * @param eventType - Standard DOM event name (click, input, change, etc)\n     * @param handler - Callback receiving the typed Event and the typed Matched Element\n     * @param options - EventListener options (capture, passive, etc)\n     */\n    return <K extends keyof HTMLElementEventMap>(\n      eventType: K,\n      handler: (event: HTMLElementEventMap[K], match: ParseSelector<S>) => void,\n      options: boolean | AddEventListenerOptions = false\n    ): Unsubscribe => {\n      if (!root) return () => { };\n\n      const listener = (e: Event) => {\n        const target = e.target as Element;\n\n        // 1. Find the closest ancestor (or self) that matches the selector\n        const match = target.closest ? target.closest(selector) : null;\n\n        // 2. Ensure the match exists AND is actually inside our root container\n        // (Prevents edge cases with disconnected nodes or Shadow DOM)\n        if (match && root.contains(match)) {\n          // @ts-ignore - TS inference here is complex but safe due to ParseSelector\n          handler(e as HTMLElementEventMap[K], match as ParseSelector<S>);\n        }\n      };\n\n      root.addEventListener(eventType, listener, options);\n      return () => root.removeEventListener(eventType, listener, options);\n    };\n  };\n};\n\n/**\n * Dispatches a CustomEvent from the target element.\n * \n * Creates and dispatches a CustomEvent with optional detail data. The detail\n * type is inferred from the provided data. By default, events bubble up the\n * DOM tree.\n * \n * @template T - The type of the detail data\n * @param target - The element to dispatch the event from (null-safe)\n * @returns A curried function that accepts event name, detail, and options\n * \n * @example\n * ```typescript\n * // Simple custom event\n * const button = document.querySelector('button');\n * dispatch(button)('clicked', { timestamp: Date.now() });\n * \n * // Typed custom events\n * interface SaveEvent {\n *   id: number;\n *   data: { name: string; email: string };\n * }\n * dispatch(form)('save', { id: 123, data: formData } as SaveEvent);\n * \n * // Listen for custom events\n * on(button)('clicked' as any, (e: CustomEvent) => {\n *   console.log('Detail:', e.detail); // { timestamp: ... }\n * });\n * \n * // Non-bubbling event\n * dispatch(element)('custom', data, { bubbles: false });\n * \n * // Cancelable event\n * dispatch(element)('beforeSave', data, { cancelable: true });\n * \n * // Component communication pattern\n * const modal = document.querySelector('.modal');\n * dispatch(modal)('modal:close', { reason: 'user-action' });\n * \n * // Null-safe: does nothing if target is null\n * const missing = document.querySelector('.missing');\n * dispatch(missing)('event', data); // Safe, no error\n * ```\n */\nexport const dispatch = (target: EventTarget | null) => {\n  return <T = any>(eventName: string, detail?: T, options: EventInit = { bubbles: true }) => {\n    if (target) {\n      target.dispatchEvent(new CustomEvent(eventName, { detail, ...options }));\n    }\n    return target;\n  };\n};\n\n\n// =============================================================================\n// 3. MANIPULATION (MODIFY & STYLE)\n// =============================================================================\n\n/**\n * Declaratively modifies an element's properties.\n *\n * Provides a unified API for setting text, HTML, styles, classes, attributes,\n * and dataset values. All modifications are applied in a single call. Returns\n * the element for chaining.\n *\n * @template T - The HTML element type\n * @param element - The element to modify (null-safe)\n * @returns A curried function that accepts props and returns the modified element\n *\n * @example\n * ```typescript\n * const button = document.querySelector('button');\n *\n * // Imperative (cleaner DX)\n * modify(button, { text: 'Click me!' });\n *\n * // Curried (pipeline friendly)\n * modify(button)({ text: 'Click me!' });\n *\n * // Multiple properties at once\n * modify(button)({\n *   text: 'Submit',\n *   class: { active: true, disabled: false },\n *   dataset: { userId: '123', action: 'save' },\n *   style: { backgroundColor: 'blue', color: 'white' },\n *   attr: { 'aria-label': 'Submit form', type: 'submit' }\n * });\n *\n * // Form inputs\n * const input = document.querySelector('input');\n * modify(input)({\n *   value: 'John Doe',\n *   disabled: false,\n *   attr: { placeholder: 'Enter name', required: true }\n * });\n *\n * // Conditional classes\n * modify(element)({\n *   class: {\n *     loading: isLoading,\n *     error: hasError,\n *     success: isSuccess\n *   }\n * });\n *\n * // Data attributes (auto-converts to kebab-case)\n * modify(element)({\n *   dataset: {\n *     userId: 123,        // becomes data-user-id=\"123\"\n *     isActive: true,     // becomes data-is-active=\"true\"\n *     config: { a: 1 }    // becomes data-config='{\"a\":1}'\n *   }\n * });\n *\n * // Null-safe: returns null if element is null\n * modify(null)({ text: 'test' }); // null\n * ```\n */\nexport const modify = def(<T extends HTMLElement>(element: T | null, props: ElementProps): T | null => {\n  if (!element) return null;\n\n  if (props.text !== undefined) element.innerText = props.text;\n  if (props.html !== undefined) element.innerHTML = props.html;\n  if (props.value !== undefined) (element as any).value = props.value;\n  if (props.disabled !== undefined) (element as any).disabled = props.disabled;\n\n  if (props.style) Object.assign(element.style, props.style);\n\n  if (props.dataset) {\n    Object.entries(props.dataset).forEach(([k, v]) => {\n      if (v === undefined) return;\n      element.dataset[k] = v === null ? undefined : String(v);\n    });\n  }\n\n  if (props.class) {\n    Object.entries(props.class).forEach(([k, v]) => element.classList.toggle(k, !!v));\n  }\n\n  if (props.attr) {\n    Object.entries(props.attr).forEach(([k, v]) => {\n      if (v === false || v === null || v === undefined) element.removeAttribute(k);\n      else element.setAttribute(k, String(v));\n    });\n  }\n\n  return element;\n});\n\n/** \n * Sets properties on an element.\n *  @alias modify \n */\nexport const set = modify\n\n/**\n * Applies inline CSS styles to an element.\n *\n * Merges the provided styles with existing inline styles. For removing styles,\n * set the property to empty string. Returns the element for chaining.\n *\n * @param element - The element to style (null-safe)\n * @returns A curried function that accepts styles and returns the element\n *\n * @example\n * ```typescript\n * const div = document.querySelector('div');\n *\n * // Imperative (cleaner DX)\n * css(div, { color: 'red', fontSize: '16px' });\n *\n * // Curried (pipeline friendly)\n * css(div)({\n *   color: 'red',\n *   fontSize: '16px',\n *   marginTop: '10px'\n * });\n *\n * // CSS custom properties (variables)\n * css(div)({\n *   '--primary-color': '#007bff',\n *   '--spacing': '1rem'\n * } as any);\n *\n * // Remove a style (set to empty string)\n * css(div)({ display: '' });\n *\n * // Animation and transitions\n * css(div)({\n *   transition: 'all 0.3s ease',\n *   transform: 'translateX(100px)',\n *   opacity: '0.5'\n * });\n *\n * // Chaining with modify\n * const element = modify(div)({ text: 'Hello' });\n * css(element)({ color: 'blue' });\n * ```\n */\nexport const css = def((element: HTMLElement | null, styles: Partial<CSSStyleDeclaration>) => {\n  if (element) Object.assign(element.style, styles);\n  return element;\n});\n\n/**\n * Applies styles temporarily and returns a revert function.\n * \n * Saves the original style values and applies new ones. The returned function\n * restores the original values. Useful for temporary visual states like hover\n * effects or loading states.\n * \n * @param element - The element to style (null-safe)\n * @returns A curried function that accepts styles and returns a cleanup function\n * \n * @example\n * ```typescript\n * const div = document.querySelector('div');\n * \n * // Temporarily change opacity\n * const revert = tempStyle(div)({ opacity: '0.5' });\n * // Later...\n * revert(); // Restores original opacity\n * \n * // Loading state pattern\n * const showLoading = () => {\n *   const revert = tempStyle(button)({\n *     opacity: '0.6',\n *     pointerEvents: 'none',\n *     cursor: 'wait'\n *   });\n *   \n *   fetchData().finally(() => {\n *     revert(); // Restore original styles\n *   });\n * };\n * \n * // Animation workflow\n * const element = document.querySelector('.box');\n * const cleanup = tempStyle(element)({\n *   transform: 'scale(1.2)',\n *   transition: 'transform 0.3s'\n * });\n * setTimeout(cleanup, 300); // Revert after animation\n * \n * // Null-safe: returns no-op if element is null\n * const noop = tempStyle(null)({ color: 'red' }); // () => {}\n * ```\n */\nexport const tempStyle = (element: HTMLElement | null) => {\n  return (styles: Partial<CSSStyleDeclaration>): Unsubscribe => {\n    if (!element) return () => { };\n    const original: Record<string, string> = {};\n\n    // Save original values\n    Object.keys(styles).forEach((key) => {\n      original[key] = element.style[key as keyof CSSStyleDeclaration] as string;\n    });\n\n    Object.assign(element.style, styles);\n\n    return () => Object.assign(element.style, original);\n  };\n};\n\n\n// =============================================================================\n// 4. STRUCTURE & TRAVERSAL\n// =============================================================================\n\n/**\n * Appends content to the end of the target element.\n *\n * Accepts multiple arguments of mixed types (strings, Nodes, null, undefined).\n * Strings are automatically converted to text nodes. Null/undefined values are\n * filtered out. Returns the parent for chaining.\n *\n * @param parent - The parent element to append to (null-safe)\n * @returns A curried function that accepts content and returns the parent\n *\n * @example\n * ```typescript\n * const list = document.querySelector('ul');\n *\n * // Imperative (cleaner DX)\n * append(list, item1, item2, item3);\n *\n * // Curried (pipeline friendly)\n * append(list)(item1, item2, item3);\n *\n * // Append a single element\n * const item = document.createElement('li');\n * append(list)(item);\n *\n * // Mix elements and text\n * append(container)(heading, 'Some text', paragraph);\n *\n * // Append text nodes\n * append(div)('Hello', ' ', 'World');\n *\n * // Null values are safely ignored\n * append(list)(item1, null, item2, undefined); // Only appends item1 and item2\n *\n * // Chaining\n * const parent = append(container)(child1);\n * append(parent)(child2);\n * ```\n */\nexport const append = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\n  parent?.append(..._nodes(content));\n  return parent;\n});\n\n/**\n * Prepends content to the start of the target element.\n *\n * Inserts content at the beginning, before any existing children. Accepts\n * multiple arguments of mixed types. Returns the parent for chaining.\n *\n * @param parent - The parent element to prepend to (null-safe)\n * @returns A curried function that accepts content and returns the parent\n *\n * @example\n * ```typescript\n * const list = document.querySelector('ul');\n *\n * // Imperative (cleaner DX)\n * prepend(list, firstItem);\n *\n * // Curried (pipeline friendly)\n * prepend(list)(firstItem);\n *\n * // Add header before content\n * const container = document.querySelector('.container');\n * const header = document.createElement('h1');\n * prepend(container)(header);\n * ```\n */\nexport const prepend = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\n  parent?.prepend(..._nodes(content));\n  return parent;\n});\n\n/**\n * Inserts content AFTER the target element as siblings.\n *\n * The content is inserted after the target in the DOM tree, at the same level.\n * Useful for inserting elements without modifying the target's children.\n *\n * @param target - The reference element (null-safe)\n * @returns A curried function that accepts content and returns the target\n *\n * @example\n * ```typescript\n * const header = document.querySelector('h1');\n * const banner = document.createElement('div');\n *\n * // Imperative (cleaner DX)\n * after(header, banner, notice, alert);\n *\n * // Curried (pipeline friendly)\n * after(header)(banner);\n *\n * // Insert multiple elements\n * after(header)(banner, notice, alert);\n * ```\n */\nexport const after = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\n  target?.after(..._nodes(content));\n  return target;\n});\n\n/**\n * Inserts content BEFORE the target element as siblings.\n *\n * The content is inserted before the target in the DOM tree, at the same level.\n *\n * @param target - The reference element (null-safe)\n * @returns A curried function that accepts content and returns the target\n *\n * @example\n * ```typescript\n * const footer = document.querySelector('footer');\n * const disclaimer = document.createElement('p');\n *\n * // Imperative (cleaner DX)\n * before(footer, disclaimer);\n *\n * // Curried (pipeline friendly)\n * before(footer)(disclaimer);\n * ```\n */\nexport const before = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\n  target?.before(..._nodes(content));\n  return target;\n});\n\n/**\n * Removes the target element from the DOM.\n * \n * Detaches the element from its parent. Event listeners attached via\n * addEventListener will be garbage collected. Always returns `null` for\n * type safety (prevents accidental reuse of removed elements).\n * \n * @param target - The element to remove (null-safe)\n * @returns Always returns `null`\n * \n * @example\n * ```typescript\n * const modal = document.querySelector('.modal');\n * remove(modal); // Modal is removed from DOM\n * \n * // Conditional removal\n * if (shouldRemove) {\n *   remove(element);\n * }\n * ```\n */\nexport const remove = (target: Element | null) => {\n  target?.remove();\n  return null;\n};\n\n/**\n * Removes all children from the target element.\n * \n * More efficient than `innerHTML = ''` and safer (doesn't parse HTML).\n * Returns the target for chaining.\n * \n * @param target - The element to empty (null-safe)\n * @returns The target element\n * \n * @example\n * ```typescript\n * const container = document.querySelector('.container');\n * \n * // Clear all content\n * empty(container);\n * \n * // Then add new content\n * append(empty(container))(newContent);\n * ```\n */\nexport const empty = (target: Element | null) => {\n  if (target) target.replaceChildren();\n  return target;\n};\n\n/**\n * Wraps the target element with a wrapper element.\n *\n * Inserts the wrapper before the target in the DOM, then moves the target\n * inside the wrapper. Useful for adding container elements around existing\n * content.\n *\n * @param target - The element to wrap (null-safe)\n * @returns A curried function that accepts a wrapper and returns it\n *\n * @example\n * ```typescript\n * const img = document.querySelector('img');\n * const figure = document.createElement('figure');\n *\n * // Imperative (cleaner DX)\n * wrap(img, figure);\n *\n * // Curried (pipeline friendly)\n * wrap(img)(figure);\n * // DOM: <figure><img /></figure>\n *\n * // Using el() helper\n * wrap(img)(el('figure')({})([]));\n *\n * // Add caption to wrapper\n * const wrapper = wrap(img)(figure);\n * append(wrapper)(el('figcaption')({})(['Image caption']));\n * ```\n */\nexport const wrap = def((target: HTMLElement | null, wrapper: HTMLElement) => {\n  if (target && wrapper && target.parentNode) {\n    target.parentNode.insertBefore(wrapper, target);\n    wrapper.appendChild(target);\n  }\n  return wrapper;\n});\n\n/**\n * Mounts a child element into a parent container.\n *\n * Appends the child to the parent and returns a cleanup function to remove it.\n * Useful for dynamic DOM updates, modals, popovers, and temporary UI elements.\n *\n * Supports two call styles:\n * 1. `mount(parent, child)` ‚Äî Imperative (cleaner DX)\n * 2. `mount(parent)(child)` ‚Äî Curried (pipeline friendly)\n *\n * @overload\n * @param parent - Parent element or selector (null-safe)\n * @param child - Child element to mount (or null for curried)\n * @returns Cleanup function to unmount the child, or no-op if parent not found\n *\n * @example\n * ```typescript\n * // Imperative style\n * const modal = document.createElement('div');\n * modal.textContent = 'Hello World';\n * const cleanup = mount(document.body, modal);\n *\n * // Later: remove the element\n * cleanup();\n *\n * // Using selector-first API\n * const popup = el('div')({ class: { popup: true } })(['Content']);\n * const remove = mount(\".container\")(popup);\n *\n * // Mounting multiple elements\n * const list = document.querySelector('ul');\n * const items = [el('li')({})(['Item 1']), el('li')({})(['Item 2'])];\n * const cleanups = items.map(item => mount(list)(item));\n *\n * // With temporary modal\n * const showModal = (content: string) => {\n *   const modal = el('div')({\n *     class: { modal: true },\n *     attr: { role: 'dialog' }\n *   })([content]);\n *\n *   const cleanup = mount(document.body)(modal);\n *\n *   // Auto-cleanup on button click\n *   modal.addEventListener('click', () => cleanup());\n *   return cleanup;\n * };\n * ```\n */\nexport const mount = def((parent: Element | string | null, child: Element | null): Unsubscribe => {\n  if (!child) return () => { };\n\n  const parentEl = typeof parent === 'string' ? document.querySelector(parent) : parent;\n  if (!parentEl) return () => { };\n\n  parentEl.appendChild(child);\n\n  // Return cleanup function\n  return () => {\n    if (child.parentNode === parentEl) {\n      parentEl.removeChild(child);\n    }\n  };\n});\n\n// =============================================================================\n// 5. CREATION & TEMPLATES\n// =============================================================================\n\n/**\n * Creates a DOM element with full type inference.\n * \n * Supports two syntaxes:\n * 1. **Hyperscript-style**: `el(tag, props, children)` ‚Äî cleaner, more readable\n * 2. **Curried**: `el(tag)(props)(children)` ‚Äî composable, pipeline-friendly\n * \n * The return type is automatically inferred from the tag name.\n * \n * @template K - The HTML tag name (keyof HTMLElementTagNameMap)\n * @param tag - The HTML tag name (e.g., 'div', 'button', 'a')\n * @param props - Optional properties (text, classes, attributes, etc.)\n * @param children - Optional children (elements or text)\n * @returns The created element (Hyperscript) or curried function (Curried)\n * \n * @example\n * ```typescript\n * // Hyperscript-style (new, cleaner)\n * const btn = el('button', { class: { primary: true } }, ['Click me']);\n * // btn is typed as HTMLButtonElement\n * \n * // Nested elements (much more readable)\n * const card = el('div', { class: { card: true } }, [\n *   el('h2', {}, ['Title']),\n *   el('p', {}, ['Description'])\n * ]);\n * \n * // Curried syntax (still supported for backward compatibility)\n * const link = el('a')({\n *   attr: { href: '/home' },\n *   class: { active: true },\n *   text: 'Home'\n * })([]);\n * // link is typed as HTMLAnchorElement\n * \n * // Form input with type inference\n * const input = el('input', {\n *   attr: { type: 'text', placeholder: 'Enter name' },\n *   value: 'John'\n * }, []);\n * // input is typed as HTMLInputElement\n * \n * // Partial application for reuse (curried)\n * const createButton = el('button');\n * const primaryBtn = createButton({ class: { primary: true } })(['Save']);\n * const secondaryBtn = createButton({ class: { secondary: true } })(['Cancel']);\n * ```\n */\nexport function el<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props: ElementProps,\n  children: (string | Node)[]\n): HTMLElementTagNameMap[K];\n\nexport function el<K extends keyof HTMLElementTagNameMap>(\n  tag: K\n): (props?: ElementProps) => (children?: (string | Node)[]) => HTMLElementTagNameMap[K];\n\nexport function el<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props?: ElementProps,\n  children?: (string | Node)[]\n): any {\n  // Hyperscript-style: el(tag, props, children)\n  if (props !== undefined && children !== undefined) {\n    const node = document.createElement(tag);\n    modify(node)(props);\n    node.append(..._nodes(children));\n    return node;\n  }\n\n  // Curried syntax: el(tag)(props)(children)\n  return (propsArg: ElementProps = {}) => {\n    return (childrenArg: (string | Node)[] = []): HTMLElementTagNameMap[K] => {\n      const node = document.createElement(tag);\n      modify(node)(propsArg);\n      node.append(..._nodes(childrenArg));\n      return node;\n    };\n  };\n}\n\n/**\n * Creates an element from an HTML template string.\n * \n * Uses tagged template literals for convenient HTML creation. Interpolated\n * values are automatically escaped. Returns the first element in the template.\n * \n * ‚ö†Ô∏è **XSS Warning**: Only use with trusted content. Do not interpolate\n * user input directly without sanitization.\n * \n * @param strings - Template string parts\n * @param values - Interpolated values\n * @returns The created HTMLElement\n * @throws Error if template doesn't produce an element\n * \n * @example\n * ```typescript\n * // Basic usage\n * const div = html`<div class=\"container\">Hello</div>`;\n * \n * // With interpolation\n * const name = 'World';\n * const greeting = html`<h1>Hello ${name}!</h1>`;\n * \n * // Complex structure\n * const card = html`\n *   <div class=\"card\">\n *     <h2>${title}</h2>\n *     <p>${description}</p>\n *   </div>\n * `;\n * \n * // ‚ö†Ô∏è UNSAFE - Don't do this with user input!\n * // const unsafe = html`<div>${userInput}</div>`;\n * \n * // ‚úÖ SAFE - Sanitize user input first\n * const safe = html`<div>${sanitize(userInput)}</div>`;\n * ```\n */\nexport const html = (strings: TemplateStringsArray, ...values: any[]): HTMLElement => {\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\n  const tpl = document.createElement('template');\n  tpl.innerHTML = str.trim();\n  const el = tpl.content.firstElementChild;\n  if (!el) throw new Error('html: Template did not result in an element');\n  return el as HTMLElement;\n};\n\n/**\n * Creates a DocumentFragment from an HTML template string.\n * \n * Like `html()` but returns a DocumentFragment containing all elements\n * from the template. Useful for creating multiple sibling elements at once.\n * \n * ‚ö†Ô∏è **XSS Warning**: Only use with trusted content.\n * \n * @param strings - Template string parts\n * @param values - Interpolated values\n * @returns A DocumentFragment containing the created elements\n * \n * @example\n * ```typescript\n * // Create multiple list items\n * const items = htmlMany`\n *   <li>Item 1</li>\n *   <li>Item 2</li>\n *   <li>Item 3</li>\n * `;\n * \n * const list = document.querySelector('ul');\n * list.appendChild(items);\n * \n * // With interpolation\n * const rows = htmlMany`\n *   <tr><td>${col1}</td><td>${col2}</td></tr>\n *   <tr><td>${col3}</td><td>${col4}</td></tr>\n * `;\n * ```\n */\nexport const htmlMany = (strings: TemplateStringsArray, ...values: any[]): DocumentFragment => {\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\n  const tpl = document.createElement('template');\n  tpl.innerHTML = str.trim();\n  return tpl.content;\n};\n\n/**\n * Clones a node, preserving its exact type.\n * \n * Creates a copy of the node and optionally its descendants. The cloned node\n * has no parent and is not part of the document. Event listeners are NOT\n * copied.\n * \n * @template T - The node type (preserved in return type)\n * @param node - The node to clone (null-safe)\n * @returns A curried function that accepts deep flag and returns the clone\n * \n * @example\n * ```typescript\n * const button = document.querySelector('button');\n * \n * // Deep clone (includes children)\n * const btnCopy = clone(button)(true);\n * // btnCopy is typed as HTMLButtonElement\n * \n * // Shallow clone (no children)\n * const btnShallow = clone(button)(false);\n * \n * // Template pattern\n * const template = el('div')({ class: { card: true } })([\n *   el('h2')({})(['Title']),\n *   el('p')({})(['Description'])\n * ]);\n * \n * // Create multiple cards from template\n * const card1 = clone(template)(true);\n * const card2 = clone(template)(true);\n * const card3 = clone(template)(true);\n * \n * // Null-safe\n * const missing = document.querySelector('.missing');\n * const result = clone(missing)(true); // null\n * ```\n */\nexport const clone = <T extends Node>(node: T | null) => {\n  return (deep: boolean = true): T | null => {\n    return node ? (node.cloneNode(deep) as T) : null;\n  };\n};\n\n\n// =============================================================================\n// 6. CLASS MANIPULATION\n// =============================================================================\n\n/**\n * Utilities for manipulating CSS classes on elements.\n * \n * All methods are null-safe and return the element for chaining (except `has`).\n * Provides a functional API for common classList operations.\n * \n * @example\n * ```typescript\n * const button = document.querySelector('button');\n * \n * // Add multiple classes\n * cls.add(button)('btn', 'btn-primary', 'active');\n * \n * // Remove classes\n * cls.remove(button)('disabled', 'loading');\n * \n * // Toggle with optional force\n * cls.toggle(button)('active'); // Toggles\n * cls.toggle(button)('active', true); // Forces add\n * cls.toggle(button)('active', false); // Forces remove\n * \n * // Replace a class\n * cls.replace(button)('btn-primary', 'btn-secondary');\n * \n * // Check for class\n * if (cls.has(button)('active')) {\n *   console.log('Button is active');\n * }\n * \n * // Chaining\n * cls.add(button)('btn');\n * cls.toggle(button)('active');\n * ```\n */\nexport const cls = {\n  /**\n   * Adds one or more CSS classes to the element.\n   *\n   * @param el - The element to add classes to (null-safe)\n   * @returns A curried function that accepts class names and returns the element\n   *\n   * @example\n   * ```typescript\n   * // Imperative (cleaner DX)\n   * cls.add(btn, 'active', 'shadow');\n   *\n   * // Curried (pipeline friendly)\n   * cls.add(btn)('active', 'shadow');\n   *\n   * // Add single class\n   * cls.add(div)('active');\n   *\n   * // Add multiple classes\n   * cls.add(div)('card', 'shadow', 'rounded');\n   *\n   * // Null-safe\n   * cls.add(null)('active'); // Returns null\n   * ```\n   */\n  add: def((el: Element | null, ...classes: string[]) => {\n    el?.classList.add(...classes);\n    return el;\n  }),\n\n  /**\n   * Removes one or more CSS classes from the element.\n   *\n   * @param el - The element to remove classes from (null-safe)\n   * @returns A curried function that accepts class names and returns the element\n   *\n   * @example\n   * ```typescript\n   * // Imperative (cleaner DX)\n   * cls.remove(btn, 'active', 'shadow');\n   *\n   * // Curried (pipeline friendly)\n   * cls.remove(btn)('active', 'shadow');\n   *\n   * // Remove single class\n   * cls.remove(div)('active');\n   *\n   * // Remove multiple classes\n   * cls.remove(div)('loading', 'disabled', 'error');\n   *\n   * // Safe if class doesn't exist\n   * cls.remove(div)('nonexistent'); // No error\n   * ```\n   */\n  remove: def((el: Element | null, ...classes: string[]) => {\n    el?.classList.remove(...classes);\n    return el;\n  }),\n\n  /**\n   * Toggles a CSS class on the element.\n   *\n   * @param el - The element to toggle the class on (null-safe)\n   * @returns A curried function that accepts class name and optional force flag\n   *\n   * @example\n   * ```typescript\n   * // Imperative (cleaner DX)\n   * cls.toggle(btn, 'active');\n   * cls.toggle(btn, 'active', true); // Force add\n   *\n   * // Curried (pipeline friendly)\n   * cls.toggle(btn)('active'); // Adds if absent, removes if present\n   * cls.toggle(btn)('active', true); // Always adds\n   * cls.toggle(btn)('active', false); // Always removes\n   *\n   * // Conditional toggle\n   * cls.toggle(button)('disabled', isLoading);\n   * ```\n   */\n  toggle: def((el: Element | null, className: string, force?: boolean) => {\n    el?.classList.toggle(className, force);\n    return el;\n  }),\n\n  /**\n   * Replaces an old class with a new class.\n   *\n   * @param el - The element to modify (null-safe)\n   * @returns A curried function that accepts old and new class names\n   *\n   * @example\n   * ```typescript\n   * // Imperative (cleaner DX)\n   * cls.replace(btn, 'btn-primary', 'btn-secondary');\n   *\n   * // Curried (pipeline friendly)\n   * cls.replace(btn)('btn-primary', 'btn-secondary');\n   *\n   * // Replace theme class\n   * cls.replace(div)('theme-light', 'theme-dark');\n   *\n   * // No effect if old class doesn't exist\n   * cls.replace(div)('nonexistent', 'new'); // No change\n   * ```\n   */\n  replace: def((el: Element | null, oldClass: string, newClass: string) => {\n    el?.classList.replace(oldClass, newClass);\n    return el;\n  }),\n\n  /**\n   * Checks if the element has a specific class.\n   * \n   * @param el - The element to check (null-safe)\n   * @returns A curried function that accepts a class name and returns boolean\n   * \n   * @example\n   * ```typescript\n   * const button = document.querySelector('button');\n   * \n   * // Check for class\n   * if (cls.has(button)('active')) {\n   *   console.log('Button is active');\n   * }\n   * \n   * // Conditional logic\n   * const isDisabled = cls.has(button)('disabled');\n   * \n   * // Null-safe: returns false if element is null\n   * cls.has(null)('active'); // false\n   * ```\n   */\n  has: (el: Element | null) => (className: string) => {\n    return !!el && el.classList.contains(className);\n  }\n};\n\n/**\n * Observes changes to a specific class on an element.\n *\n * Uses MutationObserver to watch for class attribute changes. The callback\n * fires only when the specified class is added or removed (not on other class\n * changes). Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses attribute filtering for efficiency. Consider debouncing\n * the callback if rapid changes are expected.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts class name and callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const modal = document.querySelector('.modal');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchClass(modal, 'open', (isPresent, el) => {\n *   if (isPresent) {\n *     console.log('Modal opened');\n *     document.body.style.overflow = 'hidden';\n *   } else {\n *     console.log('Modal closed');\n *     document.body.style.overflow = '';\n *   }\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchClass(modal)('open', (isPresent, el) => {\n *   if (isPresent) {\n *     console.log('Modal opened');\n *     document.body.style.overflow = 'hidden';\n *   } else {\n *     console.log('Modal closed');\n *     document.body.style.overflow = '';\n *   }\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Watch loading state\n * watchClass(button)('loading', (isLoading) => {\n *   button.disabled = isLoading;\n * });\n *\n * // Sync state between elements\n * watchClass(sidebar)('collapsed', (isCollapsed) => {\n *   cls.toggle(mainContent)('expanded', isCollapsed);\n * });\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchClass(null)('active', callback); // () => {}\n * ```\n */\nexport const watchClass = def((target: Element | null, className: string, callback: (isPresent: boolean, el: Element) => void): Unsubscribe => {\n  if (!target) return () => { };\n  let was = target.classList.contains(className);\n  const obs = new MutationObserver(() => {\n    const is = target.classList.contains(className);\n    if (is !== was) { was = is; callback(is, target); }\n  });\n  obs.observe(target, { attributes: true, attributeFilter: ['class'] });\n  return () => obs.disconnect();\n});\n\n\n// =============================================================================\n// 7. DATASET & ATTRIBUTES\n// =============================================================================\n\nconst toDataAttr = (str: string) => 'data-' + str.replace(/[A-Z]/g, m => \"-\" + m.toLowerCase());\n\n/**\n * Utilities for working with data attributes (data-*).\n * \n * Provides a functional API for getting, setting, and observing data attributes.\n * Automatically handles type conversion (numbers, booleans, JSON) and camelCase\n * to kebab-case conversion.\n * \n * @example\n * ```typescript\n * const div = document.querySelector('div');\n * \n * // Set data attributes\n * Data.set(div)('userId', 123);        // data-user-id=\"123\"\n * Data.set(div)('isActive', true);     // data-is-active=\"true\"\n * Data.set(div)('config', { a: 1 });   // data-config='{\"a\":1}'\n * \n * // Get raw string value\n * const userId = Data.get(div)('userId'); // \"123\"\n * \n * // Read with type inference\n * const id = Data.read(div)('userId');     // 123 (number)\n * const active = Data.read(div)('isActive'); // true (boolean)\n * const config = Data.read(div)('config');   // { a: 1 } (object)\n * \n * // React to changes\n * Data.bind(div)('count', (value) => {\n *   console.log('Count changed:', value);\n * });\n * ```\n */\nexport const Data = {\n  /**\n   * Gets the raw string value of a data attribute.\n   * \n   * Returns the value as-is from the dataset. For type conversion, use `read()`.\n   * \n   * @template T - The element type (inferred)\n   * @param el - The element to get data from (null-safe)\n   * @returns A curried function that accepts a key and returns the value or undefined\n   * \n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   * div.dataset.userId = '123';\n   * \n   * // Get raw value\n   * const userId = Data.get(div)('userId'); // \"123\" (string)\n   * \n   * // CamelCase key\n   * const userName = Data.get(div)('userName'); // Accesses data-user-name\n   * \n   * // Missing attribute\n   * const missing = Data.get(div)('missing'); // undefined\n   * \n   * // Null-safe\n   * Data.get(null)('userId'); // undefined\n   * ```\n   */\n  get: (el: HTMLElement | null) => (key: string) => el?.dataset[key],\n\n  /**\n   * Sets a data attribute value.\n   *\n   * Automatically converts objects to JSON strings and handles null/undefined\n   * by removing the attribute. CamelCase keys are converted to kebab-case.\n   *\n   * @template T - The element type (inferred)\n   * @param el - The element to set data on (null-safe)\n   * @returns A curried function that accepts key and value, returns the element\n   *\n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   *\n   * // Imperative (cleaner DX)\n   * Data.set(div, 'userId', '123');\n   *\n   * // Curried (pipeline friendly)\n   * Data.set(div)('userId', '123');\n   *\n   * // Set number (converted to string)\n   * Data.set(div)('count', 42); // data-count=\"42\"\n   *\n   * // Set boolean\n   * Data.set(div)('isActive', true); // data-is-active=\"true\"\n   *\n   * // Set object (JSON stringified)\n   * Data.set(div)('config', { theme: 'dark', size: 'lg' });\n   * // data-config='{\"theme\":\"dark\",\"size\":\"lg\"}'\n   *\n   * // Remove attribute (null or undefined)\n   * Data.set(div)('userId', null); // Removes data-user-id\n   *\n   * // CamelCase to kebab-case\n   * Data.set(div)('userName', 'John'); // Sets data-user-name=\"John\"\n   *\n   * // Chaining\n   * Data.set(div)('id', 1);\n   * Data.set(div)('name', 'Item');\n   * ```\n   */\n  set: def((el: HTMLElement | null, key: string, val: any) => {\n    if (!el) return el;\n    if (val == null) delete el.dataset[key];\n    else el.dataset[key] = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    return el;\n  }),\n\n  /**\n   * Reads a data attribute with automatic type inference.\n   * \n   * Intelligently parses the value:\n   * - `\"true\"` ‚Üí `true` (boolean)\n   * - `\"false\"` ‚Üí `false` (boolean)\n   * - `\"null\"` ‚Üí `null`\n   * - `\"123\"` ‚Üí `123` (number)\n   * - `'{\"a\":1}'` ‚Üí `{a:1}` (parsed JSON)\n   * - Other ‚Üí string\n   * \n   * @template T - The expected return type\n   * @param el - The element to read from (null-safe)\n   * @returns A curried function that accepts a key and returns the parsed value\n   * \n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   * \n   * // Boolean parsing\n   * div.dataset.isActive = 'true';\n   * Data.read(div)('isActive'); // true (boolean)\n   * \n   * // Number parsing\n   * div.dataset.count = '42';\n   * Data.read(div)('count'); // 42 (number)\n   * \n   * // JSON parsing\n   * div.dataset.config = '{\"theme\":\"dark\"}';\n   * Data.read(div)('config'); // { theme: 'dark' }\n   * \n   * // String fallback\n   * div.dataset.name = 'John';\n   * Data.read(div)('name'); // \"John\" (string)\n   * \n   * // Missing attribute\n   * Data.read(div)('missing'); // undefined\n   * \n   * // Type-safe usage\n   * interface Config { theme: string; size: string; }\n   * const config = Data.read<Config>(div)('config');\n   * ```\n   */\n  read: (el: HTMLElement | null) => (key: string): any => {\n    if (!el || !(key in (el.dataset || {}))) return undefined;\n    const val = el.dataset[key]!;\n    if (val === 'true') return true;\n    if (val === 'false') return false;\n    if (val === 'null') return null;\n    if (!isNaN(Number(val)) && val.trim() !== '') return Number(val);\n    if (val.startsWith('{') || val.startsWith('[')) {\n      try { return JSON.parse(val); } catch { return val; }\n    }\n    return val;\n  },\n\n  /**\n   * Observes changes to a data attribute and fires a callback.\n   *\n   * Uses MutationObserver to watch for attribute changes. The callback fires\n   * immediately with the current value, then on every change. Values are\n   * automatically parsed using `Data.read()`.\n   *\n   * @template T - The expected value type\n   * @param el - The element to observe (null-safe)\n   * @returns A curried function that accepts key and callback, returns cleanup function\n   *\n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   *\n   * // Imperative (cleaner DX)\n   * const cleanup = Data.bind(div, 'count', (value, el) => {\n   *   console.log('Count is now:', value);\n   * });\n   *\n   * // Curried (pipeline friendly)\n   * const cleanup = Data.bind(div)('count', (value, el) => {\n   *   console.log('Count is now:', value);\n   *   // Fires immediately with current value\n   *   // Then fires on every change\n   * });\n   *\n   * // Later: stop watching\n   * cleanup();\n   *\n   * // Form validation example\n   * Data.bind(input)('validationError', (error) => {\n   *   if (error) {\n   *     errorDisplay.textContent = error;\n   *     errorDisplay.style.display = 'block';\n   *   } else {\n   *     errorDisplay.style.display = 'none';\n   *   }\n   * });\n   *\n   * // Sync state between components\n   * Data.bind(slider)('value', (value) => {\n   *   valueDisplay.textContent = String(value);\n   * });\n   *\n   * // Null-safe: returns no-op cleanup\n   * const noop = Data.bind(null)('key', callback); // () => {}\n   * ```\n   */\n  bind: def((el: HTMLElement | null, key: string, callback: (val: any, el: HTMLElement) => void): Unsubscribe => {\n    if (!el) return () => { };\n    const attr = toDataAttr(key);\n    const update = () => callback(Data.read(el)(key), el);\n\n    update(); // Initial\n    const obs = new MutationObserver((m) => {\n      if (m.some(x => x.attributeName === attr)) update();\n    });\n    obs.observe(el, { attributes: true, attributeFilter: [attr] });\n    return () => obs.disconnect();\n  })\n};\n\n/**\n * Observes changes to one or more attributes on an element.\n *\n * Uses MutationObserver to watch for attribute changes. The callback fires\n * whenever any of the specified attributes change, receiving the new value\n * and attribute name. Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses attribute filtering for efficiency. The observer only\n * watches the specified attributes, not all attribute changes.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts attributes and callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const input = document.querySelector('input');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchAttr(input, 'disabled', (value, attrName) => {\n *   console.log(`${attrName} changed to:`, value);\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchAttr(input)('disabled', (value, attrName) => {\n *   console.log(`${attrName} changed to:`, value);\n *   // value is the new attribute value (string | null)\n * });\n *\n * // Watch multiple attributes\n * watchAttr(input)(['value', 'placeholder', 'type'], (value, attrName) => {\n *   console.log(`${attrName} = ${value}`);\n * });\n *\n * // Form validation\n * watchAttr(input)('aria-invalid', (value) => {\n *   if (value === 'true') {\n *     input.classList.add('error');\n *   } else {\n *     input.classList.remove('error');\n *   }\n * });\n *\n * // Sync attributes between elements\n * watchAttr(sourceElement)('title', (value) => {\n *   if (value) targetElement.setAttribute('title', value);\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchAttr(null)('disabled', callback); // () => {}\n * ```\n */\nexport const watchAttr = def((target: Element | null, attrs: string | string[], callback: (val: string | null, attr: string) => void): Unsubscribe => {\n  if (!target) return () => { };\n  const obs = new MutationObserver((muts) => muts.forEach(m => {\n    if (m.attributeName) callback(target.getAttribute(m.attributeName), m.attributeName);\n  }));\n  obs.observe(target, { attributes: true, attributeFilter: Array.isArray(attrs) ? attrs : [attrs] });\n  return () => obs.disconnect();\n});\n\n/**\n * Observes changes to the text content of an element.\n *\n * Uses MutationObserver to watch for text content changes. The callback fires\n * whenever the element's textContent changes, receiving the new text value.\n * Returns a cleanup function to stop observing.\n *\n * **Performance**: Watches both characterData (direct text node changes) and\n * childList (when text nodes are added/removed) with subtree enabled.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts a callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const div = document.querySelector('div');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchText(div, (newText) => {\n *   console.log('Text changed to:', newText);\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchText(div)((newText) => {\n *   console.log('Text changed to:', newText);\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Use in reactive UI\n * const counter = document.querySelector('#counter');\n * watchText(counter)((text) => {\n *   const count = parseInt(text);\n *   if (count > 100) alert('Limit exceeded!');\n * });\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchText(null)(callback); // () => {}\n * ```\n */\nexport const watchText = def((target: Element | null, callback: (text: string) => void): Unsubscribe => {\n  if (!target) return () => { };\n  const obs = new MutationObserver(() => {\n    callback(target.textContent || '');\n  });\n  obs.observe(target, { characterData: true, childList: true, subtree: true });\n  return () => obs.disconnect();\n});\n\n/**\n * Gets or sets an attribute on an element.\n *\n * Overloads:\n * 1. attr(\"data-id\") ‚Äî gets attribute from documentElement\n * 2. attr(el)(\"data-id\") ‚Äî gets attribute from the element\n * 3. attr(el)(\"data-id\", \"123\") ‚Äî sets attribute\n *\n * Getter returns `string | null`\n * Setter returns `void`\n */\nexport function attr(attribute: string): string | null;\nexport function attr(el: Element | null):\n  (attribute: string) => string | null;\nexport function attr(el: Element | null):\n  (attribute: string, value: string) => void;\n\nexport function attr(a: any): any {\n  // Case 1: attr(\"data-id\")\n  if (typeof a === \"string\") {\n    const attribute = a;\n    return document.documentElement.getAttribute(attribute);\n  }\n\n  // Curried case: attr(el)\n  const el: Element | null = a;\n  return (attribute: string, value?: string): any => {\n    if (!el) return value === undefined ? null : undefined;\n    if (value === undefined) {\n      return el.getAttribute(attribute);\n    }\n    el.setAttribute(attribute, value);\n  };\n}\n\n/**\n * Gets or sets a DOM property.\n *\n * Works like `attr` but for real JS properties.\n *\n * Overloads:\n * 1. prop(\"value\") ‚Äî gets from document.documentElement\n * 2. prop(el)(\"value\") ‚Äî getter\n * 3. prop(el)(\"value\", newValue) ‚Äî setter\n *\n * Getter: returns the property type of the element if known.\n * Setter: void\n */\nexport function prop<K extends keyof HTMLElement>(prop: K): HTMLElement[K];\nexport function prop<T extends HTMLElement, K extends keyof T>(\n  el: T | null\n): (prop: K) => T[K];\nexport function prop<T extends HTMLElement, K extends keyof T>(\n  el: T | null\n): (prop: K, value: T[K]) => void;\n\nexport function prop(a: any): any {\n  if (typeof a === \"string\") {\n    const key = a;\n    const el = document.documentElement as any;\n    return el[key];\n  }\n\n  const el = a as HTMLElement | null;\n\n  return (key: any, value?: any): any => {\n    if (!el) return undefined;\n    if (value === undefined) return (el as any)[key];\n    (el as any)[key] = value;\n  };\n}\n\n\n// =============================================================================\n// 8. LIFECYCLE\n// =============================================================================\n\n/**\n * Executes a callback when the DOM is fully loaded and parsed.\n * \n * If the DOM is already ready, the callback executes immediately (synchronously).\n * Otherwise, it waits for the DOMContentLoaded event. This is safer than placing\n * scripts at the end of the body, as it guarantees DOM availability.\n * \n * **Timing Guarantee**: The callback will execute exactly once, either immediately\n * or when DOMContentLoaded fires. External resources (images, stylesheets) may\n * still be loading.\n * \n * **SSR Considerations**: In server-side rendering contexts, ensure this code\n * only runs in the browser (check for `typeof document !== 'undefined'`).\n * \n * @param fn - The callback to execute when the DOM is ready\n * @returns void\n * \n * @example\n * ```typescript\n * // Basic usage\n * onReady(() => {\n *   console.log('DOM is ready!');\n *   const app = document.querySelector('#app');\n *   // Safe to manipulate DOM here\n * });\n * \n * // Initialize app\n * onReady(() => {\n *   const form = document.querySelector('form');\n *   on(form)('submit', handleSubmit);\n *   \n *   const buttons = findAll(document)('button');\n *   buttons.forEach(btn => {\n *     on(btn)('click', handleClick);\n *   });\n * });\n * \n * // Multiple callbacks (each executes independently)\n * onReady(() => console.log('First'));\n * onReady(() => console.log('Second'));\n * \n * // SSR-safe usage\n * if (typeof document !== 'undefined') {\n *   onReady(() => {\n *     // Client-side only code\n *   });\n * }\n * \n * // Difference from window.onload:\n * // - onReady: Fires when DOM is parsed (faster)\n * // - window.onload: Fires when all resources loaded (slower)\n * ```\n */\nexport const onReady = (fn: () => void): void => {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn, { once: true });\n  }\n};\n\n/**\n * Promise-based DOM lifecycle utilities for different timing needs.\n * \n * Type-safe, composable methods for waiting on specific lifecycle phases:\n * - `dom()` ‚Äî waits until DOM is parsed (DOMContentLoaded)\n * - `micro()` ‚Äî waits until microtask queue is empty\n * - `raf()` ‚Äî waits until next requestAnimationFrame\n * \n * @example\n * ```typescript\n * // Wait for DOM to be parsed\n * await ready.dom();\n * const app = document.querySelector('#app');\n * \n * // Wait for microtasks to flush\n * await ready.micro();\n * \n * // Wait for next paint\n * await ready.raf();\n * \n * // Chain multiple lifecycle waits\n * await ready.dom();\n * await ready.micro();\n * await ready.raf();\n * // Now safe to interact with layout\n * ```\n */\nexport const ready = {\n  /**\n   * Waits until the DOM is parsed and interactive (DOMContentLoaded).\n   * Resolves immediately if DOM is already loaded.\n   * \n   * @returns Promise that resolves when DOM is ready\n   */\n  dom: () => new Promise<void>(resolve => {\n    if (document.readyState !== \"loading\") resolve();\n    else document.addEventListener(\"DOMContentLoaded\", () => resolve(), { once: true });\n  }),\n\n  /**\n   * Waits until the microtask queue is flushed (after current JS execution).\n   * Useful for ensuring Promise chains and MutationObserver callbacks have run.\n   * \n   * @returns Promise that resolves on next microtask\n   */\n  micro: () => new Promise<void>(resolve => queueMicrotask(resolve)),\n\n  /**\n   * Waits until the next requestAnimationFrame (next paint cycle).\n   * Useful for deferring layout-dependent code.\n   * \n   * @returns Promise that resolves on next frame\n   */\n  raf: () => new Promise<void>(resolve => requestAnimationFrame(() => resolve()))\n};\n\n/**\n * Observes when elements matching a selector are added to the DOM.\n *\n * Uses MutationObserver to watch for new elements. The handler fires for:\n * 1. Elements already in the DOM (initial check)\n * 2. Elements added dynamically after setup\n *\n * Each element is tracked using WeakSet to prevent duplicate handler calls.\n * Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses WeakSet for O(1) duplicate checking without memory leaks.\n * The observer watches the entire subtree by default.\n *\n * **SPA Navigation**: Perfect for handling dynamically loaded content in single-page\n * applications where elements appear/disappear without full page reloads.\n *\n * @template S - The CSS selector string\n * @param selector - CSS selector to match elements\n * @returns A curried function that accepts handler, root, and once flag\n *\n * @example\n * ```typescript\n * // Imperative (cleaner DX)\n * const cleanup = onMount('.modal', (modal) => {\n *   console.log('Modal added:', modal);\n *   modal.classList.add('initialized');\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = onMount('.modal')((modal) => {\n *   console.log('Modal added:', modal);\n *   modal.classList.add('initialized');\n *\n *   // Setup modal-specific behavior\n *   const closeBtn = modal.querySelector('.close');\n *   on(closeBtn)('click', () => modal.remove());\n * });\n *\n * // Later: stop observing\n * cleanup();\n *\n * // Watch within a specific container\n * const container = document.querySelector('#app');\n * onMount('.dynamic-card')((card) => {\n *   console.log('Card added');\n * }, container);\n *\n * // One-time handler (stops after first match)\n * onMount('#splash-screen')((splash) => {\n *   setTimeout(() => splash.remove(), 3000);\n * }, document, true); // once = true\n *\n * // SPA route handling\n * onMount('[data-page]')((page) => {\n *   const pageName = page.getAttribute('data-page');\n *   console.log('Page loaded:', pageName);\n *\n *   // Initialize page-specific features\n *   initializeAnalytics(pageName);\n *   loadPageData(pageName);\n * });\n *\n * // Lazy-load images as they're added\n * onMount('img[data-src]')((img) => {\n *   const src = img.getAttribute('data-src');\n *   if (src) {\n *     img.setAttribute('src', src);\n *     img.removeAttribute('data-src');\n *   }\n * });\n *\n * // Component initialization pattern\n * onMount('[data-component=\"tooltip\"]')((el) => {\n *   new Tooltip(el); // Initialize tooltip component\n * });\n * ```\n */\nexport const onMount = def((selector: string | null, handler: (el: Element) => void, root: ParentNode = document, once = false): Unsubscribe => {\n  if (!selector) return () => { };\n  const seen = new WeakSet();\n  let foundAny = false;\n  const check = (node: Element) => {\n    if (seen.has(node)) return;\n    if (node.matches(selector)) { seen.add(node); handler(node); foundAny = true; }\n    node.querySelectorAll(selector).forEach(c => {\n      if (!seen.has(c)) { seen.add(c); handler(c); foundAny = true; }\n    });\n  };\n\n  // Initial check\n  root.querySelectorAll(selector).forEach(check);\n\n  const obs = new MutationObserver(muts => muts.forEach(m => {\n    m.addedNodes.forEach(n => { if (n.nodeType === 1) check(n as Element); });\n  }));\n\n  if (once && foundAny) return () => { }; // Already found\n  obs.observe(root, { childList: true, subtree: true });\n  return () => obs.disconnect();\n});\n\n/**\n * Waits for a condition to become true on an element.\n *\n * Returns a Promise that resolves when the predicate returns true. Uses\n * MutationObserver to watch for changes. The predicate is checked immediately,\n * then on every mutation until it returns true.\n *\n * **Timeout Recommendation**: Consider adding a timeout wrapper to prevent\n * infinite waiting:\n * ```typescript\n * Promise.race([\n *   waitFor(el, predicate),\n *   wait(5000).then(() => { throw new Error('Timeout'); })\n * ]);\n * ```\n *\n * **Memory Leak Prevention**: The observer automatically disconnects when the\n * condition is met. If the element is null, the promise never resolves (consider\n * null-checking before calling).\n *\n * @param target - The element to observe (null-unsafe: promise won't resolve if null)\n * @returns A curried function that accepts a predicate and returns a Promise\n *\n * @example\n * ```typescript\n * const button = document.querySelector('button');\n *\n * // Imperative (cleaner DX)\n * await waitFor(button, (el) => el.classList.contains('ready'));\n * console.log('Button is ready!');\n *\n * // Curried (pipeline friendly)\n * await waitFor(button)((el) => el.classList.contains('ready'));\n * console.log('Button is ready!');\n *\n * // Wait for specific attribute value\n * await waitFor(input)((el) => el.getAttribute('data-loaded') === 'true');\n * console.log('Data loaded!');\n *\n * // Wait for child count\n * const list = document.querySelector('ul');\n * await waitFor(list)((el) => el.children.length >= 10);\n * console.log('List has at least 10 items');\n *\n * // Wait for text content\n * await waitFor(status)((el) => el.textContent?.includes('Complete'));\n * console.log('Status is complete');\n *\n * // With timeout (recommended)\n * try {\n *   await Promise.race([\n *     waitFor(element)((el) => el.classList.contains('loaded')),\n *     wait(5000).then(() => { throw new Error('Timeout waiting for element'); })\n *   ]);\n *   console.log('Element loaded in time');\n * } catch (e) {\n *   console.error('Timed out:', e);\n * }\n *\n * // Animation completion\n * element.classList.add('animating');\n * await waitFor(element)((el) => !el.classList.contains('animating'));\n * console.log('Animation complete');\n *\n * // Form validation\n * await waitFor(form)((el) => {\n *   const inputs = el.querySelectorAll('input[required]');\n *   return Array.from(inputs).every(input => input.value.length > 0);\n * });\n * console.log('All required fields filled');\n * ```\n */\nexport const waitFor = def((target: Element | null, predicate: (el: Element) => boolean): Promise<Element> => {\n  return new Promise((resolve) => {\n    if (!target) return;\n    if (predicate(target)) return resolve(target);\n    const obs = new MutationObserver(() => {\n      if (predicate(target)) { obs.disconnect(); resolve(target); }\n    });\n    obs.observe(target, { attributes: true, childList: true, subtree: true, characterData: true });\n  });\n});\n\n\n// =============================================================================\n// 9. UTILS (URL, FORM, ETC)\n// =============================================================================\n\n/**\n * Utilities for working with URL query parameters.\n * \n * Provides a functional API for reading and modifying URL search parameters.\n * Supports both 'soft' navigation (using pushState) and 'hard' navigation\n * (full page reload).\n * \n * **URL Encoding**: Values are automatically URL-encoded when set.\n * \n * @example\n * ```typescript\n * // URL: https://example.com?page=1&sort=name\n * \n * // Get single parameter\n * const page = Params.get('page'); // \"1\"\n * const missing = Params.get('missing'); // null\n * \n * // Get multiple values (for array parameters)\n * // URL: ?tags=js&tags=ts&tags=react\n * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\n * \n * // Set parameter (soft navigation - no reload)\n * Params.set('page')('2')(); // Updates URL without reload\n * // URL becomes: ?page=2&sort=name\n * \n * // Set parameter (hard navigation - full reload)\n * Params.set('page')('2')('hard'); // Reloads page with new URL\n * \n * // Chaining for multiple updates\n * Params.set('page')('1')();\n * Params.set('sort')('date')();\n * Params.set('filter')('active')();\n * ```\n */\nexport const Params = {\n  /**\n   * Gets a single query parameter value.\n   * \n   * @param key - The parameter name\n   * @returns The parameter value or null if not found\n   * \n   * @example\n   * ```typescript\n   * // URL: ?id=123&name=John\n   * const id = Params.get('id'); // \"123\"\n   * const name = Params.get('name'); // \"John\"\n   * const missing = Params.get('missing'); // null\n   * ```\n   */\n  get: (key: string) => new URLSearchParams(window.location.search).get(key),\n\n  /**\n   * Gets all values for a query parameter (for array-like parameters).\n   * \n   * @param key - The parameter name\n   * @returns Array of all values for that parameter\n   * \n   * @example\n   * ```typescript\n   * // URL: ?tags=js&tags=ts&tags=react\n   * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\n   * \n   * // URL: ?filter=active\n   * const filters = Params.getAll('filter'); // [\"active\"]\n   * \n   * // Missing parameter\n   * const missing = Params.getAll('missing'); // []\n   * ```\n   */\n  getAll: (key: string) => new URLSearchParams(window.location.search).getAll(key),\n\n  /**\n   * Sets a query parameter value.\n   * \n   * @param key - The parameter name\n   * @returns A curried function that accepts value and navigation type\n   * \n   * @example\n   * ```typescript\n   * // Soft navigation (no page reload)\n   * Params.set('page')('2')(); // Default: soft\n   * Params.set('page')('2')('soft');\n   * \n   * // Hard navigation (full page reload)\n   * Params.set('page')('2')('hard');\n   * \n   * // Pagination example\n   * const nextPage = () => {\n   *   const current = parseInt(Params.get('page') || '1');\n   *   Params.set('page')(String(current + 1))();\n   * };\n   * \n   * // Filter example\n   * const applyFilter = (filter: string) => {\n   *   Params.set('filter')(filter)();\n   *   Params.set('page')('1')(); // Reset to page 1\n   *   loadData(); // Fetch filtered data\n   * };\n   * ```\n   */\n  set: (key: string) => (val: string) => (type: 'soft' | 'hard' = 'soft') => {\n    const u = new URL(window.location.href);\n    u.searchParams.set(key, val);\n    if (type === 'hard') window.location.href = u.href;\n    else window.history.pushState(null, '', u.href);\n  }\n};\n\n/**\n * Utilities for working with form data.\n * \n * Provides serialization and population of form fields. Automatically handles\n * different input types (text, checkbox, radio, number, select, textarea).\n * \n * **FormData Compatibility**: For native FormData support, use `new FormData(form)`.\n * This utility provides a plain object representation.\n * \n * @example\n * ```typescript\n * const form = document.querySelector('form');\n * \n * // Serialize form to object\n * const data = Form.serialize(form);\n * // { username: \"john\", email: \"john@example.com\", age: 25, subscribe: true }\n * \n * // Populate form from object\n * Form.populate(form)({\n *   username: \"jane\",\n *   email: \"jane@example.com\",\n *   age: 30,\n *   subscribe: false\n * });\n * \n * // Save/load form state\n * const saveForm = () => {\n *   const data = Form.serialize(form);\n *   Local.set('formDraft')(data);\n * };\n * \n * const loadForm = () => {\n *   const data = Local.get('formDraft');\n *   if (data) Form.populate(form)(data);\n * };\n * ```\n */\nexport const Form = {\n  /**\n   * Serializes form inputs into a plain object.\n   * \n   * Handles:\n   * - Text inputs ‚Üí string\n   * - Number inputs ‚Üí number\n   * - Checkboxes ‚Üí boolean\n   * - Radio buttons ‚Üí string (only checked value)\n   * - Select ‚Üí string\n   * - Textarea ‚Üí string\n   * \n   * Only includes inputs with a `name` attribute.\n   * \n   * @param root - The form or container element\n   * @returns Object with field names as keys and values\n   * \n   * @example\n   * ```typescript\n   * const form = document.querySelector('form');\n   * const data = Form.serialize(form);\n   * \n   * // Submit to API\n   * await Http.post('/api/submit')(data);\n   * \n   * // Validate before submit\n   * on(form)('submit', (e) => {\n   *   e.preventDefault();\n   *   const data = Form.serialize(form);\n   *   if (validate(data)) {\n   *     submitForm(data);\n   *   }\n   * });\n   * \n   * // Auto-save draft\n   * const inputs = form.querySelectorAll('input, textarea');\n   * inputs.forEach(input => {\n   *   on(input)('input', debounce(() => {\n   *     const data = Form.serialize(form);\n   *     Local.set('draft')(data);\n   *   }, 500));\n   * });\n   * ```\n   */\n  serialize: (root: HTMLElement | null) => {\n    const data: Record<string, any> = {};\n    if (!root) return data;\n    root.querySelectorAll<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>('input, select, textarea').forEach(el => {\n      if (!el.name) return;\n      if ((el as HTMLInputElement).type === 'checkbox') data[el.name] = (el as HTMLInputElement).checked;\n      else if ((el as HTMLInputElement).type === 'radio') { if ((el as HTMLInputElement).checked) data[el.name] = el.value; }\n      else if ((el as HTMLInputElement).type === 'number') data[el.name] = Number(el.value);\n      else data[el.name] = el.value;\n    });\n    return data;\n  },\n\n  /**\n   * Populates form inputs from a plain object.\n   *\n   * Matches object keys to input `name` attributes and sets values accordingly.\n   *\n   * @param root - The form or container element\n   * @returns A curried function that accepts data object and returns the root\n   *\n   * @example\n   * ```typescript\n   * const form = document.querySelector('form');\n   *\n   * // Imperative (cleaner DX)\n   * Form.populate(form, {\n   *   username: 'john',\n   *   email: 'john@example.com',\n   *   notifications: true\n   * });\n   *\n   * // Curried (pipeline friendly)\n   * Form.populate(form)({\n   *   username: user.username,\n   *   email: user.email,\n   *   bio: user.bio,\n   *   notifications: user.preferences.notifications\n   * });\n   *\n   * // Load saved data\n   * const savedData = Local.get('formData');\n   * if (savedData) Form.populate(form)(savedData);\n   *\n   * // Reset form to defaults\n   * Form.populate(form)({\n   *   theme: 'light',\n   *   language: 'en',\n   *   notifications: true\n   * });\n   * ```\n   */\n  populate: def((root: HTMLElement | null, data: Record<string, any>) => {\n    if (!root) return root;\n    Object.entries(data).forEach(([k, v]) => {\n      const el = root.querySelector(`[name=\"${k}\"]`) as HTMLInputElement;\n      if (!el) return;\n      if (el.type === 'checkbox' || el.type === 'radio') el.checked = !!v;\n      else el.value = String(v);\n    });\n    return root;\n  })\n};\n\n/**\n * Waits for a specified number of milliseconds.\n * \n * Returns a Promise that resolves after the delay. Useful for adding delays\n * in async functions or creating timeouts.\n * \n * @param ms - The number of milliseconds to wait\n * @returns A Promise that resolves after the delay\n * \n * @example\n * ```typescript\n * // Simple delay\n * await wait(1000); // Wait 1 second\n * console.log('Done waiting');\n * \n * // Delay in async function\n * async function showMessage() {\n *   console.log('Loading...');\n *   await wait(2000);\n *   console.log('Done!');\n * }\n * \n * // Animation timing\n * async function animate() {\n *   element.classList.add('fade-in');\n *   await wait(300);\n *   element.classList.remove('fade-in');\n * }\n * \n * // Retry with delay\n * async function retryFetch(url: string, retries = 3) {\n *   for (let i = 0; i < retries; i++) {\n *     try {\n *       return await fetch(url);\n *     } catch (e) {\n *       if (i < retries - 1) await wait(1000 * (i + 1));\n *     }\n *   }\n * }\n * ```\n */\nexport const wait = (ms: number) => new Promise(r => setTimeout(r, ms));\n\n/**\n * Waits for the next animation frame.\n * \n * Returns a Promise that resolves on the next requestAnimationFrame callback.\n * Useful for ensuring DOM updates are rendered before proceeding.\n * \n * @returns A Promise that resolves on the next frame\n * \n * @example\n * ```typescript\n * // Ensure DOM update is rendered\n * element.style.opacity = '0';\n * await nextFrame();\n * element.style.transition = 'opacity 0.3s';\n * element.style.opacity = '1';\n * \n * // Batch DOM reads after writes\n * element.style.width = '100px';\n * await nextFrame();\n * const width = element.offsetWidth; // Avoids layout thrashing\n * \n * // Smooth animation sequence\n * async function animateSequence() {\n *   element.classList.add('step-1');\n *   await nextFrame();\n *   element.classList.add('step-2');\n *   await nextFrame();\n *   element.classList.add('step-3');\n * }\n * ```\n */\nexport const nextFrame = () => new Promise(r => requestAnimationFrame(r));\n\n/** CSS Template Literal for highlighting */\nexport const cssTemplate = (strings: TemplateStringsArray, ...values: any[]) =>\n  strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\n\n// =============================================================================\n// 10. NAVIGATION (TRAVERSAL)\n// =============================================================================\n\n/**\n * Flexible, type-aware DOM traversal utilities.\n *\n * Each method supports three invocation styles:\n *\n * 1. **Element-first** (immediate):\n *    Traverse.next(el)                     ‚Üí Element | null\n *\n * 2. **Selector-first**:\n *    Traverse.next(\".item\")                ‚Üí Element | null\n *\n * 3. **Curried**:\n *    Traverse.next(el)(\"span.highlight\")   ‚Üí Element | null\n *\n * All operations are:\n *   - **Null-safe**: All functions gracefully return `null` or `[]`.\n *   - **Type-preserving**: Passing `HTMLDivElement` returns `HTMLDivElement | null`.\n *   - **Selector-aware**: Passing a selector filters the returned element(s).\n */\nexport const Traverse = {\n  /**\n   * Get the parent element, optionally filtered by a selector.\n   *\n   * @example\n   * // Element-first\n   * const parent = Traverse.parent(el);       // <div> | null\n   *\n   * // Selector-first\n   * const parent = Traverse.parent(\"#child\"); // parent of #child\n   *\n   * // Curried\n   * const specific = Traverse.parent(el)(\".box\");\n   */\n  parent(elOrSelector?: Element | string | null) {\n    if (typeof elOrSelector === \"string\") {\n      const el = document.querySelector(elOrSelector);\n      return el?.parentElement || null;\n    }\n\n    const el = elOrSelector ?? null;\n    return (selector?: string): Element | null => {\n      const parent = el?.parentElement ?? null;\n      if (!parent) return null;\n      return !selector || parent.matches(selector) ? parent : null;\n    };\n  },\n\n  /**\n   * Get the next sibling element.\n   *\n   * @example\n   * Traverse.next(el);            // <li> | null\n   * Traverse.next(\".active\");     // next of .active\n   * Traverse.next(el)(\"button\");  // next button sibling\n   */\n  next(elOrSelector?: Element | string | null) {\n    if (typeof elOrSelector === \"string\") {\n      const el = document.querySelector(elOrSelector);\n      return el?.nextElementSibling || null;\n    }\n\n    const el = elOrSelector ?? null;\n    return (selector?: string): Element | null => {\n      const next = el?.nextElementSibling ?? null;\n      if (!selector || !next) return next;\n      return next.matches(selector) ? next : null;\n    };\n  },\n\n  /**\n   * Get the previous sibling element.\n   *\n   * @example\n   * Traverse.prev(el);\n   * Traverse.prev(\".selected\");\n   * Traverse.prev(el)(\".item\");\n   */\n  prev(elOrSelector?: Element | string | null) {\n    if (typeof elOrSelector === \"string\") {\n      const el = document.querySelector(elOrSelector);\n      return el?.previousElementSibling || null;\n    }\n\n    const el = elOrSelector ?? null;\n    return (selector?: string): Element | null => {\n      const prev = el?.previousElementSibling ?? null;\n      if (!selector || !prev) return prev;\n      return prev.matches(selector) ? prev : null;\n    };\n  },\n\n  /**\n   * Get child elements, with optional selector filtering.\n   *\n   * @example\n   * Traverse.children(el);         // Element[]\n   * Traverse.children(\".list\");    // children of element matching .list\n   * Traverse.children(el)(\"li\");   // only <li> children\n   */\n  children(elOrSelector?: Element | string | null) {\n    if (typeof elOrSelector === \"string\") {\n      const el = document.querySelector(elOrSelector);\n      return el ? Array.from(el.children) : [];\n    }\n\n    const el = elOrSelector ?? null;\n    return (selector?: string): Element[] => {\n      if (!el) return [];\n      const kids = Array.from(el.children);\n      return selector ? kids.filter(c => c.matches(selector)) : kids;\n    };\n  },\n\n  /**\n    * Get sibling elements (excluding the original element).\n    *\n    * @example\n    * Traverse.siblings(el);\n    * Traverse.siblings(\"#active\");\n    * Traverse.siblings(el)(\".item\");\n    */\n  siblings(elOrSelector?: Element | string | null) {\n    if (typeof elOrSelector === \"string\") {\n      const el = document.querySelector(elOrSelector);\n      if (!el?.parentElement) return [];\n      return Array.from(el.parentElement.children).filter(c => c !== el);\n    }\n\n    const el = elOrSelector ?? null;\n    return (selector?: string): Element[] => {\n      if (!el?.parentElement) return [];\n      const sibs = Array.from(el.parentElement.children).filter(s => s !== el);\n      return selector ? sibs.filter(s => s.matches(selector)) : sibs;\n    };\n  },\n\n  /**\n   * Get all ancestor elements up to the document root.\n   *\n   * Optionally stops at an element matching a selector.\n   *\n   * @example\n   * Traverse.parents(el);                  // All ancestors\n   * Traverse.parents(\"#child\");            // Ancestors of #child\n   * Traverse.parents(el, \".section\");      // Ancestors until .section match\n   * Traverse.parents(el)(\".container\");    // Curried: ancestors matching .container\n   */\n  parents(elOrSelector?: Element | string | null, until?: string | ((el: Element) => boolean)): Element[] {\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\n    const result: Element[] = [];\n    let current = el?.parentElement ?? null;\n\n    while (current) {\n      // If until is a string selector\n      if (typeof until === \"string\" && current.matches(until)) {\n        break;\n      }\n      // If until is a function predicate\n      if (typeof until === \"function\" && until(current)) {\n        break;\n      }\n      result.push(current);\n      current = current.parentElement;\n    }\n\n    return result;\n  },\n\n  /**\n   * Get all following sibling elements.\n   *\n   * Optionally filtered by a selector.\n   *\n   * @example\n   * Traverse.nextAll(el);           // All following siblings\n   * Traverse.nextAll(\".selected\");  // Following siblings of .selected\n   * Traverse.nextAll(el)(\".item\");  // Following siblings matching .item\n   */\n  nextAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\n    const result: Element[] = [];\n    let current = el?.nextElementSibling ?? null;\n\n    while (current) {\n      if (!selector || current.matches(selector)) {\n        result.push(current);\n      }\n      current = current.nextElementSibling;\n    }\n\n    return result;\n  },\n\n  /**\n   * Get all preceding sibling elements.\n   *\n   * Optionally filtered by a selector.\n   *\n   * @example\n   * Traverse.prevAll(el);           // All preceding siblings\n   * Traverse.prevAll(\".selected\");  // Preceding siblings of .selected\n   * Traverse.prevAll(el)(\".item\");  // Preceding siblings matching .item\n   */\n  prevAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\n    const result: Element[] = [];\n    let current = el?.previousElementSibling ?? null;\n\n    while (current) {\n      if (!selector || current.matches(selector)) {\n        result.push(current);\n      }\n      current = current.previousElementSibling;\n    }\n\n    return result;\n  },\n\n  /**\n   * Get all ancestors including the element itself, up to document root.\n   *\n   * Optionally filtered by a selector.\n   *\n   * @example\n   * Traverse.closestAll(el);            // Element + all ancestors\n   * Traverse.closestAll(\"#child\");      // Self + ancestors of #child\n   * Traverse.closestAll(el)(\".box\");    // Self + ancestors matching .box\n   */\n  closestAll(elOrSelector?: Element | string | null, selector?: string): Element[] {\n    const el = typeof elOrSelector === \"string\" ? document.querySelector(elOrSelector) : elOrSelector ?? null;\n    const result: Element[] = [];\n    let current: Element | null = el;\n\n    while (current) {\n      if (!selector || current.matches(selector)) {\n        result.push(current);\n      }\n      current = current.parentElement;\n    }\n\n    return result;\n  }\n};\n\n\n// =============================================================================\n// 11. CSS VARIABLES & ANIMATION\n// =============================================================================\n\n/**\n * Utilities for working with CSS custom properties (variables).\n * \n * Provides a functional API for getting and setting CSS variables on elements.\n * Variables can be set at any level (element, :root, etc.) and will cascade\n * according to CSS specificity rules.\n * \n * **Fallback Values**: When getting variables, you can provide fallback values\n * using standard CSS syntax: `var(--color, blue)`.\n * \n * @example\n * ```typescript\n * const element = document.querySelector('.card');\n * \n * // Set CSS variable\n * CssVar.set(element)('--primary-color', '#007bff');\n * CssVar.set(element)('--spacing', '1rem');\n * \n * // Get CSS variable\n * const color = CssVar.get(element)('--primary-color'); // \"#007bff\"\n * \n * // Set on :root for global theme\n * CssVar.set(document.documentElement)('--theme', 'dark');\n * \n * // Dynamic theming\n * const setTheme = (theme: 'light' | 'dark') => {\n *   const root = document.documentElement;\n *   if (theme === 'dark') {\n *     CssVar.set(root)('--bg', '#1a1a1a');\n *     CssVar.set(root)('--text', '#ffffff');\n *   } else {\n *     CssVar.set(root)('--bg', '#ffffff');\n *     CssVar.set(root)('--text', '#000000');\n *   }\n * };\n * ```\n */\nexport const CssVar = {\n  /**\n   * Sets a CSS custom property (variable) on an element.\n   * \n   * @param el - The element to set the variable on (null-safe)\n   * @returns A curried function that accepts name and value, returns the element\n   * \n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   * \n   * // Set single variable\n   * CssVar.set(div)('--color', 'red');\n   * \n   * // Set multiple variables\n   * CssVar.set(div)('--width', '100px');\n   * CssVar.set(div)('--height', '100px');\n   * \n   * // Global theme variables\n   * const root = document.documentElement;\n   * CssVar.set(root)('--primary', '#007bff');\n   * CssVar.set(root)('--secondary', '#6c757d');\n   * \n   * // Dynamic values\n   * CssVar.set(element)('--progress', `${percentage}%`);\n   * \n   * // Null-safe\n   * CssVar.set(null)('--color', 'red'); // Returns null\n   * ```\n   */\n  set: (el: HTMLElement | null) => (name: string, value: string) => {\n    el?.style.setProperty(name, value);\n    return el;\n  },\n\n  /**\n   * Gets the computed value of a CSS custom property.\n   * \n   * Returns the computed value, which may be inherited from a parent element\n   * or :root. The value is trimmed of whitespace.\n   * \n   * @param el - The element to get the variable from (null-safe)\n   * @returns A curried function that accepts name and returns the value\n   * \n   * @example\n   * ```typescript\n   * const div = document.querySelector('div');\n   * \n   * // Get variable value\n   * const color = CssVar.get(div)('--primary-color');\n   * \n   * // Get inherited variable\n   * const spacing = CssVar.get(div)('--spacing'); // May come from parent\n   * \n   * // Use in calculations\n   * const width = parseInt(CssVar.get(element)('--width'));\n   * \n   * // Check if variable is set\n   * const hasTheme = CssVar.get(document.documentElement)('--theme') !== '';\n   * \n   * // Null-safe\n   * CssVar.get(null)('--color'); // \"\"\n   * ```\n   */\n  get: (el: HTMLElement | null) => (name: string) => {\n    return el ? getComputedStyle(el).getPropertyValue(name).trim() : '';\n  }\n};\n\n/**\n * Reads a computed CSS property value from an element.\n * \n * Gets the final computed value of any CSS property, including inherited values,\n * cascaded values, and browser defaults. Useful for reading actual rendered values\n * rather than inline styles.\n * \n * **Unit Parsing**: The returned value includes units (e.g., \"16px\", \"1.5em\").\n * Parse with `parseInt()` or `parseFloat()` if you need numeric values.\n * \n * **Computed vs Inline**: This reads computed styles (what's actually rendered),\n * not inline styles. Use `element.style.property` for inline styles only.\n * \n * @param el - The element to read from (null-safe)\n * @returns A curried function that accepts a property name and returns the value\n * \n * @example\n * ```typescript\n * const div = document.querySelector('div');\n * \n * // Get computed width (includes padding, border if box-sizing)\n * const width = computed(div)('width'); // \"200px\"\n * \n * // Get font size\n * const fontSize = computed(div)('fontSize'); // \"16px\"\n * \n * // Get color (returns rgb/rgba)\n * const color = computed(div)('color'); // \"rgb(0, 0, 0)\"\n * \n * // Parse numeric values\n * const widthNum = parseInt(computed(div)('width')); // 200\n * \n * // Check display state\n * const isHidden = computed(div)('display') === 'none';\n * \n * // Get inherited values\n * const lineHeight = computed(div)('lineHeight');\n * \n * // Null-safe\n * computed(null)('width'); // \"\"\n * ```\n */\nexport const computed = (el: HTMLElement | null) => (prop: keyof CSSStyleDeclaration): string => {\n  if (!el) return '';\n  const value = getComputedStyle(el)[prop];\n  return typeof value === 'string' ? value : String(value);\n};\n\n/**\n * Injects CSS styles into the document.\n * \n * Creates a <style> element with the provided CSS content and appends it to\n * the specified root (defaults to document.head). Returns a cleanup function\n * to remove the styles.\n * \n * **CSP Considerations**: If your site uses Content Security Policy, ensure\n * inline styles are allowed or use nonces/hashes.\n * \n * **Style Precedence**: Injected styles follow normal CSS cascade rules.\n * Later injected styles override earlier ones (if same specificity).\n * \n * **Scoping**: For scoped styles, use a unique class or data attribute as a\n * prefix in your CSS selectors.\n * \n * @param cssContent - The CSS content to inject\n * @param root - The node to append the style element to (defaults to document.head)\n * @returns A cleanup function that removes the injected styles\n * \n * @example\n * ```typescript\n * // Inject global styles\n * const cleanup = injectStyles(`\n *   body { background: #1a1a1a; color: #fff; }\n *   .card { border-radius: 8px; }\n * `);\n * \n * // Later: remove styles\n * cleanup();\n * \n * // Component-specific styles\n * const initModal = () => {\n *   const cleanup = injectStyles(`\n *     .modal { position: fixed; inset: 0; }\n *     .modal-backdrop { background: rgba(0,0,0,0.5); }\n *   `);\n *   \n *   return cleanup; // Return for cleanup when modal is destroyed\n * };\n * \n * // Scoped styles\n * const cleanup = injectStyles(`\n *   [data-theme=\"dark\"] {\n *     --bg: #1a1a1a;\n *     --text: #ffffff;\n *   }\n * `);\n * \n * // Inject into shadow DOM\n * const shadow = element.attachShadow({ mode: 'open' });\n * injectStyles('.component { color: red; }', shadow);\n * \n * // Temporary styles (auto-cleanup)\n * const showHighlight = async () => {\n *   const cleanup = injectStyles('.highlight { background: yellow; }');\n *   await wait(3000);\n *   cleanup(); // Remove after 3 seconds\n * };\n * ```\n */\nexport const injectStyles = (cssContent: string, root: Node = document.head): Unsubscribe => {\n  const style = document.createElement('style');\n  style.textContent = cssContent;\n  root.appendChild(style);\n  return () => style.remove();\n};\n\n/**\n * Waits for a CSS transition or animation to complete.\n * \n * Returns a Promise that resolves when the element's transition or animation\n * ends. Includes a fallback that resolves immediately if no transition/animation\n * is active (duration is 0s or element has display:none).\n * \n * **Fallback Timeout**: The promise includes a built-in fallback that resolves\n * if no transition/animation is detected. For additional safety, wrap in\n * `Promise.race()` with a timeout.\n * \n * **Animation Event Handling**: Listens for both `transitionend` and `animationend`\n * events. Automatically cleans up event listeners when resolved.\n * \n * @param el - The element to wait for (null-safe)\n * @returns A Promise that resolves with the element (or null) when complete\n * \n * @example\n * ```typescript\n * const modal = document.querySelector('.modal');\n * \n * // Wait for fade-in animation\n * modal.classList.add('fade-in');\n * await waitTransition(modal);\n * console.log('Animation complete!');\n * \n * // Smooth hide/remove pattern\n * element.classList.add('fade-out');\n * await waitTransition(element);\n * element.remove(); // Remove after animation\n * \n * // Sequential animations\n * element.classList.add('slide-in');\n * await waitTransition(element);\n * element.classList.add('pulse');\n * await waitTransition(element);\n * element.classList.remove('pulse');\n * \n * // Modal close with animation\n * const closeModal = async (modal: HTMLElement) => {\n *   modal.classList.remove('show');\n *   await waitTransition(modal);\n *   modal.style.display = 'none';\n * };\n * \n * // With timeout safety\n * try {\n *   await Promise.race([\n *     waitTransition(element),\n *     wait(5000).then(() => { throw new Error('Animation timeout'); })\n *   ]);\n * } catch (e) {\n *   console.error('Animation took too long');\n * }\n * \n * // Null-safe\n * await waitTransition(null); // Resolves immediately with null\n * ```\n */\nexport const waitTransition = (el: HTMLElement | null) => new Promise<HTMLElement | null>((resolve) => {\n  if (!el) return resolve(null);\n\n  let resolved = false;\n  let timeoutId: number | undefined;\n\n  const onEnd = () => {\n    if (resolved) return;\n    resolved = true;\n\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\n    el.removeEventListener('transitionend', onEnd);\n    el.removeEventListener('animationend', onEnd);\n    resolve(el);\n  };\n\n  el.addEventListener('transitionend', onEnd);\n  el.addEventListener('animationend', onEnd);\n\n  // Fallback: If no transition happens (e.g. display:none or 0s duration), resolve anyway.\n  requestAnimationFrame(() => {\n    const s = getComputedStyle(el);\n    const transitionDuration = parseFloat(s.transitionDuration) * 1000;\n    const animationDuration = parseFloat(s.animationDuration) * 1000;\n    const maxDuration = Math.max(transitionDuration, animationDuration);\n\n    if (maxDuration === 0) {\n      onEnd();\n    } else {\n      // Safety timeout: duration + 50ms buffer\n      timeoutId = setTimeout(onEnd, maxDuration + 50) as any;\n    }\n  });\n});\n\n\n// =============================================================================\n// 12. OBJECTS & STATE\n// =============================================================================\n\n/**\n * Utilities for working with plain JavaScript objects.\n * \n * Provides functional helpers for common object operations like cloning,\n * equality checking, and key picking/omitting.\n * \n * **Immutability**: These utilities create new objects rather than mutating\n * existing ones, following functional programming principles.\n * \n * **Performance**: For large objects or frequent operations, consider using\n * specialized libraries like Lodash or Ramda.\n * \n * @example\n * ```typescript\n * const user = { id: 1, name: 'John', email: 'john@example.com', role: 'admin' };\n * \n * // Deep clone\n * const userCopy = Obj.clone(user);\n * \n * // Check equality\n * const isSame = Obj.isEqual(user, userCopy); // true\n * \n * // Pick specific keys\n * const publicData = Obj.pick(user, ['id', 'name']); // { id: 1, name: 'John' }\n * \n * // Omit sensitive keys\n * const safeData = Obj.omit(user, ['email', 'role']); // { id: 1, name: 'John' }\n * ```\n */\nexport const Obj = {\n  /**\n   * Creates a deep clone of an object.\n   * \n   * Uses `structuredClone()` if available (modern browsers), falls back to\n   * JSON parse/stringify. Note: JSON fallback doesn't preserve functions,\n   * undefined values, or circular references.\n   * \n   * @template T - The type of the object to clone\n   * @param obj - The object to clone\n   * @returns A deep copy of the object\n   * \n   * @example\n   * ```typescript\n   * const original = { a: 1, b: { c: 2 } };\n   * const copy = Obj.clone(original);\n   * \n   * copy.b.c = 3;\n   * console.log(original.b.c); // 2 (unchanged)\n   * \n   * // Clone arrays\n   * const arr = [1, [2, 3], { a: 4 }];\n   * const arrCopy = Obj.clone(arr);\n   * \n   * // Clone complex objects\n   * const state = {\n   *   user: { id: 1, profile: { name: 'John' } },\n   *   settings: { theme: 'dark', notifications: true }\n   * };\n   * const stateCopy = Obj.clone(state);\n   * ```\n   */\n  clone: <T>(obj: T): T => {\n    try { return structuredClone(obj); }\n    catch { return JSON.parse(JSON.stringify(obj)); }\n  },\n\n  /**\n   * Checks deep equality between two values.\n   * \n   * Compares values recursively. Uses JSON stringification for deep comparison,\n   * so objects with different key orders will be considered different.\n   * \n   * @param a - First value\n   * @param b - Second value\n   * @returns True if values are deeply equal\n   * \n   * @example\n   * ```typescript\n   * // Primitive equality\n   * Obj.isEqual(1, 1); // true\n   * Obj.isEqual('a', 'b'); // false\n   * \n   * // Object equality\n   * Obj.isEqual({ a: 1 }, { a: 1 }); // true\n   * Obj.isEqual({ a: 1, b: 2 }, { b: 2, a: 1 }); // false (different order)\n   * \n   * // Nested objects\n   * Obj.isEqual(\n   *   { user: { name: 'John', age: 30 } },\n   *   { user: { name: 'John', age: 30 } }\n   * ); // true\n   * \n   * // Arrays\n   * Obj.isEqual([1, 2, 3], [1, 2, 3]); // true\n   * Obj.isEqual([1, 2], [2, 1]); // false\n   * ```\n   */\n  isEqual: (a: any, b: any) => a === b || JSON.stringify(a) === JSON.stringify(b),\n\n  /**\n   * Creates a new object with only the specified keys.\n   * \n   * @template T - The object type\n   * @template K - The keys to pick\n   * @param obj - The source object\n   * @param keys - Array of keys to include\n   * @returns A new object with only the specified keys\n   * \n   * @example\n   * ```typescript\n   * const user = {\n   *   id: 1,\n   *   name: 'John',\n   *   email: 'john@example.com',\n   *   password: 'secret',\n   *   role: 'admin'\n   * };\n   * \n   * // Pick public fields\n   * const publicUser = Obj.pick(user, ['id', 'name']);\n   * // { id: 1, name: 'John' }\n   * \n   * // Pick for API response\n   * const apiResponse = Obj.pick(user, ['id', 'name', 'email']);\n   * \n   * // Type-safe picking\n   * type User = typeof user;\n   * const picked: Pick<User, 'id' | 'name'> = Obj.pick(user, ['id', 'name']);\n   * ```\n   */\n  pick: <T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {\n    const ret = {} as Pick<T, K>;\n    keys.forEach(k => { if (k in obj) ret[k] = obj[k]; });\n    return ret;\n  },\n\n  /**\n   * Creates a new object excluding the specified keys.\n   * \n   * @template T - The object type\n   * @template K - The keys to omit\n   * @param obj - The source object\n   * @param keys - Array of keys to exclude\n   * @returns A new object without the specified keys\n   * \n   * @example\n   * ```typescript\n   * const user = {\n   *   id: 1,\n   *   name: 'John',\n   *   email: 'john@example.com',\n   *   password: 'secret',\n   *   role: 'admin'\n   * };\n   * \n   * // Omit sensitive fields\n   * const safeUser = Obj.omit(user, ['password']);\n   * // { id: 1, name: 'John', email: 'john@example.com', role: 'admin' }\n   * \n   * // Omit multiple fields\n   * const publicUser = Obj.omit(user, ['password', 'email', 'role']);\n   * // { id: 1, name: 'John' }\n   * \n   * // Type-safe omitting\n   * type User = typeof user;\n   * const omitted: Omit<User, 'password'> = Obj.omit(user, ['password']);\n   * ```\n   */\n  omit: <T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {\n    const ret = { ...obj };\n    keys.forEach(k => delete ret[k]);\n    return ret as Omit<T, K>;\n  }\n};\n\n\n// =============================================================================\n// 13. COLLECTIONS (BATCHING)\n// =============================================================================\n\n/**\n * Applies a function to each element in a collection.\n * \n * Similar to `Array.forEach()` but works with any iterable or array-like object\n * (NodeList, HTMLCollection, etc.). Returns the array for further processing.\n * \n * **Performance**: For simple iterations, native `forEach()` may be faster.\n * Use this when you need to work with non-array collections or want the return value.\n * \n * **vs forEach**: Unlike `forEach()`, this returns the array, allowing for\n * further chaining or processing.\n * \n * @template T - The element type\n * @param list - The collection to iterate over (null-safe)\n * @returns A curried function that accepts a callback and returns the array\n * \n * @example\n * ```typescript\n * // Work with NodeList\n * const items = document.querySelectorAll('li');\n * batch(items)((el, index) => {\n *   el.dataset.index = String(index);\n *   el.classList.add('processed');\n * });\n * \n * // Work with HTMLCollection\n * const divs = document.getElementsByTagName('div');\n * batch(divs)((div) => {\n *   div.style.opacity = '0.5';\n * });\n * \n * // Remove all matching elements\n * batch(document.querySelectorAll('.temp'))((el) => el.remove());\n * \n * // Add event listeners to multiple elements\n * batch(document.querySelectorAll('button'))((btn, i) => {\n *   on(btn)('click', () => console.log('Button', i, 'clicked'));\n * });\n * \n * // Chain with other operations\n * const elements = batch(items)((el) => el.classList.add('active'));\n * console.log('Processed', elements.length, 'elements');\n * \n * // Null-safe\n * batch(null)((el) => console.log(el)); // Returns []\n * ```\n */\nexport const batch = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\n  return (fn: (el: T, index: number) => void): T[] => {\n    if (!list) return [];\n    const arr = Array.from(list);\n    arr.forEach(fn);\n    return arr;\n  };\n};\n\n/**\n * Groups elements by a key function.\n * \n * Creates an object where keys are the result of the key function and values\n * are arrays of elements that produced that key. Useful for categorizing or\n * organizing collections of elements.\n * \n * **Type Inference**: The key function should return a string. For better type\n * safety, consider using a union of string literals as the return type.\n * \n * **Memory Considerations**: For very large collections, consider processing\n * in chunks or using a Map instead of a plain object.\n * \n * @template T - The element type\n * @param list - The collection to group (null-safe)\n * @returns A curried function that accepts a key function and returns grouped object\n * \n * @example\n * ```typescript\n * // Group by data attribute\n * const items = document.querySelectorAll('[data-category]');\n * const byCategory = groupBy(items)(el => el.dataset.category || 'uncategorized');\n * // { electronics: [...], clothing: [...], uncategorized: [...] }\n * \n * // Group by tag name\n * const elements = document.querySelectorAll('*');\n * const byTag = groupBy(elements)(el => el.tagName.toLowerCase());\n * // { div: [...], span: [...], button: [...], ... }\n * \n * // Group by class presence\n * const allDivs = document.querySelectorAll('div');\n * const byStatus = groupBy(allDivs)(el => \n *   el.classList.contains('active') ? 'active' : 'inactive'\n * );\n * \n * // Process groups\n * Object.entries(byCategory).forEach(([category, elements]) => {\n *   console.log(`${category}: ${elements.length} items`);\n *   elements.forEach(el => el.classList.add(`category-${category}`));\n * });\n * \n * // Group form inputs by type\n * const inputs = document.querySelectorAll('input');\n * const byType = groupBy(inputs)(input => input.type);\n * // { text: [...], email: [...], checkbox: [...], ... }\n * \n * // Null-safe\n * groupBy(null)(el => 'key'); // {}\n * ```\n */\nexport const groupBy = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\n  return (keyFn: (el: T) => string): Record<string, T[]> => {\n    const groups: Record<string, T[]> = {};\n    if (!list) return groups;\n    Array.from(list).forEach(el => {\n      const k = keyFn(el);\n      (groups[k] = groups[k] || []).push(el);\n    });\n    return groups;\n  };\n};\n\n\n// =============================================================================\n// 14. COMPONENT REFS\n// =============================================================================\n\n/**\n * Collects elements with `data-ref` attributes into a typed object.\n * \n * Scans the root element for children with `data-ref` attributes and creates\n * an object mapping ref names to elements. Useful for component-based patterns\n * where you need quick access to specific child elements.\n * \n * **Generic Ref Map**: For type-safe ref access, define an interface for your\n * expected refs and cast the result.\n * \n * **Duplicate Handling**: If multiple elements have the same ref name, only\n * the last one is kept. Use `groupRefs()` if you need all duplicates.\n * \n * @param root - The root element to search within (null-safe)\n * @returns Object mapping ref names to elements\n * \n * @example\n * ```typescript\n * // HTML:\n * // <form>\n * //   <input data-ref=\"username\" />\n * //   <input data-ref=\"email\" />\n * //   <button data-ref=\"submit\">Submit</button>\n * // </form>\n * \n * const form = document.querySelector('form');\n * const { username, email, submit } = refs(form);\n * \n * // Type-safe access\n * on(submit)('click', () => {\n *   const data = {\n *     username: (username as HTMLInputElement).value,\n *     email: (email as HTMLInputElement).value\n *   };\n *   console.log(data);\n * });\n * \n * // Component pattern\n * interface ModalRefs {\n *   title: HTMLElement;\n *   content: HTMLElement;\n *   closeBtn: HTMLElement;\n * }\n * \n * const modal = document.querySelector('.modal');\n * const r = refs(modal) as unknown as ModalRefs;\n * \n * modify(r.title)({ text: 'Welcome!' });\n * on(r.closeBtn)('click', () => modal.remove());\n * \n * // Null-safe\n * refs(null); // {}\n * ```\n */\nexport const refs = (root: ParentNode | null): Record<string, HTMLElement> => {\n  const r: Record<string, HTMLElement> = {};\n  if (root) {\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\n      if (el.dataset.ref) r[el.dataset.ref] = el;\n    });\n  }\n  return r;\n};\n\n/**\n * Collects elements with `data-ref` attributes into arrays.\n * \n * Like `refs()` but allows multiple elements with the same ref name. Each ref\n * name maps to an array of all elements with that ref.\n * \n * **Array Typing**: All refs are arrays, even if only one element exists.\n * This ensures consistent access patterns.\n * \n * **Duplicate Handling**: Unlike `refs()`, this preserves all elements with\n * the same ref name in document order.\n * \n * @param root - The root element to search within (null-safe)\n * @returns Object mapping ref names to arrays of elements\n * \n * @example\n * ```typescript\n * // HTML:\n * // <ul>\n * //   <li data-ref=\"item\">Item 1</li>\n * //   <li data-ref=\"item\">Item 2</li>\n * //   <li data-ref=\"item\">Item 3</li>\n * //   <button data-ref=\"action\">Delete All</button>\n * // </ul>\n * \n * const list = document.querySelector('ul');\n * const { item, action } = groupRefs(list);\n * \n * console.log(item.length); // 3\n * console.log(action.length); // 1\n * \n * // Process all items\n * item.forEach((el, index) => {\n *   el.dataset.index = String(index);\n * });\n * \n * // Add listeners to all items\n * item.forEach(el => {\n *   on(el)('click', () => console.log('Item clicked'));\n * });\n * \n * // Single action button (still an array)\n * on(action[0])('click', () => {\n *   item.forEach(el => el.remove());\n * });\n * \n * // Null-safe\n * groupRefs(null); // {}\n * ```\n */\nexport const groupRefs = (root: ParentNode | null): Record<string, HTMLElement[]> => {\n  const r: Record<string, HTMLElement[]> = {};\n  if (root) {\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\n      const k = el.dataset.ref;\n      if (k) (r[k] = r[k] || []).push(el);\n    });\n  }\n  return r;\n};\n\n\n// =============================================================================\n// 15. COLOR UTILS\n// =============================================================================\n\n/**\n * Converts a color to a specific color space.\n * \n * Uses CSS `color-mix()` to convert colors between color spaces like sRGB,\n * Display P3, etc. Requires a browser environment and modern browser support.\n * \n * **Browser Support**: Requires support for `color-mix()` function (modern browsers).\n * Check compatibility before using in production.\n * \n * **Color Space Literal Types**: Common values include 'srgb', 'display-p3',\n * 'rec2020', 'a98-rgb', 'prophoto-rgb'.\n * \n * @param color - The color to convert (any valid CSS color)\n * @param space - The target color space (defaults to 'srgb')\n * @returns The color in the specified color space\n * \n * @example\n * ```typescript\n * // Convert to Display P3 (wider gamut)\n * const p3Blue = toColorSpace('blue', 'display-p3');\n * \n * // Convert hex to P3\n * const p3Red = toColorSpace('#ff0000', 'display-p3');\n * \n * // Convert named color\n * const p3Green = toColorSpace('green', 'display-p3');\n * \n * // Use in dynamic theming\n * const primaryColor = '#007bff';\n * const p3Primary = toColorSpace(primaryColor, 'display-p3');\n * CssVar.set(document.documentElement)('--primary-p3', p3Primary);\n * \n * // Check browser support\n * try {\n *   const converted = toColorSpace('red', 'display-p3');\n *   console.log('P3 supported:', converted);\n * } catch (e) {\n *   console.log('P3 not supported, using fallback');\n * }\n * ```\n */\nexport const toColorSpace = (color: string, space: string = 'srgb'): string => {\n  const div = document.createElement('div');\n  div.style.color = `color-mix(in ${space}, ${color} 100%, transparent)`;\n  document.body.appendChild(div);\n  const res = getComputedStyle(div).color;\n  div.remove();\n  return res;\n};\n\n// =============================================================================\n// 16. CLASS CYCLING & STATE MACHINES\n// =============================================================================\n\n/**\n * Creates a function that cycles through a list of CSS classes.\n * \n * Returns a function that, when called, removes the current class and adds\n * the next one in the list. Useful for state machines, loading indicators,\n * or any cyclical UI states.\n * \n * **State Machine Type Inference**: For better type safety, define your states\n * as a const array with `as const` assertion.\n * \n * **State Persistence**: The current state is tracked internally. If you need\n * to persist state across page reloads, store the current index in localStorage.\n * \n * @param target - The element to cycle classes on (null-safe)\n * @returns A curried function that accepts class array and returns cycle function\n * \n * @example\n * ```typescript\n * const button = document.querySelector('button');\n * \n * // Loading states\n * const nextState = cycleClass(button)(['idle', 'loading', 'success', 'error']);\n * \n * on(button)('click', async () => {\n *   nextState(); // idle -> loading\n *   try {\n *     await fetchData();\n *     nextState(); // loading -> success\n *   } catch (e) {\n *     nextState(); // success -> error (or loading -> error)\n *   }\n * });\n * \n * // Traffic light simulation\n * const light = document.querySelector('.traffic-light');\n * const nextLight = cycleClass(light)(['red', 'yellow', 'green']);\n * setInterval(nextLight, 2000); // Cycle every 2 seconds\n * \n * // Theme cycling\n * const themeBtn = document.querySelector('.theme-toggle');\n * const cycleTheme = cycleClass(document.documentElement)(\n *   ['theme-light', 'theme-dark', 'theme-auto']\n * );\n * on(themeBtn)('click', cycleTheme);\n * \n * // Animation states\n * const box = document.querySelector('.box');\n * const animate = cycleClass(box)(['bounce', 'shake', 'pulse', 'spin']);\n * on(box)('click', animate);\n * \n * // Null-safe\n * const noop = cycleClass(null)(['a', 'b']); // Returns () => {}\n * ```\n */\nexport const cycleClass = (target: Element | null) => {\n  return (classes: string[]): (() => void) => {\n    if (!target) return () => { };\n\n    return () => {\n      const currentIdx = classes.findIndex(c => target.classList.contains(c));\n\n      // Remove current class if found\n      if (currentIdx > -1) target.classList.remove(classes[currentIdx]);\n\n      // Add next class\n      const nextIdx = (currentIdx + 1) % classes.length;\n      target.classList.add(classes[nextIdx]);\n    };\n  };\n};\n\n// =============================================================================\n// 17. CLEANUP & TEMPLATES\n// =============================================================================\n\n/**\n * Removes all event listeners from an element by cloning it.\n * \n * Creates a clone of the element and replaces the original with the clone.\n * This effectively removes ALL event listeners (both those added via\n * addEventListener and inline handlers). The element type is preserved.\n * \n * **Side Effects**: This is a destructive operation that removes ALL listeners,\n * including those you may want to keep. Use with caution.\n * \n * **Memory Leak Prevention**: Useful when you need to completely reset an\n * element's event handlers, especially with third-party libraries that may\n * have attached listeners you can't easily remove.\n * \n * @template T - The element type (preserved in return)\n * @param element - The element to strip listeners from (null-safe)\n * @returns The cloned element with no listeners, or null\n * \n * @example\n * ```typescript\n * const button = document.querySelector('button');\n * \n * // Add some listeners\n * button.addEventListener('click', handler1);\n * button.addEventListener('click', handler2);\n * button.onclick = handler3;\n * \n * // Remove ALL listeners\n * const cleanButton = stripListeners(button);\n * // cleanButton has no listeners, but same content/attributes\n * \n * // Use case: Reset third-party widget\n * const widget = document.querySelector('.third-party-widget');\n * const cleanWidget = stripListeners(widget);\n * // Now you can attach your own listeners\n * \n * // Use case: Memory leak cleanup\n * const oldElement = document.querySelector('.leaky');\n * const fresh = stripListeners(oldElement);\n * // Old listeners are garbage collected\n * \n * // Null-safe\n * stripListeners(null); // Returns null\n * \n * // Note: Element must have a parent\n * const orphan = document.createElement('div');\n * stripListeners(orphan); // Returns orphan unchanged (no parent)\n * ```\n */\nexport const stripListeners = <T extends Element>(element: T | null): T | null => {\n  if (!element || !element.parentNode) return element;\n  const copy = element.cloneNode(true) as T;\n  element.replaceWith(copy);\n  return copy;\n};\n\n/**\n * Instantiates a <template> element by ID or reference.\n * \n * Clones the template's content and optionally applies properties to the\n * first element in the fragment. Returns a DocumentFragment that can be\n * appended to the DOM.\n * \n * **Template Pattern**: Templates are great for reusable HTML structures.\n * Define once in HTML, instantiate many times in JavaScript.\n * \n * **Prop Application**: Properties are applied only to the first element child\n * in the fragment. For complex templates, use refs or selectors after appending.\n * \n * @param templateOrSelector - Template element or selector string\n * @returns A curried function that accepts props and returns a DocumentFragment\n * @throws Error if template is not found or invalid\n * \n * @example\n * ```typescript\n * // HTML:\n * // <template id=\"card-template\">\n * //   <div class=\"card\">\n * //     <h3 class=\"title\"></h3>\n * //     <p class=\"description\"></p>\n * //   </div>\n * // </template>\n * \n * // Instantiate template\n * const card = instantiate('#card-template')({\n *   class: { featured: true },\n *   dataset: { id: '123' }\n * });\n * \n * append(container)(card);\n * \n * // Multiple instances\n * const cards = [\n *   { title: 'Card 1', id: '1' },\n *   { title: 'Card 2', id: '2' },\n *   { title: 'Card 3', id: '3' }\n * ].map(data => {\n *   const card = instantiate('#card-template')({\n *     dataset: { id: data.id }\n *   });\n *   // Modify after instantiation\n *   const title = card.querySelector('.title');\n *   if (title) title.textContent = data.title;\n *   return card;\n * });\n * \n * // Use with template reference\n * const template = document.querySelector('#row-template') as HTMLTemplateElement;\n * const row = instantiate(template)({ class: { new: true } });\n * \n * // No props\n * const simple = instantiate('#simple-template')();\n * ```\n */\nexport const instantiate = (templateOrSelector: string | HTMLTemplateElement) => {\n  return (rootProps: ElementProps = {}): DocumentFragment => {\n    const tpl = typeof templateOrSelector === 'string'\n      ? document.querySelector(templateOrSelector) as HTMLTemplateElement\n      : templateOrSelector;\n\n    if (!tpl || !('content' in tpl)) {\n      throw new Error(`instantiate: Invalid template '${templateOrSelector}'`);\n    }\n\n    const content = tpl.content.cloneNode(true) as DocumentFragment;\n\n    // Apply props to the first actual element in the fragment\n    if (Object.keys(rootProps).length > 0 && content.firstElementChild) {\n      modify(content.firstElementChild as HTMLElement)(rootProps);\n    }\n\n    return content;\n  };\n};\n\n/**\n * Creates multiple deep clones of a node.\n * \n * Useful for creating skeleton screens, placeholder lists, or any scenario\n * where you need multiple copies of the same element structure.\n * \n * **Deep Cloning**: Each clone includes all descendants and their attributes,\n * but NOT event listeners.\n * \n * @param element - The node to clone (null-safe)\n * @returns A curried function that accepts count and returns array of clones\n * \n * @example\n * ```typescript\n * const template = document.querySelector('.card-template');\n * \n * // Create 5 skeleton cards\n * const skeletons = cloneMany(template)(5);\n * skeletons.forEach(card => append(container)(card));\n * \n * // Loading placeholders\n * const placeholder = document.querySelector('.placeholder');\n * const placeholders = cloneMany(placeholder)(10);\n * append(list)(...placeholders);\n * \n * // Generate list items\n * const listItem = el('li')({ class: { item: true } })([]);\n * const items = cloneMany(listItem)(20);\n * items.forEach((item, i) => {\n *   modify(item)({ text: `Item ${i + 1}` });\n * });\n * append(ul)(...items);\n * \n * // Null-safe\n * cloneMany(null)(5); // Returns []\n * ```\n */\nexport const cloneMany = (element: Node | null) => {\n  return (count: number): Node[] => {\n    if (!element) return [];\n    return Array.from({ length: count }).map(() => element.cloneNode(true));\n  };\n};\n\n// =============================================================================\n// 18. GEOMETRY & DIMENSIONS\n// =============================================================================\n\n/**\n * Gets the bounding client rectangle of an element.\n * \n * Returns a DOMRect with position and size information. Safe for null elements\n * (returns an empty rect at origin). The rect is relative to the viewport.\n * \n * **Reflow Considerations**: Reading layout properties like this triggers a reflow.\n * Batch reads together and separate from writes for better performance.\n * \n * @param element - The element to get bounds for (null-safe)\n * @returns DOMRect with position and size, or empty rect if null\n * \n * @example\n * ```typescript\n * const div = document.querySelector('div');\n * const bounds = rect(div);\n * \n * console.log(bounds.width, bounds.height);\n * console.log(bounds.top, bounds.left);\n * console.log(bounds.right, bounds.bottom);\n * \n * // Check if element is in viewport\n * const inViewport = (\n *   bounds.top >= 0 &&\n *   bounds.left >= 0 &&\n *   bounds.bottom <= window.innerHeight &&\n *   bounds.right <= window.innerWidth\n * );\n * \n * // Calculate center point\n * const centerX = bounds.left + bounds.width / 2;\n * const centerY = bounds.top + bounds.height / 2;\n * \n * // Null-safe\n * rect(null); // DOMRect(0, 0, 0, 0)\n * ```\n */\nexport const rect = (element: Element | null): DOMRect => {\n  return element ? element.getBoundingClientRect() : new DOMRect(0, 0, 0, 0);\n};\n\n/**\n * Gets the element's position relative to the document.\n * \n * Returns the absolute position from the top-left of the document, accounting\n * for scroll position. Unlike `getBoundingClientRect()`, this gives document\n * coordinates, not viewport coordinates.\n * \n * **Viewport Calculation**: Adds current scroll position to viewport coordinates.\n * \n * @param element - The element to get position for (null-safe)\n * @returns Object with top and left coordinates, or {0, 0} if null\n * \n * @example\n * ```typescript\n * const element = document.querySelector('.target');\n * const pos = offset(element);\n * \n * console.log('Distance from document top:', pos.top);\n * console.log('Distance from document left:', pos.left);\n * \n * // Scroll to element position\n * window.scrollTo({\n *   top: pos.top - 100, // 100px offset from top\n *   behavior: 'smooth'\n * });\n * \n * // Calculate distance between elements\n * const pos1 = offset(element1);\n * const pos2 = offset(element2);\n * const distance = Math.sqrt(\n *   Math.pow(pos2.left - pos1.left, 2) +\n *   Math.pow(pos2.top - pos1.top, 2)\n * );\n * \n * // Null-safe\n * offset(null); // { top: 0, left: 0 }\n * ```\n */\nexport const offset = (element: HTMLElement | null) => {\n  if (!element) return { top: 0, left: 0 };\n  const box = element.getBoundingClientRect();\n  const doc = document.documentElement;\n  return {\n    top: box.top + window.scrollY - doc.clientTop,\n    left: box.left + window.scrollX - doc.clientLeft\n  };\n};\n\n/**\n * Checks if an element is visible in the DOM.\n * \n * An element is considered visible if it has non-zero dimensions (width or height).\n * This checks if the element consumes space in the layout, not if it's actually\n * in the viewport or has `visibility: visible`.\n * \n * **Note**: This doesn't check `visibility`, `opacity`, or viewport position.\n * It only checks if the element has layout dimensions.\n * \n * @param element - The element to check (null-safe)\n * @returns True if element has non-zero width or height\n * \n * @example\n * ```typescript\n * const element = document.querySelector('.target');\n * \n * if (isVisible(element)) {\n *   console.log('Element is rendered');\n * }\n * \n * // Check before animating\n * if (isVisible(element)) {\n *   element.classList.add('animate');\n * }\n * \n * // Hidden elements return false\n * element.style.display = 'none';\n * isVisible(element); // false\n * \n * // Zero-sized elements return false\n * element.style.width = '0';\n * element.style.height = '0';\n * isVisible(element); // false\n * \n * // Null-safe\n * isVisible(null); // false\n * ```\n */\nexport const isVisible = (element: HTMLElement | null): boolean => {\n  return !!(element && (element.offsetWidth > 0 || element.offsetHeight > 0));\n};\n\n\n// =============================================================================\n// 19. SCROLL & FOCUS\n// =============================================================================\n\n/**\n * Scrolls an element into view.\n * \n * Uses the native `scrollIntoView()` API with customizable options. Returns\n * the element for chaining. Defaults to smooth scrolling with 'start' alignment.\n * \n * **Accessibility**: Ensure focus management accompanies scrolling for keyboard users.\n * \n * **Browser Differences**: Smooth scrolling may not work in all browsers.\n * The behavior gracefully degrades to instant scrolling.\n * \n * @param element - The element to scroll into view (null-safe)\n * @returns A curried function that accepts options and returns the element\n * \n * @example\n * ```typescript\n * const section = document.querySelector('#section-3');\n * \n * // Smooth scroll to element\n * scrollInto(section)();\n * \n * // Custom options\n * scrollInto(section)({\n *   behavior: 'smooth',\n *   block: 'center',\n *   inline: 'nearest'\n * });\n * \n * // Instant scroll\n * scrollInto(section)({ behavior: 'auto' });\n * \n * // Scroll to bottom of element\n * scrollInto(section)({ block: 'end' });\n * \n * // Navigation with scroll\n * on(navLink)('click', (e) => {\n *   e.preventDefault();\n *   const target = document.querySelector(navLink.hash);\n *   scrollInto(target)();\n *   focus(target)(); // Also focus for accessibility\n * });\n * \n * // Null-safe\n * scrollInto(null)(); // No-op, returns null\n * ```\n */\nexport const scrollInto = (element: Element | null) => {\n  return (options: ScrollIntoViewOptions = { behavior: 'smooth', block: 'start' }) => {\n    element?.scrollIntoView(options);\n    return element;\n  };\n};\n\n/**\n * Sets focus on an element.\n * \n * Safely focuses an element with optional focus options. Returns the element\n * for chaining. Null-safe.\n * \n * **Accessibility**: Essential for keyboard navigation and screen readers.\n * Always ensure focusable elements have visible focus indicators.\n * \n * @param element - The element to focus (null-safe)\n * @returns A curried function that accepts options and returns the element\n * \n * @example\n * ```typescript\n * const input = document.querySelector('input');\n * \n * // Basic focus\n * focus(input)();\n * \n * // Prevent scroll on focus\n * focus(input)({ preventScroll: true });\n * \n * // Focus after modal opens\n * const modal = document.querySelector('.modal');\n * modal.classList.add('open');\n * const firstInput = modal.querySelector('input');\n * focus(firstInput)();\n * \n * // Focus management in forms\n * on(form)('submit', (e) => {\n *   e.preventDefault();\n *   const firstError = form.querySelector('.error');\n *   if (firstError) {\n *     scrollInto(firstError)();\n *     focus(firstError)();\n *   }\n * });\n * \n * // Null-safe\n * focus(null)(); // No-op, returns null\n * ```\n */\nexport const focus = (element: HTMLElement | null) => {\n  return (options?: FocusOptions) => {\n    element?.focus(options);\n    return element;\n  };\n};\n\n/**\n * Removes focus from an element.\n * \n * Blurs the element, removing keyboard focus. Returns the element for chaining.\n * \n * **Accessibility**: Use carefully - removing focus can disorient keyboard users.\n * Usually better to move focus to another element rather than blur.\n * \n * @param element - The element to blur (null-safe)\n * @returns The element\n * \n * @example\n * ```typescript\n * const input = document.querySelector('input');\n * \n * // Remove focus\n * blur(input);\n * \n * // Close dropdown on blur\n * on(dropdown)('blur', () => {\n *   dropdown.classList.remove('open');\n * });\n * \n * // Validate on blur\n * on(input)('blur', () => {\n *   if (!input.value) {\n *     input.classList.add('error');\n *   }\n * });\n * \n * // Null-safe\n * blur(null); // No-op, returns null\n * ```\n */\nexport const blur = (element: HTMLElement | null) => {\n  element?.blur();\n  return element;\n};\n\n\n// =============================================================================\n// 20. TIMING UTILS (DEBOUNCE / THROTTLE)\n// =============================================================================\n\n/**\n * Debounces a function, delaying execution until after a pause in calls.\n * \n * Creates a debounced version of the function that delays invoking until after\n * `ms` milliseconds have elapsed since the last time it was called. Perfect for\n * handling rapid events like typing, resizing, or scrolling.\n * \n * @template T - The function type to debounce\n * @param fn - The function to debounce\n * @param ms - The number of milliseconds to delay\n * @returns A debounced version of the function\n * \n * @example\n * ```typescript\n * // Search as user types (waits for pause)\n * const searchInput = document.querySelector('input');\n * const performSearch = debounce((query: string) => {\n *   console.log('Searching for:', query);\n *   // API call here\n * }, 300);\n * \n * on(searchInput)('input', (e) => {\n *   performSearch((e.target as HTMLInputElement).value);\n * });\n * \n * // Auto-save after user stops typing\n * const autoSave = debounce((content: string) => {\n *   localStorage.setItem('draft', content);\n *   console.log('Saved!');\n * }, 1000);\n * \n * on(textarea)('input', (e) => {\n *   autoSave((e.target as HTMLTextAreaElement).value);\n * });\n * \n * // Window resize handler\n * const handleResize = debounce(() => {\n *   console.log('Window resized to:', window.innerWidth);\n *   // Expensive layout calculations here\n * }, 250);\n * \n * on(window)('resize', handleResize);\n * ```\n */\nexport const debounce = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return (...args: Parameters<T>): void => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), ms);\n  };\n};\n\n/**\n * Throttles a function, limiting how often it can be called.\n * \n * Creates a throttled version that only invokes the function at most once per\n * `ms` milliseconds. Unlike debounce, throttle ensures the function is called\n * regularly during continuous events. Perfect for scroll, mousemove, or other\n * high-frequency events.\n * \n * @template T - The function type to throttle\n * @param fn - The function to throttle\n * @param ms - The minimum time between calls in milliseconds\n * @returns A throttled version of the function\n * \n * @example\n * ```typescript\n * // Scroll progress indicator (updates max once per 16ms)\n * const updateScrollProgress = throttle(() => {\n *   const scrollPercent = (window.scrollY / document.body.scrollHeight) * 100;\n *   progressBar.style.width = `${scrollPercent}%`;\n * }, 16); // ~60fps\n * \n * on(window)('scroll', updateScrollProgress);\n * \n * // Mouse tracking (limits updates)\n * const trackMouse = throttle((e: MouseEvent) => {\n *   console.log('Mouse at:', e.clientX, e.clientY);\n *   // Update parallax effect, etc.\n * }, 50);\n * \n * on(document)('mousemove', trackMouse);\n * \n * // Infinite scroll (check max once per 200ms)\n * const checkInfiniteScroll = throttle(() => {\n *   const scrollBottom = window.scrollY + window.innerHeight;\n *   if (scrollBottom >= document.body.scrollHeight - 100) {\n *     loadMoreItems();\n *   }\n * }, 200);\n * \n * on(window)('scroll', checkInfiniteScroll);\n * \n * // Difference from debounce:\n * // - Debounce: Waits for pause, then executes once\n * // - Throttle: Executes regularly during continuous events\n * ```\n */\nexport const throttle = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\n  let lastTime = 0;\n  return (...args: Parameters<T>): void => {\n    const now = Date.now();\n    if (now - lastTime >= ms) {\n      fn(...args);\n      lastTime = now;\n    }\n  };\n};\n\n// =============================================================================\n// 21. WEB STORAGE (LOCAL & SESSION)\n// =============================================================================\n\n/**\n * Factory for creating typed storage wrappers.\n * \n * Creates storage utilities that automatically handle JSON serialization/deserialization.\n * Used internally to create `Local` and `Session` storage objects.\n * \n * **Generic Type Inference**: Use type parameters for type-safe storage access.\n * \n * **Schema Validation**: For production apps, consider adding schema validation\n * to ensure stored data matches expected types.\n * \n * **Quota Limits**: Most browsers limit localStorage to ~5-10MB. Check quota\n * before storing large amounts of data.\n * \n * **Error Handling**: Storage operations can fail (quota exceeded, private browsing).\n * Wrap in try-catch for production use.\n * \n * @param provider - The Storage object (localStorage or sessionStorage)\n * @returns Object with get, set, remove, and clear methods\n */\nconst createStorage = (provider: Storage) => ({\n  /**\n   * Gets a value from storage and parses it.\n   * \n   * Attempts to parse as JSON. If parsing fails, returns the raw string.\n   * Returns null if the key doesn't exist.\n   * \n   * @template T - The expected type of the stored value\n   * @param key - The storage key\n   * @returns The parsed value or null\n   * \n   * @example\n   * ```typescript\n   * // Get with type inference\n   * interface User { id: number; name: string; }\n   * const user = Local.get<User>('user');\n   * \n   * // Get primitive\n   * const count = Local.get<number>('count');\n   * \n   * // Get with fallback\n   * const theme = Local.get<string>('theme') || 'light';\n   * ```\n   */\n  get: <T>(key: string): T | null => {\n    const val = provider.getItem(key);\n    if (!val) return null;\n    try { return JSON.parse(val) as T; }\n    catch { return val as unknown as T; }\n  },\n\n  /**\n   * Sets a value in storage (auto-stringifies objects).\n   * \n   * Objects are JSON stringified. Primitives are converted to strings.\n   * \n   * @param key - The storage key\n   * @returns A curried function that accepts the value\n   * \n   * @example\n   * ```typescript\n   * // Store object\n   * Local.set('user')({ id: 1, name: 'John' });\n   * \n   * // Store primitive\n   * Local.set('count')(42);\n   * Local.set('theme')('dark');\n   * \n   * // Error handling\n   * try {\n   *   Local.set('largeData')(hugeObject);\n   * } catch (e) {\n   *   console.error('Storage quota exceeded');\n   * }\n   * ```\n   */\n  set: (key: string) => (value: any): void => {\n    const val = typeof value === 'object' ? JSON.stringify(value) : String(value);\n    provider.setItem(key, val);\n  },\n\n  /**\n   * Removes a key from storage.\n   * \n   * @param key - The storage key to remove\n   * \n   * @example\n   * ```typescript\n   * Local.remove('user');\n   * Session.remove('tempData');\n   * ```\n   */\n  remove: (key: string) => provider.removeItem(key),\n\n  /**\n   * Clears all storage.\n   * \n   * **Warning**: This removes ALL keys from the storage, not just those\n   * created by your app. Use with caution.\n   * \n   * @example\n   * ```typescript\n   * // Clear all localStorage\n   * Local.clear();\n   * \n   * // Clear session storage\n   * Session.clear();\n   * ```\n   */\n  clear: () => provider.clear()\n});\n\n/**\n * localStorage wrapper with automatic JSON serialization.\n * \n * Provides type-safe access to localStorage with automatic parsing/stringification.\n * Data persists across browser sessions until explicitly cleared.\n * \n * **Quota Limits**: ~5-10MB in most browsers. Check `navigator.storage.estimate()`\n * for available quota.\n * \n * **Error Handling**: Can throw QuotaExceededError. Wrap in try-catch for production.\n * \n * @example\n * ```typescript\n * // Store user data\n * interface User { id: number; name: string; email: string; }\n * const user: User = { id: 1, name: 'John', email: 'john@example.com' };\n * Local.set('user')(user);\n * \n * // Retrieve user data\n * const savedUser = Local.get<User>('user');\n * if (savedUser) {\n *   console.log(savedUser.name);\n * }\n * \n * // Store app settings\n * Local.set('settings')({\n *   theme: 'dark',\n *   language: 'en',\n *   notifications: true\n * });\n * \n * // Remove item\n * Local.remove('tempData');\n * \n * // Clear all\n * Local.clear();\n * ```\n */\nexport const Local = createStorage(window.localStorage);\n/**\n * sessionStorage wrapper with automatic JSON serialization.\n * \n * Provides type-safe access to sessionStorage. Data persists only for the\n * current browser session (tab). Cleared when the tab is closed.\n * \n * **Use Cases**: Temporary data, form drafts, wizard state, tab-specific settings.\n * \n * **Quota Limits**: Similar to localStorage (~5-10MB).\n * \n * @example\n * ```typescript\n * // Store temporary form data\n * Session.set('formDraft')({\n *   name: 'John',\n *   email: 'john@example.com',\n *   message: 'Hello...'\n * });\n * \n * // Retrieve on page reload\n * const draft = Session.get('formDraft');\n * if (draft) {\n *   Form.populate(form)(draft);\n * }\n * \n * // Multi-step wizard\n * Session.set('wizardStep')(2);\n * Session.set('wizardData')({ step1: {...}, step2: {...} });\n * \n * // Clear on completion\n * Session.remove('wizardStep');\n * Session.remove('wizardData');\n * ```\n */\nexport const Session = createStorage(window.sessionStorage);\n\n\n// =============================================================================\n// 22. COOKIES\n// =============================================================================\n\n/**\n * Utilities for working with browser cookies.\n * \n * Provides a simple API for getting, setting, and removing cookies with\n * automatic URL encoding/decoding.\n * \n * **Security**: Cookies are sent with every request to the domain. Use `secure`\n * and `httpOnly` flags for sensitive data. Consider using localStorage for\n * client-side only data.\n * \n * **Size Limits**: Cookies are limited to ~4KB per cookie, ~20 cookies per domain.\n * \n * @example\n * ```typescript\n * // Set a cookie\n * Cookie.set('theme')('dark')({ days: 30 });\n * \n * // Get a cookie\n * const theme = Cookie.get('theme'); // \"dark\"\n * \n * // Remove a cookie\n * Cookie.remove('theme');\n * ```\n */\nexport const Cookie = {\n  /**\n   * Gets a cookie value by name.\n   * \n   * Returns the decoded cookie value or null if not found.\n   * \n   * @param name - The cookie name\n   * @returns The decoded cookie value or null\n   * \n   * @example\n   * ```typescript\n   * const token = Cookie.get('auth_token');\n   * if (token) {\n   *   // User is authenticated\n   * }\n   * \n   * const userId = Cookie.get('user_id');\n   * const preferences = Cookie.get('prefs');\n   * ```\n   */\n  get: (name: string): string | null => {\n    const v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');\n    return v ? decodeURIComponent(v[2]) : null;\n  },\n\n  /**\n   * Sets a cookie with optional expiration and security settings.\n   * \n   * **Security Options**:\n   * - `secure`: Only send over HTTPS (recommended for production)\n   * - `path`: Limit cookie to specific path (defaults to '/')\n   * - `days`: Expiration in days (omit for session cookie)\n   * \n   * @param name - The cookie name\n   * @returns A curried function that accepts value and options\n   * \n   * @example\n   * ```typescript\n   * // Session cookie (expires when browser closes)\n   * Cookie.set('session_id')('abc123')();\n   * \n   * // Persistent cookie (7 days)\n   * Cookie.set('theme')('dark')({ days: 7 });\n   * \n   * // Secure cookie (HTTPS only)\n   * Cookie.set('auth_token')('secret')({ days: 1, secure: true });\n   * \n   * // Path-specific cookie\n   * Cookie.set('admin_pref')('value')({ path: '/admin', days: 30 });\n   * \n   * // Remember me (1 year)\n   * Cookie.set('remember')('true')({ days: 365 });\n   * ```\n   */\n  set: (name: string) => (value: string) => (options: { days?: number, path?: string, secure?: boolean } = {}) => {\n    let d = new Date();\n    d.setTime(d.getTime() + 24 * 60 * 60 * 1000 * (options.days || 0));\n    document.cookie = `${name}=${encodeURIComponent(value)}`\n      + `;path=${options.path || '/'}`\n      + (options.days ? `;expires=${d.toUTCString()}` : '')\n      + (options.secure ? ';secure' : '');\n  },\n\n  /**\n   * Removes a cookie by setting its expiration to the past.\n   * \n   * @param name - The cookie name to remove\n   * \n   * @example\n   * ```typescript\n   * // Logout: remove auth cookie\n   * Cookie.remove('auth_token');\n   * \n   * // Clear preferences\n   * Cookie.remove('theme');\n   * Cookie.remove('language');\n   * ```\n   */\n  remove: (name: string) => {\n    Cookie.set(name)('')({ days: -1 });\n  }\n};\n\n\n// =============================================================================\n// 23. NETWORK (FETCH WRAPPER)\n// =============================================================================\n\n/**\n * HTTP utilities - A lightweight, functional wrapper around the Fetch API.\n * \n * Provides type-safe HTTP methods with automatic JSON handling, error checking,\n * and a curried API for flexible composition.\n * \n * **Error Handling**: All methods throw on non-2xx responses. Wrap in try-catch\n * for production use.\n * \n * **CORS Considerations**: \n * - Credentials are not included by default. Add `credentials: 'include'` to headers for cookies.\n * - Preflight requests (OPTIONS) are handled automatically by the browser.\n * - Server must set appropriate CORS headers (Access-Control-Allow-Origin, etc.).\n * \n * **Type Safety**: Use generic type parameters for response typing.\n * \n * @example\n * ```typescript\n * // Define response types\n * interface User { id: number; name: string; email: string; }\n * interface ApiError { error: string; code: number; }\n * \n * // GET with type safety\n * try {\n *   const user = await Http.get<User>('/api/user/123');\n *   console.log(user.name);\n * } catch (error) {\n *   console.error('Failed to fetch user:', error);\n * }\n * \n * // POST with curried API\n * const response = await Http.post('/api/users')\n *   ({ name: 'John', email: 'john@example.com' })\n *   ({ 'Authorization': 'Bearer token123' });\n * \n * // Error handling with typed responses\n * try {\n *   const data = await Http.get<User>('/api/user');\n * } catch (err) {\n *   if (err instanceof Error) {\n *     // Parse error message for status code\n *     if (err.message.includes('404')) {\n *       console.log('User not found');\n *     }\n *   }\n * }\n * \n * // Retry pattern\n * async function fetchWithRetry<T>(\n *   url: string,\n *   maxRetries = 3,\n *   delay = 1000\n * ): Promise<T> {\n *   for (let i = 0; i < maxRetries; i++) {\n *     try {\n *       return await Http.get<T>(url);\n *     } catch (error) {\n *       if (i === maxRetries - 1) throw error;\n *       await wait(delay * (i + 1)); // Exponential backoff\n *     }\n *   }\n *   throw new Error('Max retries exceeded');\n * }\n * \n * // CORS with credentials\n * const data = await Http.get<User>(\n *   'https://api.example.com/user',\n *   { 'credentials': 'include' } as any\n * );\n * ```\n */\n\n\n\n// =============================================================================\n// 24. SERVICE WORKER\n// =============================================================================\n\n/**\n * Service Worker utilities for Progressive Web Apps (PWAs).\n * \n * Provides helpers for registering service workers, handling updates, and\n * communicating with the service worker.\n * \n * **Browser Support**: Check for 'serviceWorker' in navigator before using.\n * \n * **Lifecycle Events**:\n * 1. **Installing**: Service worker is being installed\n * 2. **Installed/Waiting**: New version is waiting to activate\n * 3. **Activating**: Service worker is taking control\n * 4. **Activated**: Service worker is controlling the page\n * \n * **Update Strategy**: Service workers update when:\n * - User navigates to a page in scope\n * - An event like push/sync occurs\n * - You call `registration.update()`\n * \n * @example\n * ```typescript\n * // Basic registration\n * const registration = await SW.register('/sw.js');\n * if (registration) {\n *   console.log('Service worker registered');\n * }\n * \n * // Handle updates\n * const reg = await SW.register('/sw.js');\n * if (reg) {\n *   reg.addEventListener('updatefound', () => {\n *     const newWorker = reg.installing;\n *     newWorker?.addEventListener('statechange', () => {\n *       if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n *         // New version available\n *         if (confirm('New version available! Reload?')) {\n *           window.location.reload();\n *         }\n *       }\n *     });\n *   });\n * }\n * \n * // Send message to service worker\n * SW.post({ type: 'CACHE_CLEAR' });\n * SW.post({ type: 'SKIP_WAITING' });\n * ```\n */\nexport const SW = {\n  /**\n   * Registers a service worker script.\n   * \n   * **Registration Scope**: By default, the scope is the directory containing\n   * the service worker file. You can override this in registration options.\n   * \n   * **Update Check**: The browser checks for updates to the service worker\n   * script on navigation. Byte-for-byte comparison is used.\n   * \n   * **Error Handling**: Returns null if registration fails or if service workers\n   * are not supported. Check the return value before using.\n   * \n   * @param scriptPath - Path to the service worker script (e.g., '/sw.js')\n   * @param options - Optional registration options\n   * @returns Promise resolving to ServiceWorkerRegistration or null\n   * \n   * @example\n   * ```typescript\n   * // Basic registration\n   * const reg = await SW.register('/sw.js');\n   * if (reg) {\n   *   console.log('SW registered with scope:', reg.scope);\n   * }\n   * \n   * // Custom scope\n   * const reg = await SW.register('/sw.js', { scope: '/app/' });\n   * \n   * // Check for updates manually\n   * const reg = await SW.register('/sw.js');\n   * if (reg) {\n   *   // Check for updates every hour\n   *   setInterval(() => reg.update(), 60 * 60 * 1000);\n   * }\n   * \n   * // Listen for lifecycle events\n   * const reg = await SW.register('/sw.js');\n   * if (reg) {\n   *   // New service worker installing\n   *   reg.addEventListener('updatefound', () => {\n   *     const installing = reg.installing;\n   *     console.log('New service worker installing...');\n   *     \n   *     installing?.addEventListener('statechange', () => {\n   *       console.log('State changed to:', installing.state);\n   *       // States: installing, installed, activating, activated, redundant\n   *     });\n   *   });\n   * }\n   * \n   * // Skip waiting and activate immediately\n   * const reg = await SW.register('/sw.js');\n   * if (reg?.waiting) {\n   *   // Tell waiting SW to skip waiting\n   *   SW.post({ type: 'SKIP_WAITING' });\n   * }\n   * \n   * // Unregister service worker\n   * const reg = await SW.register('/sw.js');\n   * if (reg) {\n   *   await reg.unregister();\n   *   console.log('Service worker unregistered');\n   * }\n   * ```\n   */\n  register: async (\n    scriptPath: string,\n    options?: RegistrationOptions\n  ): Promise<ServiceWorkerRegistration | null> => {\n    if ('serviceWorker' in navigator) {\n      try {\n        const reg = await navigator.serviceWorker.register(scriptPath, options);\n        return reg;\n      } catch (e) {\n        //console.error('SW Registration Failed:', e);\n        return null;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Posts a message to the active service worker.\n   * \n   * **Controller**: The \"controller\" is the service worker that controls the\n   * current page. It's null if no service worker is active.\n   * \n   * **Message Format**: Use a consistent message format with a `type` field\n   * for routing in the service worker.\n   * \n   * **Response Handling**: To receive responses, listen for 'message' events\n   * on navigator.serviceWorker.\n   * \n   * @param message - The message to send (typically an object with a 'type' field)\n   * \n   * @example\n   * ```typescript\n   * // Clear cache\n   * SW.post({ type: 'CACHE_CLEAR' });\n   * \n   * // Skip waiting (activate new service worker immediately)\n   * SW.post({ type: 'SKIP_WAITING' });\n   * \n   * // Custom message with data\n   * SW.post({\n   *   type: 'CACHE_URLS',\n   *   urls: ['/page1.html', '/page2.html']\n   * });\n   * \n   * // Two-way communication\n   * // Send message\n   * SW.post({ type: 'GET_CACHE_SIZE' });\n   * \n   * // Listen for response\n   * navigator.serviceWorker.addEventListener('message', (event) => {\n   *   if (event.data.type === 'CACHE_SIZE') {\n   *     console.log('Cache size:', event.data.size);\n   *   }\n * });\n   * \n   * // Sync data when online\n   * SW.post({\n   *   type: 'SYNC_DATA',\n   *   data: { userId: 123, updates: [...] }\n   * });\n   * \n   * // Check if controller exists before posting\n   * if (navigator.serviceWorker?.controller) {\n   *   SW.post({ type: 'PING' });\n   * } else {\n   *   console.log('No active service worker');\n   * }\n   * ```\n   */\n  post: (message: any) => {\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message);\n    }\n  }\n};\n\n// =============================================================================\n// 25. EVENT LIFECYCLE & CLEANUP (LISTENER GROUPS)\n// =============================================================================\n\n/**\n * Creates a manager for grouping multiple event listeners and subscriptions.\n * \n * Essential for preventing memory leaks in Single Page Applications (SPAs)\n * and component-based architectures. Allows batch cleanup of all listeners\n * when a component unmounts or a feature is disabled.\n * \n * **Use Cases**:\n * - React useEffect cleanup\n * - Vue onUnmounted hooks\n * - Modal/dialog lifecycle management\n * - Feature toggle cleanup\n * - Page navigation cleanup\n * \n * **Memory Leak Prevention**: Always call `clear()` when the component/feature\n * is destroyed to prevent memory leaks from orphaned event listeners.\n * \n * @returns Object with `add` and `clear` methods for managing subscriptions\n * \n * @example\n * ```typescript\n * // Basic usage\n * const group = createListenerGroup();\n * \n * // Add multiple listeners\n * group.add(on(button)('click', handleClick));\n * group.add(on(window)('resize', handleResize));\n * group.add(on(document)('keydown', handleKeydown));\n * \n * // Later: cleanup all at once\n * group.clear(); // Removes all 3 listeners\n * \n * // React integration\n * function MyComponent() {\n *   useEffect(() => {\n *     const listeners = createListenerGroup();\n *     \n *     listeners.add(on(button)('click', handleClick));\n *     listeners.add(on(window)('scroll', handleScroll));\n *     listeners.add(Data.bind(element)('count', handleCountChange));\n *     \n *     // Cleanup on unmount\n *     return () => listeners.clear();\n *   }, []);\n * }\n * \n * // Vue 3 Composition API\n * import { onUnmounted } from 'vue';\n * \n * export default {\n *   setup() {\n *     const listeners = createListenerGroup();\n *     \n *     listeners.add(on(button.value)('click', handleClick));\n *     listeners.add(on(window)('resize', handleResize));\n *     \n *     onUnmounted(() => {\n *       listeners.clear();\n *     });\n *   }\n * }\n * \n * // Modal lifecycle\n * class Modal {\n *   private listeners = createListenerGroup();\n *   \n *   open() {\n *     this.listeners.add(on(this.closeBtn)('click', () => this.close()));\n *     this.listeners.add(on(this.overlay)('click', () => this.close()));\n *     this.listeners.add(on(document)('keydown', (e) => {\n *       if (e.key === 'Escape') this.close();\n *     }));\n *   }\n *   \n *   close() {\n *     this.listeners.clear(); // Clean up all listeners\n *     remove(this.element);\n *   }\n * }\n * \n * // Feature toggle\n * const featureListeners = createListenerGroup();\n * \n * function enableFeature() {\n *   featureListeners.add(on(button)('click', featureHandler));\n *   featureListeners.add(watchClass(element)('active', handleActiveChange));\n * }\n * \n * function disableFeature() {\n *   featureListeners.clear(); // Remove all feature listeners\n * }\n * \n * // Page navigation cleanup\n * let currentPageListeners = createListenerGroup();\n * \n * function navigateTo(page: string) {\n *   // Clean up previous page\n *   currentPageListeners.clear();\n *   \n *   // Set up new page\n *   currentPageListeners = createListenerGroup();\n *   currentPageListeners.add(on(pageElement)('click', handlePageClick));\n *   // ... more listeners\n * }\n * \n * // Combining with other cleanup\n * const group = createListenerGroup();\n * \n * // Add regular listeners\n * group.add(on(button)('click', handler));\n * \n * // Add custom cleanup logic\n * group.add(() => {\n *   console.log('Custom cleanup');\n *   clearInterval(intervalId);\n *   cancelAnimationFrame(rafId);\n * });\n * \n * group.clear(); // Runs all cleanup functions\n * ```\n */\nexport const createListenerGroup = () => {\n  const unsubs: Unsubscribe[] = [];\n  return {\n    /**\n     * Registers a cleanup function or unsubscribe callback.\n     * \n     * @param fn - The cleanup function to register\n     * \n     * @example\n     * ```typescript\n     * const group = createListenerGroup();\n     * \n     * // Add event listener cleanup\n     * group.add(on(button)('click', handler));\n     * \n     * // Add observer cleanup\n     * group.add(watchClass(element)('active', callback));\n     * \n     * // Add custom cleanup\n     * group.add(() => {\n     *   clearTimeout(timeoutId);\n     *   worker.terminate();\n     * });\n     * ```\n     */\n    add: (fn: Unsubscribe) => {\n      unsubs.push(fn);\n    },\n\n    /**\n     * Executes all registered cleanup functions and clears the list.\n     * \n     * **Order**: Cleanup functions are called in the order they were added.\n     * \n     * **Idempotent**: Safe to call multiple times - subsequent calls do nothing.\n     * \n     * @example\n     * ```typescript\n     * const group = createListenerGroup();\n     * group.add(on(btn)('click', handler));\n     * group.add(on(window)('resize', resizeHandler));\n     * \n     * group.clear(); // Removes both listeners\n     * group.clear(); // Safe to call again - does nothing\n     * ```\n     */\n    clear: () => {\n      unsubs.forEach(fn => fn());\n      unsubs.length = 0;\n    }\n  };\n};\n\n\n// =============================================================================\n// 26. SIGNALS & CONTROLLERS (ABORTCONTROLLER)\n// =============================================================================\n\n/**\n * AbortController and AbortSignal utilities for cancellable operations.\n * \n * Provides helpers for creating abort signals, timeout signals, and wrapping\n * promises with cancellation support. Essential for managing async operations\n * that may need to be cancelled (fetch requests, animations, long computations).\n * \n * **Use Cases**:\n * - Cancel fetch requests when component unmounts\n * - Timeout long-running operations\n * - Cancel animations or intervals\n * - Abort expensive computations\n * \n * **Signal Composition**: Multiple operations can share the same signal,\n * allowing batch cancellation.\n * \n * @example\n * ```typescript\n * // Basic cancellation\n * const { signal, abort } = Signal.create();\n * fetch('/api/data', { signal });\n * // Later: abort the request\n * abort();\n * \n * // Timeout pattern\n * const timeoutSignal = Signal.timeout(5000);\n * try {\n *   const data = await fetch('/api/slow', { signal: timeoutSignal });\n * } catch (error) {\n *   if (error.name === 'AbortError') {\n *     console.log('Request timed out');\n *   }\n * }\n * \n * // Wrap non-fetch promises\n * const { signal, abort } = Signal.create();\n * const result = await Signal.wrap(\n *   longRunningComputation(),\n *   signal\n * );\n * ```\n */\nexport const Signal = {\n  /**\n   * Creates a new AbortController and returns its signal and abort function.\n   * \n   * **Pattern**: Destructure to get both signal and abort function.\n   * \n   * **Cleanup**: Call abort() to cancel all operations using this signal.\n   * \n   * @returns Object with `signal` (AbortSignal) and `abort` function\n   * \n   * @example\n   * ```typescript\n   * // Basic usage\n   * const { signal, abort } = Signal.create();\n   * \n   * fetch('/api/users', { signal })\n   *   .then(res => res.json())\n   *   .catch(err => {\n   *     if (err.name === 'AbortError') {\n   *       console.log('Request was cancelled');\n   *     }\n   *   });\n   * \n   * // Cancel the request\n   * abort();\n   * \n   * // React component cleanup\n   * function UserList() {\n   *   useEffect(() => {\n   *     const { signal, abort } = Signal.create();\n   *     \n   *     fetch('/api/users', { signal })\n   *       .then(res => res.json())\n   *       .then(setUsers);\n   *     \n   *     return () => abort(); // Cancel on unmount\n   *   }, []);\n   * }\n   * \n   * // Multiple operations with same signal\n   * const { signal, abort } = Signal.create();\n   * \n   * Promise.all([\n   *   fetch('/api/users', { signal }),\n   *   fetch('/api/posts', { signal }),\n   *   fetch('/api/comments', { signal })\n   * ]);\n   * \n   * // Abort all three requests at once\n   * abort();\n   * \n   * // Conditional abort\n   * const { signal, abort } = Signal.create();\n   * const button = document.querySelector('button');\n   * \n   * on(button)('click', () => {\n   *   fetch('/api/data', { signal });\n   * });\n   * \n   * on(button)('click', () => {\n   *   abort(); // Cancel if clicked again\n   * });\n   * ```\n   */\n  create: () => {\n    const c = new AbortController();\n    return { signal: c.signal, abort: () => c.abort() };\n  },\n\n  /**\n   * Creates an AbortSignal that automatically aborts after a timeout.\n   * \n   * **Browser Support**: Uses native `AbortSignal.timeout()` if available,\n   * falls back to manual implementation for older browsers.\n   * \n   * **Use Case**: Prevent operations from running indefinitely.\n   * \n   * @param ms - Timeout in milliseconds\n   * @returns An AbortSignal that aborts after the specified time\n   * \n   * @example\n   * ```typescript\n   * // Timeout fetch request after 5 seconds\n   * try {\n   *   const response = await fetch('/api/data', {\n   *     signal: Signal.timeout(5000)\n   *   });\n   *   const data = await response.json();\n   * } catch (error) {\n   *   if (error.name === 'AbortError') {\n   *     console.log('Request timed out after 5 seconds');\n   *   }\n   * }\n   * \n   * // Different timeouts for different endpoints\n   * const fastEndpoint = fetch('/api/fast', {\n   *   signal: Signal.timeout(1000)\n   * });\n   * \n   * const slowEndpoint = fetch('/api/slow', {\n   *   signal: Signal.timeout(10000)\n   * });\n   * \n   * // Timeout with fallback\n   * async function fetchWithFallback(url: string) {\n   *   try {\n   *     return await fetch(url, { signal: Signal.timeout(3000) });\n   *   } catch (error) {\n   *     if (error.name === 'AbortError') {\n   *       // Return cached data or default\n   *       return getCachedData(url);\n   *     }\n   *     throw error;\n   *   }\n   * }\n   * \n   * // Timeout for non-fetch operations\n   * const result = await Signal.wrap(\n   *   expensiveComputation(),\n   *   Signal.timeout(5000)\n   * );\n   * ```\n   */\n  timeout: (ms: number): AbortSignal => {\n    // Use native if available, fallback for older browsers\n    if ('timeout' in AbortSignal) return AbortSignal.timeout(ms);\n    const c = new AbortController();\n    setTimeout(() => c.abort(), ms);\n    return c.signal;\n  },\n\n  /**\n   * Wraps a Promise to make it abortable via an AbortSignal.\n   * \n   * **Behavior**: If the signal aborts, the promise rejects with AbortError.\n   * The original promise continues running but its result is ignored.\n   * \n   * **Error Handling**: Always check for `error.name === 'AbortError'` to\n   * distinguish cancellation from other errors.\n   * \n   * @template T - The promise result type\n   * @param promise - The promise to wrap\n   * @param signal - Optional AbortSignal to control cancellation\n   * @returns The wrapped promise that can be cancelled\n   * \n   * @example\n   * ```typescript\n   * // Wrap async function\n   * const { signal, abort } = Signal.create();\n   * \n   * async function processData() {\n   *   await wait(1000);\n   *   return { result: 'done' };\n   * }\n   * \n   * const result = await Signal.wrap(processData(), signal);\n   * \n   * // Cancel before completion\n   * setTimeout(() => abort(), 500);\n   * \n   * // Timeout pattern\n   * try {\n   *   const result = await Signal.wrap(\n   *     longComputation(),\n   *     Signal.timeout(5000)\n   *   );\n   * } catch (error) {\n   *   if (error.name === 'AbortError') {\n   *     console.log('Computation timed out');\n   *   }\n * }\n   * \n   * // Animation loop with cancellation\n   * async function animateWithCancel(signal: AbortSignal) {\n   *   for (let i = 0; i < 100; i++) {\n   *     if (signal.aborted) break;\n   *     await Signal.wrap(nextFrame(), signal);\n   *     element.style.opacity = String(i / 100);\n   *   }\n   * }\n   * \n   * const { signal, abort } = Signal.create();\n   * animateWithCancel(signal);\n   * // Later: abort()\n   * \n   * // Race with timeout\n   * const { signal, abort } = Signal.create();\n   * \n   * try {\n   *   const result = await Promise.race([\n   *     Signal.wrap(fetchData(), signal),\n   *     wait(5000).then(() => { throw new Error('Timeout'); })\n   *   ]);\n   * } catch (error) {\n   *   console.error('Failed or timed out:', error);\n   * }\n   * \n   * // Cleanup on abort\n   * const { signal, abort } = Signal.create();\n   * \n   * signal.addEventListener('abort', () => {\n   *   console.log('Operation cancelled, cleaning up...');\n   *   cleanup();\n   * });\n   * \n   * await Signal.wrap(operation(), signal);\n   * ```\n   */\n  wrap: <T>(promise: Promise<T>, signal?: AbortSignal): Promise<T> => {\n    if (!signal) return promise;\n    if (signal.aborted) return Promise.reject(new DOMException('Aborted', 'AbortError'));\n\n    return new Promise((resolve, reject) => {\n      const abortHandler = () => {\n        reject(new DOMException('Aborted', 'AbortError'));\n        signal.removeEventListener('abort', abortHandler);\n      };\n\n      signal.addEventListener('abort', abortHandler);\n\n      promise.then(\n        val => { signal.removeEventListener('abort', abortHandler); resolve(val); },\n        err => { signal.removeEventListener('abort', abortHandler); reject(err); }\n      );\n    });\n  }\n};\n\n\n// =============================================================================\n// 27. APP-WIDE PUB/SUB (TYPED EVENT BUS)\n// =============================================================================\n\n/**\n * Creates a strongly-typed event bus for application-wide communication.\n * \n * Provides a type-safe pub/sub system using native EventTarget under the hood.\n * Perfect for decoupling components without the overhead of heavy state\n * management libraries.\n * \n * **Type Safety**: Define your event map as a type parameter for full\n * IntelliSense support and compile-time checking.\n * \n * **vs Native Events**: Unlike DOM events, this provides:\n * - Type-safe event names and payloads\n * - No DOM dependency (works anywhere)\n * - Simpler API focused on pub/sub patterns\n * \n * **Performance**: Uses native EventTarget, so it's as fast as DOM events.\n * \n * **Memory**: Remember to unsubscribe when components unmount to prevent leaks.\n * \n * @template Events - Event map type: `{ eventName: payloadType }`\n * @returns Object with `on`, `emit`, and `once` methods\n * \n * @example\n * ```typescript\n * // Define event types\n * interface AppEvents {\n *   'user:login': { id: number; name: string; };\n *   'user:logout': void;\n *   'cart:add': { productId: string; quantity: number; };\n *   'cart:remove': { productId: string; };\n *   'notification:show': { message: string; type: 'success' | 'error'; };\n * }\n * \n * // Create typed bus\n * const bus = createBus<AppEvents>();\n * \n * // Subscribe with full type safety\n * const unsubscribe = bus.on('user:login', (data) => {\n *   console.log(`User ${data.name} logged in`); // data is typed!\n *   updateUI(data.id);\n * });\n * \n * // Emit events\n * bus.emit('user:login', { id: 123, name: 'John' });\n * bus.emit('user:logout'); // void events don't need data\n * \n * // Cleanup\n * unsubscribe();\n * \n * // One-time listeners\n * bus.once('user:login', (data) => {\n *   console.log('First login:', data.name);\n *   // Automatically unsubscribes after first call\n * });\n * \n * // Cross-component communication\n * // Component A\n * bus.on('cart:add', ({ productId, quantity }) => {\n *   updateCartUI(productId, quantity);\n *   showNotification(`Added ${quantity} items`);\n * });\n * \n * // Component B\n * function addToCart(productId: string, qty: number) {\n *   bus.emit('cart:add', { productId, quantity: qty });\n * }\n * \n * // React integration\n * function CartBadge() {\n *   const [count, setCount] = useState(0);\n *   \n *   useEffect(() => {\n *     const unsub1 = bus.on('cart:add', ({ quantity }) => {\n *       setCount(c => c + quantity);\n *     });\n *     \n *     const unsub2 = bus.on('cart:remove', () => {\n *       setCount(c => c - 1);\n *     });\n *     \n *     return () => {\n *       unsub1();\n *       unsub2();\n *     };\n *   }, []);\n *   \n *   return <span>{count}</span>;\n * }\n * \n * // Global notification system\n * const notifications = createBus<{\n *   show: { message: string; type: 'info' | 'success' | 'error'; };\n *   hide: void;\n * }>();\n * \n * notifications.on('show', ({ message, type }) => {\n *   const toast = createToast(message, type);\n *   append(document.body)(toast);\n * });\n * \n * // Anywhere in your app\n * notifications.emit('show', {\n *   message: 'Saved successfully!',\n *   type: 'success'\n * });\n * ```\n */\nexport const createBus = <Events extends Record<string, any>>() => {\n  const target = new EventTarget();\n\n  return {\n    /**\n     * Subscribes to an event.\n     * \n     * **Type Safety**: Event name and data are fully typed based on the Events map.\n     * \n     * **Cleanup**: Always store and call the returned unsubscribe function to\n     * prevent memory leaks.\n     * \n     * @template K - Event name (inferred from Events)\n     * @param event - The event name to listen for\n     * @param handler - Callback function receiving typed event data\n     * @returns Unsubscribe function to remove the listener\n     * \n     * @example\n     * ```typescript\n     * interface Events {\n     *   'data:updated': { id: number; value: string; };\n     * }\n     * \n     * const bus = createBus<Events>();\n     * \n     * // Subscribe\n     * const unsub = bus.on('data:updated', (data) => {\n     *   console.log(`Data ${data.id} = ${data.value}`);\n     * });\n     * \n     * // Unsubscribe\n     * unsub();\n     * \n     * // Multiple subscribers\n     * const unsub1 = bus.on('data:updated', updateUI);\n     * const unsub2 = bus.on('data:updated', logChange);\n     * const unsub3 = bus.on('data:updated', syncToServer);\n     * \n     * // Cleanup all\n     * [unsub1, unsub2, unsub3].forEach(fn => fn());\n     * ```\n     */\n    on: <K extends keyof Events & string>(\n      event: K,\n      handler: (data: Events[K]) => void\n    ): Unsubscribe => {\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\n      target.addEventListener(event, listener);\n      return () => target.removeEventListener(event, listener);\n    },\n\n    /**\n     * Emits an event with typed data.\n     * \n     * **Type Checking**: TypeScript ensures you provide the correct data type\n     * for each event.\n     * \n     * **Synchronous**: All handlers are called synchronously in registration order.\n     * \n     * @template K - Event name (inferred from Events)\n     * @param event - The event name to emit\n     * @param data - The event data (type-checked against Events map)\n     * \n     * @example\n     * ```typescript\n     * interface Events {\n     *   'save': { id: number; data: object; };\n     *   'delete': { id: number; };\n     *   'clear': void;\n     * }\n     * \n     * const bus = createBus<Events>();\n     * \n     * // Valid emissions\n     * bus.emit('save', { id: 1, data: { name: 'John' } });\n     * bus.emit('delete', { id: 1 });\n     * bus.emit('clear'); // void event\n     * \n     * // TypeScript errors:\n     * // bus.emit('save', { id: 1 }); // Missing 'data'\n     * // bus.emit('delete', {}); // Missing 'id'\n     * // bus.emit('clear', {}); // Unexpected data\n     * \n     * // Conditional emit\n     * if (hasChanges) {\n     *   bus.emit('save', { id, data: formData });\n     * }\n     * ```\n     */\n    emit: <K extends keyof Events & string>(event: K, data: Events[K]) => {\n      target.dispatchEvent(new CustomEvent(event, { detail: data }));\n    },\n\n    /**\n     * Subscribes to an event for one-time execution.\n     * \n     * **Auto-Unsubscribe**: The handler is automatically removed after the\n     * first time it's called.\n     * \n     * **Use Cases**: Initialization events, one-time confirmations, first-load actions.\n     * \n     * @template K - Event name (inferred from Events)\n     * @param event - The event name to listen for\n     * @param handler - Callback function (called only once)\n     * \n     * @example\n     * ```typescript\n     * interface Events {\n     *   'app:ready': void;\n     *   'user:firstLogin': { userId: number; };\n     * }\n     * \n     * const bus = createBus<Events>();\n     * \n     * // Run once when app is ready\n     * bus.once('app:ready', () => {\n     *   console.log('App initialized');\n     *   loadUserPreferences();\n     * });\n     * \n     * // First login bonus\n     * bus.once('user:firstLogin', ({ userId }) => {\n     *   showWelcomeModal(userId);\n     *   grantSignupBonus(userId);\n     * });\n     * \n     * // Emit multiple times - handler only runs once\n     * bus.emit('app:ready');\n     * bus.emit('app:ready'); // Handler doesn't run again\n     * ```\n     */\n    once: <K extends keyof Events & string>(\n      event: K,\n      handler: (data: Events[K]) => void\n    ): void => {\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\n      target.addEventListener(event, listener, { once: true });\n    }\n  };\n};\n\n// =============================================================================\n// 28. FLUENT WRAPPER ($)\n// =============================================================================\n\n/**\n * Wraps a single element in a fluent object with all fdom functions pre-bound.\n * \n * Provides an object-oriented, method-chaining API as an alternative to the\n * functional style. All methods return the wrapper (except getters), enabling\n * jQuery-like chaining.\n * \n * **vs Functional Style**:\n * - **Fluent**: `$(btn).addClass('active').css({ color: 'red' }).on('click', handler)`\n * - **Functional**: `cls.add(btn)('active'); css(btn)({ color: 'red' }); on(btn)('click', handler)`\n * \n * **When to Use**:\n * - **Fluent ($)**: When performing multiple operations on the same element\n * - **Functional**: When working with multiple elements or in functional pipelines\n * \n * **Type Preservation**: The generic type parameter preserves the element type\n * throughout the chain.\n * \n * **Null Safety**: All methods handle null elements gracefully.\n * \n * @template T - The HTML element type (inferred from input)\n * @param target - The element to wrap (null-safe)\n * @returns Fluent wrapper object with all fdom methods pre-bound\n * \n * @example\n * ```typescript\n * // Basic chaining\n * const button = document.querySelector('button');\n * $(button)\n *   .modify({ text: 'Click me' })\n *   .addClass('btn', 'btn-primary')\n *   .css({ padding: '10px 20px' })\n *   .on('click', () => console.log('Clicked!'));\n * \n * // vs Functional style (same result)\n * modify(button)({ text: 'Click me' });\n * cls.add(button)('btn', 'btn-primary');\n * css(button)({ padding: '10px 20px' });\n * on(button)('click', () => console.log('Clicked!'));\n * \n * // Type preservation\n * const input = document.querySelector('input');\n * $(input)\n *   .modify({ value: 'test' })\n *   .val('new value')  // Type-safe: knows it's an input\n *   .onInput((val) => console.log(val));\n * \n * // Conditional chaining\n * $(element)\n *   .addClass('base')\n *   .toggleClass('active', isActive)\n *   .css({ opacity: isVisible ? '1' : '0' });\n * \n * // Event handling with chaining\n * $(form)\n *   .on('submit', (e) => {\n *     e.preventDefault();\n *     const data = Form.serialize(form);\n *     submitData(data);\n *   })\n *   .on('reset', () => console.log('Form reset'));\n * \n * // Access raw element\n * const wrapped = $(button);\n * const raw = wrapped.raw; // Get underlying HTMLElement\n * \n * // Complex UI setup\n * $(modal)\n *   .addClass('modal')\n *   .css({ display: 'none' })\n *   .on('click', (e) => {\n *     if (e.target === modal) closeModal();\n *   })\n *   .append(\n *     el('div')({ class: { 'modal-content': true } })([\n *       el('h2')({})(['Modal Title']),\n *       el('p')({})(['Modal content'])\n *     ])\n *   );\n * \n * // Animation with chaining\n * $(element)\n *   .addClass('fade-in')\n *   .waitTransition()\n *   .then(() => {\n *     $(element).removeClass('fade-in').addClass('visible');\n *   });\n * \n * // Null-safe operations\n * const missing = document.querySelector('.nonexistent');\n * $(missing).addClass('test'); // No error, safely ignored\n * \n * // Comparison: Fluent vs Functional\n * // Fluent: Better for single-element operations\n * $(button).addClass('active').css({ color: 'red' });\n * \n * // Functional: Better for multiple elements\n * [button1, button2, button3].forEach(btn => {\n *   cls.add(btn)('active');\n *   css(btn)({ color: 'red' });\n * });\n * \n * // Or use $$ for batch operations\n * $$('.button').addClass('active').css({ color: 'red' });\n * ```\n */\nexport const $ = <T extends HTMLElement>(target: T | null) => {\n  // Helper to bind target-first functions and return wrapper for chaining\n  const chain = <F extends (t: any) => (...args: any[]) => any>(fn: F) =>\n    (...args: Parameters<ReturnType<F>>) => {\n      if (target) fn(target)(...args);\n      return wrapper;\n    };\n\n  const wrapper = {\n    /**\n     * The raw underlying HTMLElement.\n     * @type {T | null}\n     */\n    raw: target,\n\n    // =========================================\n    // EVENTS\n    // =========================================\n\n    /**\n     * Adds an event listener.\n     * @param event - Event name (e.g., 'click', 'submit')\n     * @param handler - Function to handle the event\n     * @param options - Event options (capture, passive, etc.)\n     * @returns {this} Fluent wrapper for chaining\n     */\n    on: chain(on),\n\n    /**\n     * Dispatches a custom event.\n     * @param name - Name of the event\n     * @param detail - Data to pass with the event\n     * @returns {this} Fluent wrapper for chaining\n     */\n    dispatch: chain(dispatch),\n\n    // =========================================\n    // MANIPULATION\n    // =========================================\n\n    /**\n     * Modifies element properties (text, html, class, etc.).\n     * @param props - Object of properties to set\n     * @returns {this} Fluent wrapper for chaining\n     */\n    modify: chain(modify),\n\n    /**\n     * Applies inline CSS styles.\n     * @param styles - Object of CSS properties (camelCase or kebab-case)\n     * @returns {this} Fluent wrapper for chaining\n     */\n    css: chain(css),\n\n    /**\n     * Applies temporary styles that revert after a delay.\n     * @param styles - Styles to apply\n     * @param ms - Optional duration in ms to revert styles\n     * @returns {this} Fluent wrapper for chaining\n     */\n    tempStyle: (styles: Partial<CSSStyleDeclaration>, ms?: number) => {\n      if (target) {\n        const revert = tempStyle(target)(styles);\n        if (ms) setTimeout(revert, ms);\n      }\n      return wrapper;\n    },\n\n    // =========================================\n    // STRUCTURE\n    // =========================================\n\n    /**\n     * Appends children to this element.\n     * @param children - Elements or strings to append\n     * @returns {this} Fluent wrapper for chaining\n     */\n    append: chain(append),\n\n    /**\n     * Prepends children to this element.\n     * @param children - Elements or strings to prepend\n     * @returns {this} Fluent wrapper for chaining\n     */\n    prepend: chain(prepend),\n\n    /**\n     * Inserts content after this element.\n     * @param content - Elements or strings to insert\n     * @returns {this} Fluent wrapper for chaining\n     */\n    after: chain(after),\n\n    /**\n     * Inserts content before this element.\n     * @param content - Elements or strings to insert\n     * @returns {this} Fluent wrapper for chaining\n     */\n    before: chain(before),\n\n    /**\n     * Removes this element from the DOM.\n     * @returns {void}\n     */\n    remove: () => { if (target) remove(target); },\n\n    /**\n     * Removes all children from this element.\n     * @returns {this} Fluent wrapper for chaining\n     */\n    empty: () => { if (target) empty(target); return wrapper; },\n\n    /**\n     * Wraps this element with another element.\n     * @param wrapperEl - The wrapping element\n     * @returns {this} Fluent wrapper for chaining\n     */\n    wrap: chain(wrap),\n\n    /**\n     * Clones this element.\n     * @returns {HTMLElement} The cloned element (not wrapped)\n     */\n    clone: () => target ? clone(target) : null,\n\n    // =========================================\n    // CLASSES\n    // =========================================\n\n    /**\n     * Adds one or more classes.\n     * @param classes - Class names to add\n     * @returns {this} Fluent wrapper for chaining\n     */\n    addClass: chain(cls.add),\n\n    /**\n     * Removes one or more classes.\n     * @param classes - Class names to remove\n     * @returns {this} Fluent wrapper for chaining\n     */\n    removeClass: chain(cls.remove),\n\n    /**\n     * Toggles a class (conditionally or always).\n     * @param className - Class to toggle\n     * @param force - Optional boolean to force add/remove\n     * @returns {this} Fluent wrapper for chaining\n     */\n    toggleClass: chain(cls.toggle),\n\n    /**\n     * Replaces one class with another.\n     * @param oldClass - Class to remove\n     * @param newClass - Class to add\n     * @returns {this} Fluent wrapper for chaining\n     */\n    replaceClass: chain(cls.replace),\n\n    /**\n     * Checks if the element has a class.\n     * @param className - Class to check\n     * @returns {boolean} True if class exists\n     */\n    hasClass: (className: string) => target ? cls.has(target)(className) : false,\n\n    /**\n     * Watches for class changes.\n     * @param callback - Function called when classes change\n     * @returns {Unsubscribe} Function to stop watching\n     */\n    //watchClass: (callback: (classes: string[]) => void) => target ? watchClass(target)(callback) : () => { },\n\n    /**\n     * Cycles through a list of classes (removes current, adds next).\n     * @param classes - Array of classes to cycle\n     * @returns {this} Fluent wrapper for chaining\n     */\n    cycleClass: chain(cycleClass),\n\n    // =========================================\n    // DATA & ATTRIBUTES\n    // =========================================\n\n    /**\n     * Gets a data attribute value (raw string).\n     * @param key - Attribute name (without 'data-')\n     * @returns {string | undefined} Raw value\n     */\n    dataGet: (key: string) => target ? Data.get(target)(key) : undefined,\n\n    /**\n     * Sets a data attribute.\n     * @param key - Attribute name\n     * @param val - Value to set (automatically stringified)\n     * @returns {this} Fluent wrapper for chaining\n     */\n    dataSet: chain(Data.set),\n\n    /**\n     * Reads and parses a data attribute.\n     * @param key - Attribute name\n     * @returns {any} Parsed value (JSON, number, boolean, string)\n     */\n    dataRead: (key: string) => target ? Data.read(target)(key) : undefined,\n\n    /**\n     * Binds a callback to data attribute changes.\n     * @param key - Attribute to watch\n     * @param handler - Callback receiving new parsed value\n     * @returns {Unsubscribe} Function to stop watching\n     */\n    dataBind: (key: string, handler: (val: any) => void) => target ? Data.bind(target)(key, handler) : () => { },\n\n    /**\n     * Watches an attribute for changes.\n     * @param attr - Attribute name\n     * @param handler - Callback receiving new value\n     * @returns {Unsubscribe} Function to stop watching\n     */\n    watchAttr: (attr: string, handler: (val: string | null) => void) => target ? watchAttr(target)(attr, handler) : () => { },\n\n    /**\n     * Watches text content for changes.\n     * @param handler - Callback receiving new text\n     * @returns {Unsubscribe} Function to stop watching\n     */\n    watchText: (handler: (text: string | null) => void) => target ? watchText(target)(handler) : () => { },\n\n    // =========================================\n    // INPUTS & FORMS\n    // =========================================\n\n    /**\n     * Gets or sets the value.\n     * - No args: Gets value (smart typed)\n     * - Arg provided: Sets value\n     * @param newVal - Value to set\n     * @returns {any | this} Value if getting, wrapper if setting\n     */\n    val: (newVal?: any) => {\n      if (newVal === undefined) return Input.get(target as unknown as FormElement);\n      Input.set(target as unknown as FormElement)(newVal);\n      return wrapper;\n    },\n\n    /**\n     * Gets files from an input[type=\"file\"].\n     * @returns {File[]} Array of files\n     */\n    files: () => Input.files(target as unknown as HTMLInputElement),\n\n    /**\n     * Listens for input events (keystrokes).\n     * @param handler - Callback receiving parsed value\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onInput: (handler: (val: any, e: Event) => void) => target ? Input.watch(target as unknown as FormElement)(handler) : () => { },\n\n    /**\n     * Listens for input events with debounce.\n     * @param ms - Debounce delay in ms\n     * @param handler - Callback receiving parsed value\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onInputDebounced: (ms: number, handler: (val: any, e: Event) => void) => target ? Input.watchDebounced(target as unknown as FormElement)(handler as unknown as any, ms) : () => { },\n\n    /**\n     * Listens for change events (blur/enter).\n     * @param handler - Callback receiving parsed value\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onChange: (handler: (val: any, e: Event) => void) => target ? Input.change(target as unknown as FormElement)(handler) : () => { },\n\n    /**\n     * Selects all text in the input.\n     * @returns {this} Fluent wrapper for chaining\n     */\n    selectText: () => { Input.select(target as unknown as HTMLInputElement); return wrapper; },\n\n    /**\n     * Validates the input using HTML5 validation API.\n     * @returns {boolean} True if valid\n     */\n    validate: () => target ? Input.validate(target as unknown as FormElement) : false,\n\n    // =========================================\n    // KEYBOARD\n    // =========================================\n\n    /**\n     * Listens for a specific key press.\n     * @param key - Key to listen for (e.g., 'Enter', 'Escape')\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onKey: (key: string, handler: (e: KeyboardEvent) => void) => {\n      if (target) Key.is(target)(key, handler);\n      return wrapper;\n    },\n\n    /**\n     * Listens for the Tab key.\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onTab: (handler: (e: KeyboardEvent) => void) => {\n      if (target) Key.onTab(target)(handler);\n      return wrapper;\n    },\n\n    /**\n     * Listens for Arrow keys.\n     * @param handler - Callback receiving direction and event\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onArrow: (handler: (dir: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\n      if (target) Key.onArrow(target)(handler);\n      return wrapper;\n    },\n\n    // =========================================\n    // FOCUS\n    // =========================================\n\n    /**\n     * Listens for focus event.\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onFocus: (handler: (e: FocusEvent) => void) => {\n      if (target) Focus.on(target)(handler);\n      return wrapper;\n    },\n\n    /**\n     * Listens for blur event.\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onBlur: (handler: (e: FocusEvent) => void) => {\n      if (target) Focus.onBlur(target)(handler);\n      return wrapper;\n    },\n\n    /**\n     * Listens for focusin (bubbles).\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onFocusIn: (handler: (e: FocusEvent) => void) => {\n      if (target) Focus.onIn(target)(handler);\n      return wrapper;\n    },\n\n    /**\n     * Listens for focusout (bubbles).\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    onFocusOut: (handler: (e: FocusEvent) => void) => {\n      if (target) Focus.onOut(target)(handler);\n      return wrapper;\n    },\n\n    /**\n     * Traps focus within this element (for modals/dialogs).\n     * @returns {Unsubscribe} Function to disable trap\n     */\n    trapFocus: () => Focus.trap(target),\n\n    // =========================================\n    // POINTER & TEXT\n    // =========================================\n\n    /**\n     * Listens for clicks outside this element.\n     * @param handler - Callback function\n     * @returns {Unsubscribe} Function to stop listening\n     */\n    clickOutside: (handler: () => void) => {\n      if (!target) return () => { };\n      const listener = (e: Event) => {\n        if (target && !target.contains(e.target as Node)) handler();\n      };\n      document.addEventListener('click', listener);\n      return () => document.removeEventListener('click', listener);\n    },\n\n    /**\n     * Checks if element contains text.\n     * @param text - String or RegExp to search\n     * @returns {boolean} True if found\n     */\n    hasText: (text: string | RegExp) => target ? !!Text.find(target)(text) : false,\n\n    /**\n     * Finds the first text node matching the pattern.\n     * @param text - String or RegExp to search\n     * @param selector - Optional selector to scope search\n     * @returns {Text | null} The found text node\n     */\n    findText: (text: string | RegExp, selector?: string) => target ? Text.find(target)(text, selector) : null,\n\n    /**\n     * Finds all text nodes matching the pattern.\n     * @param text - String or RegExp to search\n     * @param selector - Optional selector to scope search\n     * @returns {Text[]} Array of found text nodes\n     */\n    findAllText: (text: string | RegExp, selector?: string) => target ? Text.findAll(target)(text, selector) : [],\n\n    /**\n     * Replaces text content.\n     * @param search - String or RegExp to find\n     * @param replace - Replacement string\n     * @returns {this} Fluent wrapper for chaining\n     */\n    replaceText: (search: string | RegExp, replace: string) => {\n      if (target) Text.replace(target)(search, replace);\n      return wrapper;\n    },\n\n    // =========================================\n    // VIEW TRANSITIONS\n    // =========================================\n\n    /**\n     * Sets the view-transition-name.\n     * @param name - Transition name\n     * @returns {this} Fluent wrapper for chaining\n     */\n    transitionName: chain(ViewTransitions.name),\n\n    /**\n     * Removes the view-transition-name.\n     * @returns {this} Fluent wrapper for chaining\n     */\n    removeTransitionName: () => { ViewTransitions.unname(target); return wrapper; },\n\n    /**\n     * Runs a view transition focusing on this element.\n     * @param name - Temporary transition name\n     * @param updateFn - Function to run during transition\n     * @returns {Promise<void>} Promise resolving when done\n     */\n    transitionWith: (name: string, updateFn: () => void) => ViewTransitions.tempName(target)(name)(updateFn),\n\n    // =========================================\n    // TRAVERSAL\n    // =========================================\n\n    /** Parent element */\n    parent: Traverse.parent(target),\n    /** Next sibling element */\n    next: Traverse.next(target),\n    /** Previous sibling element */\n    prev: Traverse.prev(target),\n    /** Child elements */\n    children: Traverse.children(target),\n    /** Sibling elements */\n    siblings: Traverse.siblings(target),\n\n    // =========================================\n    // GEOMETRY & UI\n    // =========================================\n\n    /**\n     * Gets the bounding client rect.\n     * @returns {DOMRect | undefined}\n     */\n    rect: () => rect(target),\n\n    /**\n     * Gets the element's offset position.\n     * @returns {{ top: number, left: number } | undefined}\n     */\n    offset: () => offset(target),\n\n    /**\n     * Scrolls the element into view.\n     * @param arg - Scroll options or boolean\n     * @returns {this} Fluent wrapper for chaining\n     */\n    scrollInto: (arg?: boolean | ScrollIntoViewOptions) => { target?.scrollIntoView(arg); return wrapper; },\n\n    /**\n     * Focuses the element.\n     * @param options - Focus options\n     * @returns {this} Fluent wrapper for chaining\n     */\n    focus: (options?: FocusOptions) => { target?.focus(options); return wrapper; },\n\n    /**\n     * Blurs the element.\n     * @returns {this} Fluent wrapper for chaining\n     */\n    blur: () => { target?.blur(); return wrapper; },\n\n    // =========================================\n    // UTILS\n    // =========================================\n\n    /**\n     * Waits for CSS transitions to complete.\n     * @returns {Promise<void>}\n     */\n    waitTransition: () => waitTransition(target)\n  };\n\n  return wrapper;\n};\n\n/**\n * Turns a DOM tree into a component object by mapping `data-ref` nodes.\n * \n * **Pattern**: Use `data-ref=\"name\"` in HTML to mark elements. This function\n * gathers them into a strongly-typed object for easy access.\n * \n * **Type Safety**: Pass a generic type to define the expected refs.\n * \n * **Performance**: Scans the tree once on initialization. Much faster than\n * repeated `querySelector` calls.\n * \n * @template T - Interface defining the expected refs (e.g. `{ title: HTMLElement }`)\n * @param rootOrSelector - The root element or a selector string\n * @returns Object containing the root and all mapped refs\n * \n * @example\n * ```typescript\n * // HTML:\n * // <div id=\"card\">\n * //   <h1 data-ref=\"title\"></h1>\n * //   <button data-ref=\"btn\"></button>\n * //   <input data-ref=\"input\" type=\"text\">\n * // </div>\n * \n * // Define types\n * interface CardRefs {\n *   title: HTMLHeadingElement;\n *   btn: HTMLButtonElement;\n *   input: HTMLInputElement;\n * }\n * \n * // Initialize\n * const card = component<CardRefs>('#card');\n * \n * // Access refs directly (type-safe)\n * card.title.textContent = 'Hello World';\n * card.input.value = 'Initial value';\n * \n * // Use with fluent API\n * $(card.btn).on('click', () => {\n *   console.log(card.input.value);\n * });\n * \n * // Component Factory Pattern\n * function createCard(data: any) {\n *   const el = clone(template);\n *   const cmp = component<CardRefs>(el);\n *   \n *   cmp.title.textContent = data.title;\n *   \n *   return cmp;\n * }\n * ```\n */\nexport const component = <T extends Record<string, HTMLElement>>(rootOrSelector: HTMLElement | string | null) => {\n  const root = typeof rootOrSelector === 'string' ? find(document)(rootOrSelector) : rootOrSelector;\n  if (!root) return {} as T & { root: null };\n\n  // Get all refs\n  const nodes = refs(root) as T;\n\n  return {\n    root,\n    ...nodes\n  };\n};\n\n/**\n * Wraps a LIST of elements for batch operations.\n * \n * **Batch Processing**: Calling a method applies it to ALL elements in the list.\n * \n * **Performance**: Optimized for batch DOM updates.\n * \n * **Parallel Operations**: Methods run sequentially on each element, but\n * can be conceptually treated as parallel updates.\n * \n * @param selectorOrList - Selector string, Array of Elements, or NodeList\n * @returns Fluent wrapper for the list of elements\n * \n * @example\n * ```typescript\n * // Select and update multiple elements\n * $$('.btn')\n *   .addClass('active')\n *   .css({ opacity: '1' })\n *   .on('click', handler);\n * \n * // Filter and map\n * $$('input')\n *   .filter((el) => el.value === '')\n *   .addClass('error');\n * \n * // Batch event handling\n * const unsubscribeAll = $$('.item').on('click', (e) => {\n *   console.log('Item clicked');\n * });\n * \n * // Cleanup\n * unsubscribeAll();\n * \n * // Complex batch update\n * $$('.card')\n *   .removeClass('selected')\n *   .modify({ title: 'Reset' })\n *   .css({ transform: 'none' });\n * \n * // Functional map (returns array of results)\n * const values = $$('input').map(el => el.value);\n * \n * // Chaining with filter\n * $$('li')\n *   .filter((el, i) => i % 2 === 0) // Evens\n *   .css({ background: '#eee' });\n * ```\n */\nexport const $$ = (selectorOrList: string | Element[] | NodeListOf<Element>) => {\n  const elements = typeof selectorOrList === 'string'\n    ? findAll(document)(selectorOrList)\n    : Array.from(selectorOrList) as HTMLElement[];\n\n  // Helper to map a function over all elements\n  const map = (fn: any) => (arg: any, arg2?: any) => {\n    elements.forEach(el => fn(el)(arg, arg2));\n    return wrapper; // Return self for chaining\n  };\n\n  const wrapper = {\n    raw: elements,\n\n    // Batch Operations\n    modify: map(modify),\n    css: map(css),\n    addClass: map(cls.add),\n    removeClass: map(cls.remove),\n    toggleClass: map(cls.toggle),\n    attr: map((el: any) => (attr: any) => modify(el)({ attr })),\n\n    // Batch Events\n    on: (evt: any, handler: any) => {\n      const unsubs = elements.map(el => on(el)(evt, handler));\n      return () => unsubs.forEach(u => u()); // Return batch unsubscribe\n    },\n\n    // Batch Traversal / Manipulation\n    remove: () => elements.forEach(el => remove(el)),\n    empty: () => elements.forEach(el => empty(el)),\n\n    // Functional map (standard array map)\n    map: <T>(fn: (el: HTMLElement, i: number) => T) => elements.map(fn),\n    filter: (fn: (el: HTMLElement, i: number) => boolean) => elements.filter(fn)\n  };\n\n  return wrapper;\n};\n\n/**\n * Creates a Proxy object where properties are 2-way bound to the element's dataset.\n * \n * **Reactivity**: Assigning to properties updates the DOM `data-*` attributes.\n * Reading properties reads from the DOM.\n * \n * **Type Safety**: Use a generic interface to define the expected data structure.\n * \n * **Limitations**:\n * - Only stores strings (or JSON serialized values)\n * - Performance cost of DOM access on every read/write\n * - Property names are converted to kebab-case (e.g. `userId` -> `data-user-id`)\n * \n * @template T - Interface defining the store shape\n * @param element - The element to bind to\n * @returns Proxy object mirroring the element's dataset\n * \n * @example\n * ```typescript\n * // Define state shape\n * interface UserState {\n *   userId: number;\n *   isAdmin: boolean;\n *   theme: 'light' | 'dark';\n *   preferences: { notifications: boolean };\n * }\n * \n * // Create store\n * const state = store<UserState>(document.body);\n * \n * // Write to DOM (updates data-attributes)\n * state.userId = 123;          // data-user-id=\"123\"\n * state.isAdmin = true;        // data-is-admin=\"true\"\n * state.theme = 'dark';        // data-theme=\"dark\"\n * state.preferences = { notifications: true }; // JSON serialized\n * \n * // Read from DOM\n * console.log(state.userId); // 123 (typed as number)\n * \n * // Reactivity with MutationObserver\n * Data.bind(document.body)('user-id', (newId) => {\n *   console.log('User ID changed to:', newId);\n * });\n * \n * // Delete property\n * delete state.theme; // Removes data-theme attribute\n * ```\n */\nexport const store = <T extends Record<string, any> = Record<string, any>>(element: HTMLElement | null) => {\n  if (!element) return new EventTarget() as T & EventTarget;\n\n  const target = new EventTarget();\n  return new Proxy(target, {\n    get: (t, prop: string | symbol) => {\n      if (prop in t) {\n        const val = (t as any)[prop];\n        return typeof val === 'function' ? val.bind(t) : val;\n      }\n      return Data.read(element)(String(prop));\n    },\n    set: (t, prop: string | symbol, value: any) => {\n      if (prop in t) return true;\n      Data.set(element)(String(prop), value);\n      t.dispatchEvent(new CustomEvent(String(prop), { detail: value }));\n      t.dispatchEvent(new CustomEvent('change', { detail: { prop, value } }));\n      return true;\n    },\n    deleteProperty: (t, prop: string | symbol) => {\n      if (prop in t) return false;\n      Data.set(element)(String(prop), null);\n      t.dispatchEvent(new CustomEvent(String(prop), { detail: null }));\n      t.dispatchEvent(new CustomEvent('change', { detail: { prop, value: null } }));\n      return true;\n    },\n    // Allow iteration over current dataset\n    ownKeys: () => Reflect.ownKeys(element.dataset),\n    getOwnPropertyDescriptor: (_, _key) => ({\n      enumerable: true,\n      configurable: true,\n    })\n  }) as T & EventTarget;\n};\n\n/**\n * Wraps a form or container to manage input values, validation, and submission.\n * \n * **Features**:\n * - Automatic serialization of all inputs\n * - Population of inputs from data objects\n * - Simplified submit handling with `preventDefault`\n * - Batch clearing of inputs\n * \n * **Validation**: Combine with `Input.validate` or custom logic in submit handler.\n * \n * @param target - Form element or selector\n * @returns Form wrapper object\n * \n * @example\n * ```typescript\n * const f = form('#login-form');\n * \n * // Get all values\n * const data = f.values();\n * console.log(data.username, data.password);\n * \n * // Pre-fill form\n * f.set({\n *   username: 'admin',\n *   rememberMe: true\n * });\n * \n * // Handle submit\n * f.submit((data, e) => {\n *   // Validations\n *   if (!data.username) {\n *     alert('Username required');\n *     return;\n *   }\n *   \n *   // API call\n *   api.login(data).catch(err => {\n *     console.error(err);\n *     f.clear(); // Clear on error if needed\n *   });\n * });\n * \n * // Clear form\n * f.clear();\n * ```\n */\nexport const form = (target: HTMLElement | string | null) => {\n  const el = typeof target === 'string' ? find(document)(target) : target;\n\n  return {\n    raw: el,\n    /** Get all values as object */\n    values: () => Form.serialize(el),\n    /** Set values from object */\n    set: (data: Record<string, any>) => Form.populate(el)(data),\n    /** Clear all inputs */\n    clear: () => {\n      if (!el) return;\n      el.querySelectorAll('input, select, textarea').forEach((i: any) => {\n        if (i.type === 'checkbox' || i.type === 'radio') i.checked = false;\n        else i.value = '';\n      });\n    },\n    /** Short hand for on('submit') with preventDefault and serialization */\n    submit: (handler: (data: any, e: Event) => void) => {\n      return on(el)('submit', (e) => {\n        e.preventDefault();\n        handler(Form.serialize(el), e);\n      });\n    }\n  };\n};\n\n// =============================================================================\n// 29. INPUTS & CONTROLS\n// =============================================================================\n\nexport type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\nexport const Input = {\n  /**\n   * Smart Getter. Automatically handles:\n   * - Checkbox/Radio -> boolean\n   * - Number/Range -> number\n   * - File -> FileList\n   * - Select/Text -> string\n   * \n   * @example const val = Input.get(input);\n   */\n  get: (el: FormElement | null): any => {\n    if (!el) return undefined;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox' || el.type === 'radio') return el.checked;\n      if (el.type === 'number' || el.type === 'range') return el.valueAsNumber;\n      if (el.type === 'file') return el.files;\n      if (el.type === 'date') return el.valueAsDate;\n    }\n    return el.value;\n  },\n\n  /**\n   * Smart Setter. Automatically handles checkboxes, numbers, etc.\n   * \n   * @example Input.set(checkbox)(true);\n   */\n  set: (el: FormElement | null) => (val: any) => {\n    if (!el) return el;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox' || el.type === 'radio') {\n        el.checked = !!val;\n      } else if (el.type === 'file') {\n        // Read-only usually, but clearing allowed\n        if (!val) el.value = '';\n      } else if (el.type === 'date' && val instanceof Date) {\n        el.valueAsDate = val;\n      } else {\n        el.value = String(val);\n      }\n    } else {\n      el.value = String(val);\n    }\n    // Trigger event so listeners know it changed programmatically\n    el.dispatchEvent(new Event('input', { bubbles: true }));\n    el.dispatchEvent(new Event('change', { bubbles: true }));\n    return el;\n  },\n\n  /**\n   * Returns an array of Files from a file input (easier than FileList).\n   */\n  files: (el: HTMLInputElement | null): File[] => {\n    return el && el.files ? Array.from(el.files) : [];\n  },\n\n  /**\n   * Watches the 'input' event (keystrokes).\n   * callback receives the *parsed* value, not the event.\n   * \n   * @example Input.watch(search)(query => filterList(query));\n   */\n  watch: (el: FormElement | null) => {\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\n      if (!el) return () => { };\n      const handler = (e: Event) => callback(Input.get(el), e);\n      el.addEventListener('input', handler);\n      return () => el.removeEventListener('input', handler);\n    };\n  },\n\n  /**\n   * Watches the 'input' event with a DEBOUNCE.\n   * Perfect for search bars.\n   * \n   * @example Input.watchDebounced(search)(query => api.search(query), 500);\n   */\n  watchDebounced: (el: FormElement | null) => {\n    return (callback: (val: any) => void, ms: number): Unsubscribe => {\n      if (!el) return () => { };\n      const d = debounce((_e) => callback(Input.get(el)), ms);\n      el.addEventListener('input', d);\n      return () => el.removeEventListener('input', d);\n    };\n  },\n\n  /**\n   * Watches the 'change' event (blur/enter/selection).\n   * \n   * @example Input.change(dropdown)(val => console.log('Selected', val));\n   */\n  change: (el: FormElement | null) => {\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\n      if (!el) return () => { };\n      const handler = (e: Event) => callback(Input.get(el), e);\n      el.addEventListener('change', handler);\n      return () => el.removeEventListener('change', handler);\n    };\n  },\n\n  /**\n   * Selects all text in the input/textarea.\n   */\n  select: (el: HTMLInputElement | HTMLTextAreaElement | null) => {\n    el?.select();\n    return el;\n  },\n\n  /**\n   * Checks validity and returns boolean. \n   * Optionally sets custom validity message.\n   */\n  validate: (el: FormElement | null) => (msg?: string): boolean => {\n    if (!el) return false;\n    if (msg !== undefined) el.setCustomValidity(msg);\n    return el.checkValidity();\n  }\n};\n\n// =============================================================================\n// 30. EVENT HELPERS\n// =============================================================================\n\nexport const Evt = {\n  /**\n   * Stops propagation (bubbling) of the event.\n   * Can be used as a wrapper for handlers.\n   * \n   * @example on(btn)('click', Evt.stop(handler));\n   */\n  stop: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\n    e.stopPropagation();\n    if (fn) fn(e);\n  },\n\n  /**\n   * Prevents default behavior.\n   * \n   * @example on(form)('submit', Evt.prevent(submitHandler));\n   */\n  prevent: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\n    e.preventDefault();\n    if (fn) fn(e);\n  },\n\n  /**\n   * Stops propagation AND prevents default.\n   */\n  kill: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (fn) fn(e);\n  },\n\n  /**\n   * Filters an event handler to only run for specific keys.\n   * \n   * @example on(input)('keydown', Evt.key('Enter', search));\n   */\n  key: (keyOrKeys: string | string[], fn: (e: KeyboardEvent) => void) => (e: KeyboardEvent) => {\n    const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n    if (keys.includes(e.key)) fn(e);\n  },\n\n  /**\n   * Checks if the event triggered exactly on the element (not a child).\n   */\n  isSelf: (e: Event) => e.target === e.currentTarget,\n\n  /**\n   * Gets the coordinate of the event relative to the viewport.\n   * Handles Mouse and Touch events uniformly.\n   */\n  pointer: (e: MouseEvent | TouchEvent | Event) => {\n    if ('touches' in e) {\n      const t = (e as TouchEvent).touches[0] || (e as TouchEvent).changedTouches[0];\n      return { x: t.clientX, y: t.clientY };\n    }\n    return { x: (e as MouseEvent).clientX, y: (e as MouseEvent).clientY };\n  }\n};\n\n// =============================================================================\n// 31. KEYBOARD & FOCUS INTERACTIONS\n// =============================================================================\n\nexport const Key = {\n  /**\n   * Listens for a specific key press.\n   * @example Key.is(input)('Enter', onSubmit);\n   */\n  is: (target: EventTarget | null) => (key: string, handler: (e: KeyboardEvent) => void) => {\n    return on(target)('keydown', (e) => {\n      if (e.key === key) handler(e as KeyboardEvent);\n    });\n  },\n\n  /**\n   * Listens for the 'Tab' key.\n   * Useful for trapping focus or form navigation logic.\n   */\n  onTab: (target: EventTarget | null) => (handler: (e: KeyboardEvent) => void) => {\n    return on(target)('keydown', (e) => {\n      if (e.key === 'Tab') handler(e as KeyboardEvent);\n    });\n  },\n\n  /**\n   * Listens for any Arrow key.\n   * Handler receives the direction ('Up' | 'Down' | 'Left' | 'Right').\n   * \n   * @example \n   * Key.onArrow(menu)((dir, e) => {\n   *   if (dir === 'Down') focusNext();\n   * });\n   */\n  onArrow: (target: EventTarget | null) => {\n    return (handler: (direction: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\n      return on(target)('keydown', (e) => {\n        if (e.key.startsWith('Arrow')) {\n          const dir = e.key.replace('Arrow', '') as 'Up' | 'Down' | 'Left' | 'Right';\n          handler(dir, e as KeyboardEvent);\n        }\n      });\n    };\n  }\n};\n\nexport const Focus = {\n  /**\n   * Standard Focus event.\n   */\n  on: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\n    return on(target)('focus', handler as any);\n  },\n\n  /**\n   * Standard Blur event.\n   */\n  onBlur: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\n    return on(target)('blur', handler as any);\n  },\n\n  /**\n   * Focus In (Bubbles).\n   * Useful for detecting if ANY child within a container gained focus.\n   */\n  onIn: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\n    return on(target)('focusin', handler as any);\n  },\n\n  /**\n   * Focus Out (Bubbles).\n   * Useful for detecting if focus left a container entirely.\n   */\n  onOut: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\n    return on(target)('focusout', handler as any);\n  },\n\n  /**\n   * Traps focus within an element (Accessibility).\n   * Prevents Tab from leaving the target container.\n   */\n  trap: (target: HTMLElement | null) => {\n    if (!target) return () => { };\n\n    const handler = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab') return;\n\n      const focusables = target.querySelectorAll<HTMLElement>(\n        'a[href], button, textarea, input, select, [tabindex]:not([tabindex=\"-1\"])'\n      );\n      const first = focusables[0];\n      const last = focusables[focusables.length - 1];\n\n      if (e.shiftKey) {\n        if (document.activeElement === first) {\n          e.preventDefault();\n          last.focus();\n        }\n      } else {\n        if (document.activeElement === last) {\n          e.preventDefault();\n          first.focus();\n        }\n      }\n    };\n\n    target.addEventListener('keydown', handler);\n    return () => target.removeEventListener('keydown', handler);\n  }\n};\n\n// =============================================================================\n// 32. TEXT QUERYING\n// =============================================================================\n\nexport const Text = {\n  /**\n   * Finds all elements containing the specified text or matching a Regex.\n   * \n   * @example\n   * // Find all buttons saying \"Submit\"\n   * const btns = Text.findAll(document)('Submit', 'button');\n   * \n   * // Find using Regex\n   * const prices = Text.findAll(table)(/$\\d+\\.\\d{2}/);\n   */\n  findAll: (root: Element | Document = document) => {\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element[] => {\n      const matches = new Set<Element>();\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n\n      let node: Node | null;\n      while ((node = walker.nextNode())) {\n        const parent = node.parentElement;\n        const content = node.nodeValue || '';\n\n        // 1. Check if parent matches selector\n        if (!parent || !parent.matches(selector)) continue;\n\n        // 2. Check text match\n        const isMatch = typeof textOrRegex === 'string'\n          ? content.includes(textOrRegex)\n          : textOrRegex.test(content);\n\n        if (isMatch) matches.add(parent);\n      }\n\n      return Array.from(matches);\n    };\n  },\n\n  /**\n   * Finds the FIRST element containing the text.\n   * \n   * @example\n   * const btn = Text.find(form)('Save');\n   */\n  find: (root: Element | Document = document) => {\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element | null => {\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n      let node: Node | null;\n\n      while ((node = walker.nextNode())) {\n        const parent = node.parentElement;\n        const content = node.nodeValue || '';\n\n        if (!parent || !parent.matches(selector)) continue;\n\n        const isMatch = typeof textOrRegex === 'string'\n          ? content.includes(textOrRegex)\n          : textOrRegex.test(content);\n\n        if (isMatch) return parent;\n      }\n      return null;\n    };\n  },\n\n  /**\n   * Replaces text in the target's descendants.\n   * Safe wrapper that only touches text nodes, preserving HTML structure.\n   * \n   * @example\n   * Text.replace(document.body)('foo', 'bar');\n   */\n  replace: (root: Element | null) => {\n    return (searchValue: string | RegExp, replaceValue: string) => {\n      if (!root) return root;\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n      let node: Node | null;\n\n      while ((node = walker.nextNode())) {\n        const val = node.nodeValue || '';\n        if (typeof searchValue === 'string' ? val.includes(searchValue) : searchValue.test(val)) {\n          node.nodeValue = val.replace(searchValue, replaceValue);\n        }\n      }\n      return root;\n    };\n  }\n};\n\n// =============================================================================\n// 33. VIEW TRANSITIONS\n// =============================================================================\n\n// Type shim for environments where ViewTransition isn't in 'lib' yet\ninterface ViewTransition {\n  finished: Promise<void>;\n  ready: Promise<void>;\n  updateCallbackDone: Promise<void>;\n  skipTransition(): void;\n}\n\nexport const ViewTransitions = {\n  /** Checks if View Transitions are supported. */\n  isSupported: () => 'startViewTransition' in document,\n\n  /**\n   * Sets the `view-transition-name` on an element.\n   * Essential for connecting elements across DOM updates.\n   * \n   * @example View.name(img)('hero-image');\n   */\n  name: (target: HTMLElement | null) => (name: string) => {\n    if (target) target.style.viewTransitionName = name;\n    return target;\n  },\n\n  /** Removes the view-transition-name. */\n  unname: (target: HTMLElement | null) => {\n    if (target) target.style.removeProperty('view-transition-name');\n    return target;\n  },\n\n  /**\n   * Starts a global View Transition.\n   * Gracefully falls back to immediate execution if not supported.\n   * \n   * @example\n   * ViewTransitions.start(() => {\n   *   // Update DOM here\n   *   document.body.append(newPage);\n   * });\n   */\n  start: (updateCallback: () => Promise<void> | void): ViewTransition | null => {\n    if (!('startViewTransition' in document)) {\n      updateCallback();\n      return null;\n    }\n    // @ts-ignore\n    return document.startViewTransition(updateCallback);\n  },\n\n  /**\n   * Starts a transition with a specific class applied to the document element.\n   * Useful for defining different animations (e.g. 'slide-left' vs 'slide-right').\n   * \n   * @example ViewTransitions.withClass('slide-back')(() => history.back());\n   */\n  withClass: (className: string) => (updateCallback: () => Promise<void> | void) => {\n    document.documentElement.classList.add(className);\n\n    const transition = ViewTransitions.start(updateCallback);\n\n    if (transition) {\n      transition.finished.finally(() => document.documentElement.classList.remove(className));\n    } else {\n      document.documentElement.classList.remove(className);\n    }\n    return transition;\n  },\n\n  /**\n   * Applies a transition name to an element ONLY for the duration of the next transition.\n   * Auto-cleans up the name when the transition finishes.\n   * \n   * @example View.tempName(img)('hero-morph')(async () => updateDOM());\n   */\n  tempName: (target: HTMLElement | null) => (name: string) => {\n    return (updateCallback: () => Promise<void> | void) => {\n      if (!target) return ViewTransitions.start(updateCallback);\n\n      target.style.viewTransitionName = name;\n      const transition = ViewTransitions.start(updateCallback);\n\n      if (transition) {\n        transition.finished.finally(() => target.style.removeProperty('view-transition-name'));\n      } else {\n        target.style.removeProperty('view-transition-name');\n      }\n      return transition;\n    };\n  }\n};\n\n// =============================================================================\n// 34. ASYNC & PROMISES\n// =============================================================================\n\nexport const Async = {\n  /**\n   * Wraps a value or Promise in a Promise (safe normalization).\n   */\n  resolve: <T>(v: T | PromiseLike<T>): Promise<T> => Promise.resolve(v),\n\n  /**\n   * Sleeps for N milliseconds.\n   * @example await Async.sleep(1000);\n   */\n  sleep: (ms: number) => new Promise(resolve => setTimeout(resolve, ms)),\n\n  /**\n   * Waits for the next Animation Frame.\n   */\n  nextFrame: () => new Promise(resolve => requestAnimationFrame(resolve)),\n\n  /**\n   * Retries a function N times with exponential backoff.\n   * \n   * @example\n   * const data = await Async.retry(() => api.get(), { retries: 3 });\n   */\n  retry: <T>(\n    fn: () => Promise<T>,\n    options: { retries?: number, delay?: number, factor?: number } = {}\n  ): Promise<T> => {\n    const { retries = 3, delay = 100, factor = 2 } = options;\n\n    return fn().catch(err => {\n      if (retries <= 0) throw err;\n      return Async.sleep(delay).then(() =>\n        Async.retry(fn, { retries: retries - 1, delay: delay * factor, factor })\n      );\n    });\n  },\n\n  /**\n   * Races a promise against a timeout.\n   * Throws 'TimeoutError' if time limit exceeded.\n   * \n   * @example\n   * await Async.timeout(fetch('/long'), 5000);\n   */\n  timeout: <T>(promise: Promise<T>, ms: number): Promise<T> => {\n    return Promise.race([\n      promise,\n      new Promise<T>((_, reject) => setTimeout(() => reject(new Error('TimeoutError')), ms))\n    ]);\n  },\n\n  /**\n   * Limits concurrency of a map function.\n   * Useful for batch processing without flooding the network.\n   * \n   * @example\n   * await Async.map(userIds, fetchUser, 2); // 2 at a time\n   */\n  map: async <T, R>(\n    items: T[],\n    fn: (item: T, index: number) => Promise<R>,\n    concurrency: number = Infinity\n  ): Promise<R[]> => {\n    const results: R[] = [];\n    const queue = items.map((item, i) => ({ item, i }));\n\n    const worker = async () => {\n      while (queue.length > 0) {\n        const { item, i } = queue.shift()!;\n        results[i] = await fn(item, i);\n      }\n    };\n\n    await Promise.all(Array.from({ length: Math.min(items.length, concurrency) }, worker));\n    return results;\n  },\n\n  /**\n   * Creates a \"Deferred\" promise object (exposed resolve/reject).\n   * \n   * @example\n   * const { promise, resolve } = Async.defer();\n   */\n  defer: <T>() => {\n    let resolve!: (value: T | PromiseLike<T>) => void;\n    let reject!: (reason?: any) => void;\n    const promise = new Promise<T>((res, rej) => { resolve = res; reject = rej; });\n    return { promise, resolve, reject };\n  },\n\n  /**\n   * Wraps a promise to make it \"Cancelable\" (wrapper only).\n   * Note: Does not stop the underlying operation, just ignores the result.\n   */\n  cancelable: <T>(promise: Promise<T>) => {\n    let isCanceled = false;\n    const wrapped = new Promise<T>((resolve, reject) => {\n      promise.then(\n        val => !isCanceled && resolve(val),\n        err => !isCanceled && reject(err)\n      );\n    });\n    return {\n      promise: wrapped,\n      cancel: () => { isCanceled = true; }\n    };\n  }\n};\n\n// =============================================================================\n// 35. TASK QUEUE\n// =============================================================================\n\n/**\n * Creates a Task Queue with concurrency control.\n * Useful for throttling API calls, toasts, or sequential animations.\n * \n * @example\n * const q = createQueue({ concurrency: 1 });\n * q.add(() => api.save(A));\n * q.add(() => api.save(B));\n * await q.drain();\n */\nexport const createQueue = (options: { concurrency?: number, autoStart?: boolean } = {}) => {\n  type Task<T = any> = () => Promise<T> | T;\n\n  const concurrency = options.concurrency || 1;\n  const queue: { fn: Task, resolve: Function, reject: Function }[] = [];\n  let active = 0;\n  let isPaused = !options.autoStart && options.autoStart !== undefined;\n\n  // Event listeners\n  const listeners: Record<string, Function[]> = {\n    drain: [],\n    error: []\n  };\n\n  const next = () => {\n    if (isPaused || active >= concurrency || queue.length === 0) {\n      if (active === 0 && queue.length === 0) listeners.drain.forEach(fn => fn());\n      return;\n    }\n\n    const job = queue.shift();\n    if (!job) return;\n\n    active++;\n\n    Promise.resolve()\n      .then(() => job.fn())\n      .then(res => job.resolve(res))\n      .catch(err => {\n        listeners.error.forEach(fn => fn(err));\n        job.reject(err);\n      })\n      .finally(() => {\n        active--;\n        next();\n      });\n\n    next(); // Try to start more if concurrency allows\n  };\n\n  return {\n    /** Adds a task to the queue. Returns a promise that resolves when the task finishes. */\n    add: <T>(fn: Task<T>): Promise<T> => {\n      return new Promise((resolve, reject) => {\n        queue.push({ fn, resolve, reject });\n        next();\n      });\n    },\n\n    /** Pauses processing. Active tasks complete, but new ones wait. */\n    pause: () => { isPaused = true; },\n\n    /** Resumes processing. */\n    resume: () => { isPaused = false; next(); },\n\n    /** Clears all pending tasks. */\n    clear: () => { queue.length = 0; },\n\n    /** Returns the number of pending + active tasks. */\n    size: () => queue.length + active,\n\n    /** Returns a promise that resolves when all tasks are complete. */\n    drain: () => new Promise<void>(resolve => {\n      if (active === 0 && queue.length === 0) return resolve();\n      listeners.drain.push(resolve);\n    }),\n\n    /** Listen for errors (globally for the queue). */\n    onError: (fn: (err: any) => void) => listeners.error.push(fn)\n  };\n};\n\n// =============================================================================\n// 36. HISTORY & URL STATE\n// =============================================================================\n\n/**\n * Valid types for URL Query Parameters.\n */\nexport type QueryValue = string | number | boolean | null | undefined;\nexport type QueryParams = Record<string, QueryValue | QueryValue[]>;\n\nexport const History = {\n  /**\n   * Updates the URL Query Parameters with new values.\n   * Merges with existing params. Pass `null` or `undefined` to remove a key.\n   * Handles arrays as repeated params (e.g., `?tag=a&tag=b`).\n   * \n   * Order: params -> (mode?)\n   * \n   * @example \n   * // Results in ?page=2&sort=desc\n   * History.query({ page: 2, sort: 'desc' })(); \n   * \n   * // Replace history instead of push\n   * History.query({ tab: 'settings' })('replace');\n   */\n  query: (params: QueryParams) => (mode: 'push' | 'replace' = 'push') => {\n    const url = new URL(window.location.href);\n\n    Object.entries(params).forEach(([k, v]) => {\n      // 1. Remove existing keys to overwrite/clear them\n      url.searchParams.delete(k);\n\n      // 2. Set new values\n      if (v === null || v === undefined || v === '') return;\n\n      if (Array.isArray(v)) {\n        v.forEach(item => url.searchParams.append(k, String(item)));\n      } else {\n        url.searchParams.set(k, String(v));\n      }\n    });\n\n    const method = mode === 'replace' ? 'replaceState' : 'pushState';\n    window.history[method](window.history.state, '', url.href);\n  },\n\n  /**\n   * Reads current Query Parameters into a typed Object.\n   * Note: duplicate keys (arrays) will return the *last* value, \n   * use `History.readQueryAll()` if you expect arrays.\n   * \n   * @template T\n   * @returns {T}\n   * \n   * @example \n   * const { page, sort } = History.readQuery<{ page: string, sort: string }>();\n   */\n  readQuery: <T extends Record<string, string>>(): T => {\n    return Object.fromEntries(new URLSearchParams(window.location.search)) as unknown as T;\n  },\n\n  /**\n   * Reads Query Parameters, ensuring all values are arrays.\n   * Useful for filters like `?tags=a&tags=b`.\n   */\n  readQueryAll: (): Record<string, string[]> => {\n    const params: Record<string, string[]> = {};\n    new URLSearchParams(window.location.search).forEach((val, key) => {\n      (params[key] = params[key] || []).push(val);\n    });\n    return params;\n  },\n\n  /**\n   * Pushes a new entry onto the history stack with optional state.\n   * \n   * @template T - Type of the state object\n   * @example History.push('/profile', { userId: 123 });\n   */\n  push: <T = any>(path: string, state?: T) => {\n    window.history.pushState(state, '', path);\n  },\n\n  /**\n   * Replaces the current history entry.\n   * \n   * @template T - Type of the state object\n   * @example History.replace(window.location.pathname, { scrolled: true });\n   */\n  replace: <T = any>(path: string, state?: T) => {\n    window.history.replaceState(state, '', path);\n  },\n\n  /**\n   * Gets the current history state object with Type Safety.\n   * \n   * @template T\n   * @example const state = History.state<{ userId: number }>();\n   */\n  state: <T>(): T | null => {\n    return window.history.state as T;\n  },\n\n  /**\n   * Navigates back in history.\n   */\n  back: () => window.history.back(),\n\n  /**\n   * Navigates forward in history.\n   */\n  forward: () => window.history.forward(),\n\n  /**\n   * Reloads the current page.\n   */\n  reload: () => window.location.reload(),\n\n  /**\n   * Listens for history changes (Back/Forward buttons).\n   * Returns a cleanup function.\n   * \n   * @example \n   * const stop = History.onPop(e => console.log('Navigated to', e.state));\n   */\n  onPop: (handler: (e: PopStateEvent) => void): Unsubscribe => {\n    window.addEventListener('popstate', handler);\n    return () => window.removeEventListener('popstate', handler);\n  },\n\n  /**\n   * Serializes an object to a Unicode-safe Base64 string.\n   * Useful for storing complex state in the URL hash.\n   * \n   * @example window.location.hash = History.encodeState({ filters: [...] });\n   */\n  encodeState: (state: any): string => {\n    try {\n      const json = JSON.stringify(state);\n      // encodeURIComponent handles Unicode chars that btoa chokes on\n      return btoa(encodeURIComponent(json).replace(/%([0-9A-F]{2})/g,\n        (_, p1) => String.fromCharCode(parseInt(p1, 16))\n      ));\n    } catch { return ''; }\n  },\n\n  /**\n   * Deserializes a Base64 string back to an object.\n   */\n  decodeState: <T>(str: string): T | null => {\n    try {\n      const json = decodeURIComponent(Array.prototype.map.call(atob(str),\n        (c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n      ).join(''));\n      return JSON.parse(json);\n    } catch { return null; }\n  },\n\n  /**\n * Two-way binds a form input to a URL Query Parameter.\n * \n * Features:\n * 1. Sets input value from URL on load.\n * 2. Updates URL on input change (debounced).\n * 3. Updates input on PopState (Back/Forward button).\n * \n * Order: paramName -> debounceMs -> element\n * \n * @example \n * const searchInput = find(document)('#search');\n * History.syncToUrl('q', 300)(searchInput);\n */\n  syncToUrl: (paramName: string, debounceMs = 300) => (target: HTMLElement | null): Unsubscribe => {\n    if (!target) return () => { };\n\n    // Determine if element is Checkbox/Radio or Text-like\n    const isCheckable = (target as HTMLInputElement).type === 'checkbox' || (target as HTMLInputElement).type === 'radio';\n\n    // 1. READ: Function to update DOM from URL\n    const updateFromUrl = () => {\n      const val = new URLSearchParams(window.location.search).get(paramName);\n      if (val === null) return; // No param = do nothing (or clear?)\n\n      if (isCheckable) {\n        (target as HTMLInputElement).checked = val === 'true';\n      } else {\n        (target as HTMLInputElement).value = val;\n      }\n    };\n\n    // 2. WRITE: Function to update URL from DOM\n    const updateToUrl = debounce(() => {\n      const val = isCheckable\n        ? String((target as HTMLInputElement).checked)\n        : (target as HTMLInputElement).value;\n\n      History.query({ [paramName]: val })('replace');\n    }, debounceMs);\n\n    // 3. BIND: Attach listeners\n    updateFromUrl(); // Initial sync\n\n    target.addEventListener('input', updateToUrl);\n    target.addEventListener('change', updateToUrl);\n    window.addEventListener('popstate', updateFromUrl);\n\n    // Cleanup\n    return () => {\n      target.removeEventListener('input', updateToUrl);\n      target.removeEventListener('change', updateToUrl);\n      window.removeEventListener('popstate', updateFromUrl);\n    };\n  }\n}\n\n// =============================================================================\n// 0.1 FUNCTIONAL COMBINATORS\n// =============================================================================\n\nexport const Fn = {\n  /**\n   * Standard Left-to-Right composition.\n   * Passes the output of one function as the input to the next.\n   * @example pipe(getName, toUpper, log)(user);\n   */\n  pipe: <T>(...fns: Function[]) => (x: T) => fns.reduce((v, f) => f(v), x),\n\n  /**\n   * Curries a binary function.\n   * Turns `fn(a, b)` into `fn(a)(b)`.\n   * @example const add = curry((a, b) => a + b); add(1)(2);\n   */\n  curry: <A, B, R>(fn: (a: A, b: B) => R) => (a: A) => (b: B): R => fn(a, b),\n\n  /**\n   * Swaps the arguments of a curried function.\n   * Turns `fn(a)(b)` into `fn(b)(a)`.\n   * Useful for converting \"Config-First\" to \"Target-First\" or vice versa.\n   * \n   * @example \n   * // Suppose style(prop)(el)\n   * const styleEl = swap(style)(el);\n   * styleEl('color');\n   */\n  swap: <A, B, R>(fn: (a: A) => (b: B) => R) => (b: B) => (a: A): R => fn(a)(b),\n\n  /**\n   * Flips the arguments of a standard binary function.\n   * Turns `fn(a, b)` into `fn(b, a)`.\n   */\n  flip: <A, B, R>(fn: (a: A, b: B) => R) => (b: B, a: A): R => fn(a, b),\n\n  /**\n   * Executes a side-effect function and returns the original value.\n   * Essential for logging or debugging inside a `pipe` chain without breaking it.\n   * \n   * @example pipe(modify({...}), tap(console.log), addClass('active'))(el);\n   */\n  tap: <T>(fn: (x: T) => void) => (x: T): T => {\n    fn(x);\n    return x;\n  },\n\n  /**\n   * Executes a function only if the value is not null/undefined.\n   * Useful wrapper for standard API functions that might crash on null.\n   * \n   * @example const safeParse = maybe(JSON.parse);\n   */\n  maybe: <T, R>(fn: (x: T) => R) => (x: T | null | undefined): R | null => {\n    return (x === null || x === undefined) ? null : fn(x);\n  },\n\n  /**\n   * Creates a function that accepts data as the *first* argument, \n   * but applies it to a curried function expecting data *last*.\n   * \n   * Adapts `fn(config)(data)` to `fn(data, config)`.\n   */\n  unbind: <D, C, R>(fn: (config: C) => (data: D) => R) => (data: D, config: C): R => {\n    return fn(config)(data);\n  },\n\n  /**\n   * \"Thunks\" a function. Returns a function that accepts no arguments \n   * and returns the result of the original call.\n   * Useful for event handlers that don't need the event object.\n   * \n   * @example on(btn)('click', thunk(count, increment));\n   */\n  thunk: <T>(fn: (...args: any[]) => T, ...args: any[]) => () => fn(...args),\n\n  /**\n   * Returns the value unchanged.\n   * Useful as a default no-op callback.\n   */\n  identity: <T>(x: T): T => x,\n\n  /**\n   * A function that does nothing.\n   */\n  noop: () => { }\n};\n\n// =============================================================================\n// 37. ERROR HANDLING (RESULT & OPTION)\n// =============================================================================\n\n/**\n * Represents a successful computation.\n */\nexport type Ok<T> = { ok: true; val: T; err: null };\n\n/**\n * Represents a failed computation.\n */\nexport type Err<E> = { ok: false; val: null; err: E };\n\n/**\n * A Result type (inspired by Rust) that is either Ok or Err.\n * Forces you to check `.ok` before accessing the value.\n */\nexport type Result<T, E = Error> = Ok<T> | Err<E>;\n\nexport const Result = {\n  /** Creates a success result. */\n  ok: <T>(val: T): Ok<T> => ({ ok: true, val, err: null }),\n\n  /** Creates a failure result. */\n  err: <E>(err: E): Err<E> => ({ ok: false, val: null, err }),\n\n  /**\n   * Wraps a synchronous function that might throw.\n   * Returns a Result object instead of throwing.\n   * \n   * @example\n   * const res = Result.try(() => JSON.parse(badString));\n   * if (!res.ok) console.error(res.err);\n   */\n  try: <T>(fn: () => T): Result<T, Error> => {\n    try {\n      return Result.ok(fn());\n    } catch (e) {\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\n    }\n  },\n\n  /**\n   * Wraps a Promise that might reject.\n   * Returns a Promise<Result>.\n   * \n   * @example\n   * const { ok, val, err } = await Result.async(() => fetch('/api'));\n   */\n  async: async <T>(fn: () => Promise<T>): Promise<Result<T, Error>> => {\n    try {\n      const val = await fn();\n      return Result.ok(val);\n    } catch (e) {\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\n    }\n  },\n\n  /**\n   * Unwraps a Result. Returns value if Ok, throws if Err.\n   */\n  unwrap: <T, E>(res: Result<T, E>): T => {\n    if (res.ok) return res.val;\n    throw res.err;\n  },\n\n  /**\n   * Unwraps a Result with a fallback value.\n   */\n  unwrapOr: <T, E>(res: Result<T, E>, fallback: T): T => {\n    return res.ok ? res.val : fallback;\n  },\n\n  /**\n   * Maps the value if Ok, ignores if Err.\n   */\n  map: <T, U, E>(res: Result<T, E>, fn: (v: T) => U): Result<U, E> => {\n    return res.ok ? Result.ok(fn(res.val)) : res as unknown as Err<E>;\n  }\n};\n\n\n// =============================================================================\n// 38. OPTION (NULLABLE HANDLING)\n// =============================================================================\n\n/**\n * Functional wrapper for nullable values.\n */\nexport const Option = {\n  /**\n   * Creates an Option from a nullable value.\n   */\n  from: <T>(val: T | null | undefined) => ({\n    val,\n    isSome: val !== null && val !== undefined,\n    isNone: val === null || val === undefined\n  }),\n\n  /**\n   * Returns the value or a fallback.\n   * @example Option.unwrapOr(input, 'default');\n   */\n  unwrapOr: <T>(val: T | null | undefined, fallback: T): T => {\n    return (val !== null && val !== undefined) ? val : fallback;\n  },\n\n  /**\n   * Maps the value if it exists, returns null otherwise.\n   * @example const len = Option.map(str, s => s.length);\n   */\n  map: <T, R>(val: T | null | undefined, fn: (v: T) => R): R | null => {\n    return (val !== null && val !== undefined) ? fn(val) : null;\n  },\n\n  /**\n   * Executes side-effect if value exists.\n   * @example Option.then(element, el => el.remove());\n   */\n  then: <T>(val: T | null | undefined, fn: (v: T) => void): void => {\n    if (val !== null && val !== undefined) fn(val);\n  }\n};\n\n// =============================================================================\n// 39. REACTIVE BINDINGS (\"THE HARD WAY\" HELPERS)\n// =============================================================================\n\n/**\n * A Setter function that updates the DOM only if the value has changed.\n */\nexport type Setter<T> = (newValue: T) => void;\n\nexport const bind = {\n  /**\n   * Generic value binder with diffing.\n   * \n   * @example\n   * const setScore = bind.val(0, (n) => div.innerText = n);\n   */\n  val: <T>(initial: T, effect: (val: T) => void): Setter<T> => {\n    let current = initial;\n    return (next: T) => {\n      if (!Object.is(current, next)) {\n        current = next;\n        effect(next);\n      }\n    };\n  },\n\n  /**\n   * Binds textContent.\n   * @example const setText = bind.text(h1); setText('Hello');\n   */\n  text: (el: HTMLElement | null): Setter<string> => {\n    let current: string | undefined;\n    return (text: string) => {\n      if (el && current !== text) {\n        current = text;\n        el.textContent = text;\n      }\n    };\n  },\n\n  /**\n   * Binds innerHTML.\n   */\n  html: (el: HTMLElement | null): Setter<string> => {\n    let current: string | undefined;\n    return (html: string) => {\n      if (el && current !== html) {\n        current = html;\n        el.innerHTML = html;\n      }\n    };\n  },\n\n  /**\n   * Binds an attribute.\n   * Supports optional currying: `attr(name, el)` or `attr(name)(el)`.\n   * \n   * @example\n   * const setId = bind.attr('id', div); \n   * setId(123);\n   */\n  attr: (name: string, el?: HTMLElement | null) => {\n    const createSetter = (target: HTMLElement | null): Setter<string | number | boolean | null> => {\n      let current: any;\n      return (val) => {\n        if (!target || current === val) return;\n        current = val;\n        if (val === null || val === false) target.removeAttribute(name);\n        else target.setAttribute(name, String(val));\n      };\n    };\n    // Handle optional currying\n    return el !== undefined ? createSetter(el) : createSetter;\n  },\n\n  /**\n   * Binds a class toggle.\n   * Supports optional currying.\n   * \n   * @example const toggleActive = bind.toggle('active', div);\n   */\n  toggle: (className: string, el?: HTMLElement | null) => {\n    const createSetter = (target: HTMLElement | null): Setter<boolean> => {\n      let current: boolean | undefined;\n      return (active) => {\n        if (!target || current === active) return;\n        current = active;\n        target.classList.toggle(className, active);\n      };\n    };\n    return el !== undefined ? createSetter(el) : createSetter;\n  },\n\n  /**\n   * Binds a list to a container.\n   * Replaces children only if array reference changes.\n   * \n   * @example \n   * const updateList = bind.list(ul, (user, i) => el('li')({ text: user.name })());\n   * updateList(users);\n   */\n  list: <T>(container: HTMLElement | null, renderItem: (item: T, index: number) => Node) => {\n    let currentData: T[] | undefined;\n\n    return (data: T[]) => {\n      if (!container) return;\n      if (data === currentData) return; // Ref check\n\n      currentData = data;\n\n      // Optimization: fast clear if empty\n      if (data.length === 0) {\n        if (container.firstChild) container.replaceChildren();\n        return;\n      }\n\n      const fragment = document.createDocumentFragment();\n      data.forEach((item, i) => fragment.appendChild(renderItem(item, i)));\n      container.replaceChildren(fragment);\n    };\n  }\n};\n\n\n// =============================================================================\n// 40. VIEW FACTORY & BINDER GENERATOR\n// =============================================================================\n/**\n * Helper to bind multiple events to refs in one go.\n * \n * @example\n * bindEvents(refs, {\n *   btn: { click: handleClick },\n *   input: { input: handleInput, keydown: handleKey }\n * })\n */\nexport const bindEvents = <K extends string>(\n  refs: Record<K, HTMLElement>,\n  map: Partial<Record<K, Record<string, (e: Event, el: HTMLElement) => void>>>\n) => {\n  Object.entries(map).forEach(([refKey, events]) => {\n    const el = refs[refKey as K];\n    if (!el) return;\n\n    Object.entries(events as Record<string, any>).forEach(([evtName, handler]) => {\n      // Uses our standard 'on' function\n      on(el)(evtName as any, (e) => handler(e, el));\n    });\n  });\n};\n/**\n * Defines the shape of the Refs object returned by `view()`.\n * Use a generic to specify keys: `view<'title' | 'button'>`\n */\nexport type Refs<K extends string> = Record<K, HTMLElement>;\n\n/**\n * A factory for creating maintainable \"Hard Way\" views.\n * \n * @template K - The names of the data-ref attributes in the HTML.\n * @param htmlString - The HTML template string.\n */\nexport const view = <K extends string = string>(htmlString: string) => {\n  const tpl = document.createElement('template');\n  tpl.innerHTML = htmlString.trim();\n\n  /**\n   * Instantiates the view.\n   * @returns {{ root: HTMLElement | DocumentFragment, refs: Refs<K> }}\n   */\n  return () => {\n    const root = document.importNode(tpl.content, true);\n    const refs = {} as Refs<K>;\n\n    root.querySelectorAll('[data-ref]').forEach(el => {\n      const key = (el as HTMLElement).dataset.ref;\n      if (key) refs[key as K] = el as HTMLElement;\n    });\n\n    // Determine if we return a single root element or the fragment\n    const rootEl = (root.children.length === 1 ? root.firstElementChild : root) as HTMLElement | DocumentFragment;\n\n    return { root: rootEl, refs };\n  };\n};\n\n/**\n * A helper to generate a typed object of Setters from a Refs object.\n * This reduces the boilerplate of creating individual binders manually.\n * \n * @example\n * const { refs } = createCard();\n * const ui = binder(refs, {\n *   title: bind.text,\n *   image: bind.attr('src'),\n *   active: bind.toggle('is-active')\n * });\n * \n * // Usage\n * ui.title('Hello');\n * ui.active(true);\n */\nexport const binder = <\n  R extends Record<string, HTMLElement>,\n  Schema extends { [Key in keyof R]?: (el: HTMLElement) => Setter<any> }\n>(\n  refs: R,\n  schema: Schema\n): { [Key in keyof Schema]: Schema[Key] extends (el: any) => infer S ? S : never } => {\n  const binders = {} as any;\n  for (const key in schema) {\n    if (refs[key]) {\n      // @ts-ignore\n      binders[key] = schema[key](refs[key]);\n    }\n  }\n  return binders;\n};\n\n// =============================================================================\n// 41. HTTP FACTORY (TYPE-SAFE, FLEXIBLE, WITH DEFAULTS)\n// =============================================================================\n\n/**\n * HTTP request method type.\n */\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\n\n/**\n * HTTP response status code.\n */\nexport type HttpStatus = 200 | 201 | 204 | 400 | 401 | 403 | 404 | 405 | 409 | 422 | 429 | 500 | 502 | 503 | (number & {});\n\n/**\n * Flexible request init configuration.\n * Supports any standard Fetch API options plus custom extensions.\n * \n * @template T - Custom header type overrides\n */\nexport interface HttpRequestInit extends Omit<RequestInit, 'body'> {\n  /** Request body - auto-stringified if object */\n  body?: BodyInit | Record<string, any> | null;\n  /** Base URL to prepend (overrides Http defaults) */\n  baseURL?: string;\n  /** Query parameters to append */\n  params?: Record<string, string | number | boolean | null | undefined>;\n  /** Custom timeout in ms (0 = no timeout) */\n  timeout?: number;\n  /** Retry count on network failure (default: 0) */\n  retries?: number;\n  /** Delay between retries in ms (default: 1000) */\n  retryDelay?: number;\n  /** Transform response before returning */\n  transform?: (data: any) => any;\n}\n\n/**\n * HTTP response wrapper with metadata.\n * \n * @template T - The response data type\n * \n * @example\n * ```typescript\n * const res: HttpResponse<User> = await http.get('/users/1')({});\n * if (res.ok) console.log(res.data); // User\n * else console.error(res.statusText, res.error);\n * ```\n */\nexport interface HttpResponse<T = any> {\n  /** True if status is 2xx */\n  ok: boolean;\n  /** HTTP status code */\n  status: HttpStatus;\n  /** Status text (e.g., \"OK\", \"Not Found\") */\n  statusText: string;\n  /** Response data (parsed JSON, text, blob, etc.) */\n  data: T | null;\n  /** Error object if request failed */\n  error: Error | null;\n  /** Raw Fetch Response object */\n  response: globalThis.Response;\n}\n\n/**\n * HTTP client configuration.\n * Defines defaults for all requests made by this client.\n * \n * @template H - Custom header keys type\n */\nexport interface HttpConfig<H extends string = string> {\n  /** Base URL for all requests (e.g., \"https://api.example.com\") */\n  baseURL?: string;\n  /** Default headers for all requests */\n  headers?: Record<H | string, string>;\n  /** Default timeout in ms (0 = no timeout) */\n  timeout?: number;\n  /** Retry policy for network failures */\n  retries?: number;\n  /** Delay between retries */\n  retryDelay?: number;\n  /** Request interceptor (runs before fetch) */\n  interceptRequest?: (init: HttpRequestInit) => HttpRequestInit | Promise<HttpRequestInit>;\n  /** Response interceptor (runs after fetch) */\n  interceptResponse?: <T = any>(res: HttpResponse<T>) => HttpResponse<T> | Promise<HttpResponse<T>>;\n}\n\n/**\n * Merges two header objects with type safety.\n * @internal\n */\nconst _mergeHeaders = (\n  base: Record<string, string> | undefined,\n  override: Record<string, string> | undefined\n): Record<string, string> => {\n  return { ...base, ...override };\n};\n\n/**\n * Builds a full URL with optional base and params.\n * @internal\n */\nconst _buildUrl = (path: string, baseURL?: string, params?: Record<string, any>): string => {\n  let url = baseURL ? `${baseURL}${path}` : path;\n\n  if (params) {\n    const search = new URLSearchParams();\n    for (const [key, val] of Object.entries(params)) {\n      if (val !== null && val !== undefined) {\n        search.set(key, String(val));\n      }\n    }\n    const qs = search.toString();\n    if (qs) url += `${url.includes('?') ? '&' : '?'}${qs}`;\n  }\n\n  return url;\n};\n\n/**\n * Converts body to RequestInit.body format.\n * @internal\n */\nconst _encodeBody = (body: any): BodyInit | null => {\n  if (body === null || body === undefined) return null;\n  if (typeof body === 'string') return body;\n  if (body instanceof Blob) return body;\n  if (body instanceof FormData) return body;\n  if (body instanceof ArrayBuffer) return body;\n  // Object: serialize to JSON\n  return JSON.stringify(body);\n};\n\n/**\n * Parses response based on content-type.\n * @internal\n */\nconst _parseResponse = async (response: globalThis.Response, transform?: (data: any) => any): Promise<any> => {\n  const contentType = response.headers.get('content-type') || '';\n\n  let data: any;\n  if (contentType.includes('application/json')) {\n    try {\n      data = await response.json();\n    } catch {\n      data = await response.text();\n    }\n  } else if (contentType.includes('text')) {\n    data = await response.text();\n  } else if (contentType.includes('image') || contentType.includes('video') || contentType.includes('audio')) {\n    data = await response.blob();\n  } else {\n    data = await response.arrayBuffer();\n  }\n\n  return transform ? transform(data) : data;\n};\n\n/**\n * Executes a fetch request with retry logic.\n * @internal\n */\nconst _fetchWithRetry = async (\n  url: string,\n  init: RequestInit,\n  retries: number = 0,\n  retryDelay: number = 1000,\n  timeout: number = 0\n): Promise<globalThis.Response> => {\n  const controller = new AbortController();\n  const timeoutId = timeout > 0 ? setTimeout(() => controller.abort(), timeout) : undefined;\n\n  try {\n    return await fetch(url, { ...init, signal: controller.signal });\n  } catch (error) {\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\n\n    // Retry on network error (not on HTTP error like 404)\n    if (retries > 0 && (error instanceof TypeError || error instanceof DOMException)) {\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\n      return _fetchWithRetry(url, init, retries - 1, retryDelay, timeout);\n    }\n\n    throw error;\n  } finally {\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\n  }\n};\n\n/**\n * Creates a type-safe HTTP client with flexible configuration.\n * \n * Advanced HTTP factory with full control: configure defaults per client,\n * override per-request, automatic retries, timeouts, interceptors, and more.\n * \n * Features:\n * - Fully type-safe with generics for request/response\n * - Automatic JSON serialization/deserialization\n * - Query parameter support with smart merging\n * - Configurable defaults (baseURL, headers, timeout, retries)\n * - Request/response interceptors (async support)\n * - Timeout support with AbortController\n * - Automatic retry on network failure\n * - Content-type detection (JSON, text, blob, etc.)\n * - Returns typed response object with metadata + helper methods\n * \n * @template H - Custom header keys (e.g., 'Authorization', 'X-Custom')\n * @param config - HTTP client configuration\n * @returns A configured Http client factory with GET, POST, PUT, DELETE, PATCH methods\n * \n * @example\n * ```typescript\n * // ===== BASIC SETUP =====\n * const api = HttpFactory.create({\n *   baseURL: 'https://api.example.com',\n *   headers: { 'X-API-Key': 'secret' },\n *   timeout: 5000,\n *   retries: 2\n * });\n * \n * // ===== TYPE-SAFE REQUESTS =====\n * interface User { id: number; name: string }\n * interface CreateUserPayload { name: string; email: string }\n * \n * // GET with automatic type inference\n * const res = await api.get<User>('/users/123')({});\n * if (res.ok) console.log(res.data.id); // data is User\n * \n * // POST with body and query params\n * const created = await api.post<User>('/users')({\n *   body: { name: 'Alice', email: 'alice@example.com' },\n *   params: { notify: true },\n *   timeout: 3000\n * });\n * \n * // ===== PER-REQUEST OVERRIDES =====\n * // Override baseURL for specific request\n * await api.get('/status')({\n *   baseURL: 'https://status.example.com'\n * });\n * \n * // Override timeout for slow endpoint\n * await api.get<Data>('/expensive-operation')({\n *   timeout: 30000,\n *   retries: 3\n * });\n * \n * // ===== INTERCEPTORS (AUTH, LOGGING, ERROR HANDLING) =====\n * const api = HttpFactory.create({\n *   baseURL: 'https://api.example.com',\n *   interceptRequest: async (init) => {\n *     // Add auth token dynamically\n *     const token = await getAuthToken();\n *     return {\n *       ...init,\n *       headers: {\n *         ...init.headers,\n *         'Authorization': `Bearer ${token}`\n *       }\n *     };\n *   },\n *   interceptResponse: async (res) => {\n *     // Global error handling\n *     if (res.status === 401) {\n *       await refreshAuth();\n *       // Retry logic would go here\n *     }\n *     return res;\n *   }\n * });\n * \n * // ===== RESPONSE HELPERS =====\n * const res = await api.get<User[]>('/users')({});\n * \n * // Check success\n * if (api.isOk(res)) {\n *   console.log(res.data); // Narrowed to User[]\n * }\n * \n * // Unwrap or throw\n * const users = api.unwrap(res); // throws if not ok\n * \n * // Unwrap with fallback\n * const users = api.unwrapOr(res, []); // returns [] if error\n * \n * // ===== TRANSFORMATION =====\n * await api.get<string[]>('/tags')({\n *   transform: (data) => data.map((t: any) => t.name) // Transform JSON before returning\n * });\n * ```\n */\nexport const Http = {\n  /**\n   * Creates a configured HTTP client with defaults.\n   * \n   * Use this for applications that need centralized configuration, interceptors,\n   * or per-client defaults (baseURL, timeout, retries, custom headers).\n   * \n   * For simple one-off requests, use the static methods: Http.get, Http.post, etc.\n   * \n   * @template H - Custom header keys type\n   * @param config - Client configuration\n   * @returns An Http client factory\n   * \n   * @example\n   * ```typescript\n   * const api = Http.create({\n   *   baseURL: 'https://api.example.com',\n   *   headers: { 'X-API-Key': 'secret' },\n   *   timeout: 5000,\n   *   retries: 2,\n   *   interceptRequest: async (init) => {\n   *     const token = await getAuthToken();\n   *     return {\n   *       ...init,\n   *       headers: { ...init.headers, 'Authorization': `Bearer ${token}` }\n   *     };\n   *   }\n   * });\n   * \n   * const user = await api.get<User>('/users/123')({});\n   * ```\n   */\n  create: <H extends string = string>(config: HttpConfig<H> = {}) => {\n    const {\n      baseURL: defaultBaseURL,\n      headers: defaultHeaders,\n      timeout: defaultTimeout = 0,\n      retries: defaultRetries = 0,\n      retryDelay: defaultRetryDelay = 1000,\n      interceptRequest,\n      interceptResponse\n    } = config;\n\n    /**\n     * Executes an HTTP request.\n     * @internal\n     */\n    const _request = async <T = any>(\n      method: HttpMethod,\n      path: string,\n      init: HttpRequestInit = {}\n    ): Promise<HttpResponse<T>> => {\n      const {\n        body,\n        baseURL = defaultBaseURL,\n        params,\n        timeout = defaultTimeout,\n        retries = defaultRetries,\n        retryDelay = defaultRetryDelay,\n        transform,\n        ...restInit\n      } = init;\n\n      // Merge headers (default + request-specific)\n      const headers = _mergeHeaders(\n        defaultHeaders as Record<string, string> | undefined,\n        restInit.headers as Record<string, string> | undefined\n      );\n\n      // Auto-set Content-Type for JSON bodies\n      if (body && typeof body === 'object' && !Array.isArray(body) && !(body instanceof FormData)) {\n        headers['Content-Type'] = 'application/json';\n      }\n\n      // Build fetch init\n      let fetchInit: any = {\n        ...restInit,\n        method,\n        headers\n      };\n\n      // Encode body\n      if (body !== undefined && body !== null) {\n        fetchInit.body = _encodeBody(body);\n      }\n\n      // Run request interceptor\n      if (interceptRequest) {\n        const intercepted = await interceptRequest(init);\n        fetchInit = { ...fetchInit, ...intercepted } as any;\n      }\n\n      // Build full URL with params\n      const url = _buildUrl(path, baseURL, params);\n\n      // Execute fetch with retry logic\n      let response: globalThis.Response;\n      try {\n        response = await _fetchWithRetry(url, fetchInit, retries, retryDelay, timeout);\n      } catch (error) {\n        const httpRes: HttpResponse<T> = {\n          ok: false,\n          status: 0,\n          statusText: 'Network Error',\n          data: null,\n          error: error instanceof Error ? error : new Error(String(error)),\n          response: null as any\n        };\n        return interceptResponse ? await interceptResponse(httpRes) : httpRes;\n      }\n\n      // Parse response data\n      let data: T | null = null;\n      try {\n        data = await _parseResponse(response, transform);\n      } catch (error) {\n        console.error('Failed to parse response:', error);\n      }\n\n      // Build response wrapper\n      const httpRes: HttpResponse<T> = {\n        ok: response.ok,\n        status: response.status as HttpStatus,\n        statusText: response.statusText,\n        data,\n        error: null,\n        response\n      };\n\n      // Run response interceptor\n      return interceptResponse ? await interceptResponse(httpRes) : httpRes;\n    };\n\n    return {\n      /**\n       * Performs a GET request.\n       * \n       * @template T - Response data type\n       * @param path - Endpoint path (e.g., '/users/123')\n       * @returns A curried function that accepts request config\n       * \n       * @example\n       * ```typescript\n       * const res = await http.get<User>('/users/123')({});\n       * ```\n       */\n      get: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('GET', path, init),\n\n      /**\n       * Performs a POST request.\n       * \n       * @template T - Response data type\n       * @param path - Endpoint path\n       * @returns A curried function that accepts request config with body\n       * \n       * @example\n       * ```typescript\n       * const res = await http.post<Created>('/users')({\n       *   body: { name: 'John' }\n       * });\n       * ```\n       */\n      post: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('POST', path, init),\n\n      /**\n       * Performs a PUT request.\n       * \n       * @template T - Response data type\n       * @param path - Endpoint path\n       * @returns A curried function that accepts request config with body\n       */\n      put: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('PUT', path, init),\n\n      /**\n       * Performs a DELETE request.\n       * \n       * @template T - Response data type\n       * @param path - Endpoint path\n       * @returns A curried function that accepts request config\n       */\n      delete: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('DELETE', path, init),\n\n      /**\n       * Performs a PATCH request.\n       * \n       * @template T - Response data type\n       * @param path - Endpoint path\n       * @returns A curried function that accepts request config with body\n       */\n      patch: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('PATCH', path, init),\n\n      /**\n       * Checks if an HTTP response is successful (2xx).\n       * \n       * @example\n       * ```typescript\n       * const res = await http.get('/users')({});\n       * if (http.isOk(res)) {\n       *   // res.data is guaranteed to be of the generic type\n       * }\n       * ```\n       */\n      isOk: <T = any>(res: HttpResponse<T>): res is HttpResponse<T> & { data: T } => res.ok,\n\n      /**\n       * Unwraps response data or throws on error.\n       * \n       * @example\n       * ```typescript\n       * const users = http.unwrap(await http.get<User[]>('/users')({}));\n       * ```\n       */\n      unwrap: <T = any>(res: HttpResponse<T>): T => {\n        if (!res.ok) throw res.error || new Error(`HTTP ${res.status}: ${res.statusText}`);\n        return res.data as T;\n      },\n\n      /**\n       * Unwraps response data or returns fallback on error.\n       * \n       * @example\n       * ```typescript\n       * const users = http.unwrapOr(\n       *   await http.get<User[]>('/users')({}),\n       *   []\n       * );\n       * ```\n       */\n      unwrapOr: <T = any>(res: HttpResponse<T>, fallback: T): T => {\n        return res.ok ? (res.data as T) : fallback;\n      }\n    };\n  },\n\n  /**\n   * Performs a simple GET request without client configuration.\n   * \n   * Throws an error if the response is not ok (non-2xx status).\n   * \n   * **Error Handling**: Error message includes status code and text.\n   * \n   * @template T - The expected response type\n   * @param url - The URL to fetch from\n   * @param headers - Optional request headers\n   * @returns Promise resolving to parsed JSON response\n   * @throws Error if response is not ok\n   * \n   * @example\n   * ```typescript\n   * // Basic GET\n   * const users = await Http.get<User[]>('/api/users');\n   * \n   * // With custom headers\n   * const data = await Http.get<Data>('/api/data', {\n   *   'Authorization': 'Bearer token',\n   *   'Accept-Language': 'en-US'\n   * });\n   * \n   * // Error handling\n   * try {\n   *   const user = await Http.get<User>('/api/user/999');\n   * } catch (error) {\n   *   // Error message: \"Http.get 404: Not Found\"\n   *   console.error(error);\n   * }\n   * ```\n   */\n  get: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\n    const res = await fetch(url, { headers });\n    if (!res.ok) throw new Error(`Http.get ${res.status}: ${res.statusText}`);\n    return res.json();\n  },\n\n  /**\n   * Performs a simple POST request without client configuration.\n   * \n   * **Curried API**: url -> body -> headers for composition and reusability.\n   * \n   * Throws an error if the response is not ok.\n   * \n   * @template T - The expected response type\n   * @param url - The URL to post to\n   * @returns A curried function accepting body then headers\n   * \n   * @example\n   * ```typescript\n   * // Basic POST\n   * const user = await Http.post('/api/users')\n   *   ({ name: 'John', email: 'john@example.com' })\n   *   ();\n   * \n   * // With auth headers\n   * const response = await Http.post('/api/login')\n   *   ({ username: 'admin', password: 'secret' })\n   *   ({ 'X-CSRF-Token': csrfToken });\n   * \n   * // Partial application\n   * const createUser = Http.post('/api/users');\n   * const user1 = await createUser({ name: 'Alice' })();\n   * const user2 = await createUser({ name: 'Bob' })();\n   * ```\n   */\n  post: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json', ...headers },\n      body: JSON.stringify(body)\n    });\n    if (!res.ok) throw new Error(`Http.post ${res.status}: ${res.statusText}`);\n    return res.json();\n  },\n\n  /**\n   * Performs a simple PUT request without client configuration.\n   * \n   * **Curried API**: url -> body -> headers for composition and reusability.\n   * \n   * Throws an error if the response is not ok.\n   * \n   * @template T - The expected response type\n   * @param url - The URL to put to\n   * @returns A curried function accepting body then headers\n   * \n   * @example\n   * ```typescript\n   * // Update resource\n   * const updated = await Http.put('/api/users/123')\n   *   ({ name: 'John Updated', email: 'new@example.com' })\n   *   ({ 'Authorization': `Bearer ${token}` });\n   * \n   * // Partial application\n   * const updateUser = (id: number) => Http.put(`/api/users/${id}`);\n   * await updateUser(123)({ name: 'Alice' })();\n   * ```\n   */\n  put: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\n    const res = await fetch(url, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json', ...headers },\n      body: JSON.stringify(body)\n    });\n    if (!res.ok) throw new Error(`Http.put ${res.status}: ${res.statusText}`);\n    return res.json();\n  },\n\n  /**\n   * Performs a simple DELETE request without client configuration.\n   * \n   * Throws an error if the response is not ok.\n   * \n   * @template T - The expected response type (often void or { success: boolean })\n   * @param url - The URL to delete\n   * @param headers - Optional request headers\n   * @returns Promise resolving to parsed JSON response\n   * @throws Error if response is not ok\n   * \n   * @example\n   * ```typescript\n   * // Delete resource\n   * await Http.delete('/api/users/123', {\n   *   'Authorization': `Bearer ${token}`\n   * });\n   * \n   * // With confirmation\n   * const result = await Http.delete<{ success: boolean }>(\n   *   '/api/posts/456',\n   *   { 'Authorization': `Bearer ${token}` }\n   * );\n   * if (result.success) {\n   *   remove(postElement);\n   * }\n   * ```\n   */\n  delete: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\n    const res = await fetch(url, { method: 'DELETE', headers });\n    if (!res.ok) throw new Error(`Http.delete ${res.status}: ${res.statusText}`);\n    return res.json();\n  }\n};\n\n/**\n * Narrows an element to a more specific type using a CSS selector.\n *\n * Usage:\n *   const input = cast(\"input[type=email]\")(el);\n *\n * Returns:\n *   - el (narrowed) if it matches\n *   - null otherwise\n */\nexport function cast<S extends string>(selector: S) {\n  return <T extends Element>(el: T | null): ParseSelector<S> | null => {\n    if (!el) return null;\n    return el.matches(selector)\n      ? (el as unknown as ParseSelector<S>)\n      : null;\n  };\n}\n\n/**\n * Type guard: checks if a node is an Element.\n */\nexport function isElement(node: Node | null): node is Element {\n  return node instanceof Element;\n}\n\n/**\n * Type guard: narrows an element to a specific tag type based on tag name.\n *\n * Example:\n *   nodes.filter(isTag(\"button\")) // HTMLButtonElement[]\n */\nexport function isTag<K extends keyof HTMLElementTagNameMap>(tag: K) {\n  return (el: Element | null): el is HTMLElementTagNameMap[K] => {\n    return !!el && el.tagName.toLowerCase() === tag.toLowerCase();\n  };\n}\n\n/**\n * Checks whether an element is visible within the viewport or a custom scroll root.\n *\n * **Usage styles:**\n *\n * **1. Element-first**\n * ```ts\n * const visible = isInViewport(myDiv);\n * ```\n *\n * **2. Selector-first**\n * ```ts\n * const visible = isInViewport(\".item\");\n * ```\n *\n * **3. Curried**\n * ```ts\n * const check = isInViewport(\".item\");\n * const visible = check({ partial: true });\n * ```\n *\n * **4. Fully-Curried (element first, options later)**\n * ```ts\n * const withOptions = isInViewport(myDiv);\n * const visible = withOptions({ threshold: 0.5 });\n * ```\n *\n * ---\n *\n * **Visibility semantics**\n *\n * The function defaults to **full visibility**, meaning the element must be\n * entirely inside the bounding box of the viewport (or of `root`, if provided).\n *  \n * Use options to relax or refine the check:\n *\n * - `partial?: boolean` ‚Äî true if **any part** intersects the root.\n * - `threshold?: number` ‚Äî percentage of the element that must be visible (0‚Äì1).\n *   Overrides `partial`/`full` semantics.\n * - `margin?: number | { top?: number; right?: number; bottom?: number; left?: number }`\n *   ‚Äî expands or contracts the root bounds.\n * - `root?: Element | Document` ‚Äî custom scroll container; defaults to viewport.\n *\n * ---\n *\n * **Selector behavior**\n *\n * When passed a string selector, the function queries the element from\n * `document`. If the selector does not match anything, the function returns\n * `false`.\n *\n * ---\n *\n * **Examples**\n *\n * **Check if fully visible**\n * ```ts\n * isInViewport(myDiv); // true or false\n * ```\n *\n * **Check if partially visible**\n * ```ts\n * isInViewport(myDiv, { partial: true });\n * ```\n *\n * **Require at least 60% visibility**\n * ```ts\n * isInViewport(myDiv, { threshold: 0.6 });\n * ```\n *\n * **Use margin to treat near-visibility as visible**\n * ```ts\n * isInViewport(myDiv, { margin: 50 });\n * ```\n *\n * **Use another scroll root**\n * ```ts\n * const scroller = document.querySelector(\".scroll-area\")!;\n * isInViewport(myDiv, { root: scroller });\n * ```\n *\n * @template S - CSS selector literal used to type-narrow elements when\n *               calling with a selector string.\n */\nexport function isInViewport<S extends string>(\n  elOrSelector?: Element | null | S\n):\n  | boolean\n  | ((\n    options?: {\n      /**\n       * Allow partial visibility.  \n       * default: false (element must be fully inside)\n       */\n      partial?: boolean;\n\n      /**\n       * Percentage of element that must be visible (0‚Äì1).  \n       * Overrides `partial`. default: 1 (fully visible)\n       */\n      threshold?: number;\n\n      /**\n       * Custom viewport root (e.g., a scroll container).\n       * default: window viewport\n       */\n      root?: Element | null;\n\n      /**\n       * Margin (CSS margin syntax: \"10px\", \"10px 20px\", etc.)\n       * Expands or contracts the effective viewport.\n       */\n      margin?: string;\n    }\n  ) => boolean) {\n  // --- Selector-first mode ---\n  if (typeof elOrSelector === \"string\") {\n    const el = document.querySelector(elOrSelector);\n    if (!el) return false;\n    return inViewport(el, {});\n  }\n\n  // --- Element-first or null-safe curried ---\n  const el = elOrSelector ?? null;\n\n  return (options?: {\n    partial?: boolean;\n    threshold?: number;\n    root?: Element | null;\n    margin?: string;\n  }): boolean => {\n    if (!el) return false;\n    return inViewport(el, options ?? {});\n  };\n}\n\n/**\n * Internal utility performing the actual visibility check.\n */\nfunction inViewport(\n  el: Element,\n  {\n    partial = false,\n    threshold,\n    root = null,\n    margin\n  }: {\n    partial?: boolean;\n    threshold?: number;\n    root?: Element | null;\n    margin?: string;\n  }\n): boolean {\n  const rect = el.getBoundingClientRect();\n\n  // Parse margin offsets\n  const margins = parseMargin(margin);\n\n  // Viewport or custom root bounds\n  const containerRect = root\n    ? root.getBoundingClientRect()\n    : {\n      top: 0,\n      left: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight\n    };\n\n  // Apply margin adjustments\n  const vp = {\n    top: containerRect.top + margins.top,\n    left: containerRect.left + margins.left,\n    right: containerRect.right - margins.right,\n    bottom: containerRect.bottom - margins.bottom\n  };\n\n  const elementArea = rect.width * rect.height;\n  if (elementArea === 0) return false;\n\n  const intersection = {\n    top: Math.max(rect.top, vp.top),\n    left: Math.max(rect.left, vp.left),\n    right: Math.min(rect.right, vp.right),\n    bottom: Math.min(rect.bottom, vp.bottom)\n  };\n\n  const intersectWidth = intersection.right - intersection.left;\n  const intersectHeight = intersection.bottom - intersection.top;\n\n  if (intersectWidth <= 0 || intersectHeight <= 0) return false;\n\n  const visibleArea = intersectWidth * intersectHeight;\n\n  // Threshold overrides all other options\n  if (typeof threshold === \"number\") {\n    return visibleArea / elementArea >= threshold;\n  }\n\n  // Full visibility (default)\n  if (!partial) {\n    return (\n      rect.top >= vp.top &&\n      rect.left >= vp.left &&\n      rect.right <= vp.right &&\n      rect.bottom <= vp.bottom\n    );\n  }\n\n  // Partial visibility\n  return visibleArea > 0;\n}\n\n/**\n * Parses CSS-like margin strings (\"10px 20px\").\n */\nfunction parseMargin(input?: string) {\n  if (!input) return { top: 0, left: 0, right: 0, bottom: 0 };\n\n  const parts = input.split(/\\s+/).map(p => parseInt(p, 10) || 0);\n\n  switch (parts.length) {\n    case 1:\n      return { top: parts[0], right: parts[0], bottom: parts[0], left: parts[0] };\n    case 2:\n      return { top: parts[0], right: parts[1], bottom: parts[0], left: parts[1] };\n    case 3:\n      return { top: parts[0], right: parts[1], bottom: parts[2], left: parts[1] };\n    case 4:\n    default:\n      return {\n        top: parts[0],\n        right: parts[1],\n        bottom: parts[2],\n        left: parts[3]\n      };\n  }\n}\n\n/* --------------------------------------------------------\n * Animation Helpers\n * -------------------------------------------------------- */\n/**\n * Animate an element using Web Animations API.\n *\n * Supports:\n * - Selector or element input\n * - Curried: animate(el)(keyframes, options)\n *\n * @example\n * ```ts\n * await animate(\".box\", { opacity: [0,1] }, { duration: 300 });\n * await animate(document.querySelector(\".box\"))({ transform: [\"scale(0)\",\"scale(1)\"] }, { duration: 500 });\n * ```\n */\nexport function animate(elOrSelector?: Element | string | null) {\n  if (typeof elOrSelector === \"string\") {\n    const el = document.querySelector(elOrSelector);\n    return (keyframes: Keyframe[], options?: KeyframeAnimationOptions) => el ? el.animate(keyframes, options).finished : Promise.resolve();\n  }\n  const el = elOrSelector ?? null;\n  return (keyframes: Keyframe[], options?: KeyframeAnimationOptions) => el ? el.animate(keyframes, options).finished : Promise.resolve();\n}\n\n\n\n\n/**\n * Sanitizes HTML by removing dangerous tags and attributes to prevent XSS.\n * \n * **Safety Features**:\n * - Removes `<script>`, `<iframe>`, `<object>`, `<embed>` tags.\n * - Removes all `on*` attributes (inline event handlers like `onclick`).\n * - Removes `javascript:` URIs in `href` and `src` attributes.\n * \n * **SECURITY WARNING**: While significantly safer than a raw innerHTML, this function \n * is lightweight and may not catch every sophisticated XSS vector. \n * For high-risk inputs (e.g., public comments, rich text from untrusted users), \n * use a dedicated library like DOMPurify.\n * \n * @template T - The return type (defaults to string, can be cast to TrustedHTML etc.)\n * @param html - The HTML string to sanitize\n * @returns The sanitized HTML string\n * \n * @example\n * ```typescript\n * // Removes scripts and handlers\n * const safe = sanitizeHTMLSimple('<div onclick=\"alert(1)\">Hello</div><script>...</script>');\n * // Result: \"<div>Hello</div>\"\n * \n * // Removes dangerous protocols\n * const safeLink = sanitizeHTMLSimple('<a href=\"javascript:alert(1)\">Link</a>');\n * // Result: \"<a>Link</a>\"\n * ```\n */\nexport function sanitizeHTMLSimple<T = string>(html: string): T {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n\n  const dangerousTags = ['script', 'iframe', 'object', 'embed'];\n\n  // 1. Remove dangerous tags\n  template.content.querySelectorAll(dangerousTags.join(',')).forEach(node => node.remove());\n\n  // 2. Sanitize attributes on all remaining elements\n  template.content.querySelectorAll('*').forEach(el => {\n    const attrs = el.getAttributeNames();\n    for (const attr of attrs) {\n      // Remove event handlers\n      if (attr.startsWith('on')) {\n        el.removeAttribute(attr);\n      }\n      // Remove javascript: protocol\n      else if (attr === 'href' || attr === 'src') {\n        const value = el.getAttribute(attr) || '';\n        if (value.toLowerCase().trim().startsWith('javascript:')) {\n          el.removeAttribute(attr);\n        }\n      }\n    }\n  });\n\n  return template.innerHTML as unknown as T;\n}\n\n/**\n * Extracts text content from an HTML string, removing all tags.\n * \n * Useful for:\n * - Generating plain text previews\n * - SEO descriptions\n * - Accessibility labels\n * - Safe text display\n * \n * @template T - The return type (defaults to string)\n * @param html - The HTML string to parse\n * @returns The plain text content\n * \n * @example\n * ```typescript\n * const text = sanitizeHTMLTextOnly('<h1>Hello <b>World</b></h1>');\n * // Result: \"Hello World\"\n * \n * // Handles entities\n * const decoded = sanitizeHTMLTextOnly('Fish &amp; Chips');\n * // Result: \"Fish & Chips\"\n * ```\n */\nexport function sanitizeHTMLTextOnly<T = string>(html: string): T {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return (template.content.textContent || '') as unknown as T;\n}\n\n\n// =============================================================================\n// 42. COMPONENT ARCHITECTURE (Release Candidate)\n// =============================================================================\n\n/**\n * Context object passed to the component setup function.\n * Provides a scoped, auto-cleaning sandbox for the component's logic.\n */\nexport interface ComponentContext<\n  Refs extends Record<string, HTMLElement> = any,\n  Groups extends Record<string, HTMLElement[]> = any,\n  State extends Record<string, any> = Record<string, any>\n> {\n  /** The root element of the component */\n  root: HTMLElement;\n\n  /** \n   * Map of single elements with `data-ref` attributes.\n   * Access is type-safe based on the generic provided.\n   */\n  refs: Refs;\n\n  /** \n   * Map of element arrays with `data-ref` attributes.\n   * Useful for lists (e.g., `groups.items.forEach(...)`).\n   */\n  groups: Groups;\n\n  /**\n   * Reactive Proxy for the root element's dataset.\n   * - Reading `state.foo` reads `data-foo` from the DOM.\n   * - Writing `state.foo = x` updates `data-foo` and triggers watchers.\n   */\n  state: State;\n\n  /**\n   * Scoped element finder (querySelector within root).\n   */\n  find: (selector: string) => HTMLElement | null;\n\n  /**\n   * Scoped element finder (querySelectorAll within root).\n   */\n  findAll: (selector: string) => HTMLElement[];\n\n  /**\n   * Adds an event listener that automatically cleans up when the component is destroyed.\n   * \n   * @overload Delegated event on the component root.\n   * @overload Direct event on a specific target element.\n   */\n  on<K extends keyof HTMLElementEventMap>(\n    event: K,\n    selector: string,\n    handler: (e: HTMLElementEventMap[K], target: HTMLElement) => void\n  ): void;\n  on<K extends keyof HTMLElementEventMap>(\n    event: K,\n    target: EventTarget,\n    handler: (e: HTMLElementEventMap[K], target: EventTarget) => void\n  ): void;\n\n  /**\n   * Watches a specific key in the component's state (DOM attributes) for changes.\n   * Fires immediately with current value, then on every change.\n   */\n  watch: (key: keyof State & string, handler: (val: any) => void) => void;\n\n  /**\n   * Establishes Two-Way Binding between a form input and a state key.\n   * - Input changes -> Update State\n   * - State changes -> Update Input value\n   */\n  bind: (input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, key: keyof State & string) => void;\n\n  /**\n   * Registers a cleanup function to run when the component is destroyed.\n   * (Equivalent to React's useEffect return function).\n   */\n  effect: (fn: Unsubscribe) => void;\n\n  /**\n   * Helper to attach an IntersectionObserver or ResizeObserver.\n   * Auto-disconnects on destroy.\n   */\n  observe: (\n    type: 'intersection' | 'resize',\n    target: Element,\n    callback: IntersectionObserverCallback | ResizeObserverCallback,\n    options?: object\n  ) => void;\n}\n\n/**\n * The public interface returned by a component instance.\n */\nexport type ComponentInstance<API> = API & {\n  /** The root element */\n  root: HTMLElement;\n  /** Destroys the component, removing all listeners and observers */\n  destroy: () => void;\n};\n\n/**\n * A lightweight component factory with automatic lifecycle management.\n * \n * Applies the **Setup Pattern** (similar to Vue 3 Composition API) to Vanilla DOM elements.\n * It binds a logic closure to a root element and provides a scoped `Context` toolkit.\n * \n * üß† **Key Features:**\n * 1. **Auto-Cleanup**: All event listeners (`on`), watchers (`watch`), and observers (`observe`) \n *    attached via the context are automatically removed when `destroy()` is called.\n * 2. **Scoped Access**: `refs`, `find`, and `findAll` are scoped to the component root.\n * 3. **DOM-as-State**: The `ctx.state` proxy reads/writes directly to `data-*` attributes,\n *    keeping the DOM as the single source of truth.\n * 4. **Composition**: The `setup` function allows you to compose reusable logic functions\n *    easily.\n * \n * @template API - The public interface returned by the component (methods/properties).\n * @template R - The shape of `refs` (elements marked with `data-ref=\"name\"`).\n * @template G - The shape of `groups` (lists of elements marked with `data-ref=\"name\"`).\n * @template S - The shape of `state` (data attributes accessed via `ctx.state`).\n * \n * @param target - The DOM element or CSS selector to mount the component on.\n * @param setup - The initialization function. Receives `ComponentContext` and returns the public API.\n * @returns The initialized component instance, or `null` if the target was not found.\n * \n * @example\n * ```typescript\n * // 1. Define Types (Optional, for strong typing)\n * interface CounterRefs { display: HTMLElement; btn: HTMLButtonElement; }\n * interface CounterState { count: number; }\n * \n * // 2. HTML: <div id=\"app\"><span data-ref=\"display\"></span><button data-ref=\"btn\">Inc</button></div>\n * \n * // 3. Define Component\n * const Counter = defineComponent<any, CounterRefs, any, CounterState>('#app', (ctx) => {\n *   const { display, btn } = ctx.refs;\n * \n *   // Initialize State (updates data-count=\"0\" in DOM)\n *   ctx.state.count = 0;\n * \n *   // Event Listener (auto-cleaned on destroy)\n *   ctx.on('click', btn, () => {\n *     ctx.state.count++;\n *   });\n * \n *   // Reactive Watcher (runs when state changes)\n *   ctx.watch('count', (val) => {\n *     display.textContent = String(val);\n *   });\n * });\n * ```\n * \n * @example\n * ```typescript\n * // Example: Exposing a Public API\n * interface ModalAPI { open: () => void; close: () => void; }\n * \n * const Modal = defineComponent<ModalAPI>('#my-modal', (ctx) => {\n *   const { root } = ctx;\n * \n *   const open = () => {\n *     ctx.state.isOpen = true;\n *     root.setAttribute('open', '');\n *   };\n * \n *   const close = () => {\n *     ctx.state.isOpen = false;\n *     root.removeAttribute('open');\n *   };\n * \n *   // Close on Escape key (delegated to document, but managed by component)\n *   const cleanupKey = on(document)('keydown', (e) => {\n *     if (e.key === 'Escape') close();\n *   });\n *   ctx.effect(cleanupKey); // Register for auto-cleanup\n * \n *   // Return methods to be used externally\n *   return { open, close };\n * });\n * \n * // Usage\n * Modal.open();\n * // Later...\n * Modal.destroy(); // Cleans up DOM listeners and the global Escape listener\n * ```\n */\nexport const defineComponent = <\n  API extends Record<string, any> = {},\n  R extends Record<string, HTMLElement> = any,\n  G extends Record<string, HTMLElement[]> = any,\n  S extends Record<string, any> = any\n>(\n  target: string | HTMLElement | null,\n  setup: (ctx: ComponentContext<R, G, S>) => API | void\n): ComponentInstance<API> | null => {\n  // 1. Resolve Root\n  const root = (typeof target === 'string' ? find(document)(target) : target) as HTMLElement;\n  if (!root) return null;\n\n  // 2. Lifecycle & Cleanup Manager\n  const hooks = createListenerGroup();\n\n  // 3. Construct Context\n  const ctx: ComponentContext<R, G, S> = {\n    root,\n    refs: refs(root) as R,\n    groups: groupRefs(root) as G,\n    state: store<S>(root),\n\n    find: find(root),\n    findAll: findAll(root),\n\n    // Unified Event Manager\n    on: (event: string, targetOrSelector: string | EventTarget, handler: any) => {\n      if (typeof targetOrSelector === 'string') {\n        // Delegated\n        hooks.add(onDelegated(root)(targetOrSelector)(event as any, handler));\n      } else {\n        // Direct\n        hooks.add(on(targetOrSelector as any)(event as any, (e) => handler(e, targetOrSelector)));\n      }\n    },\n\n    // Reactive State Watcher\n    watch: (key, handler) => {\n      hooks.add(Data.bind(root)(key, handler));\n    },\n\n    // Two-Way Data Binding\n    bind: (input, key) => {\n      if (!input) return;\n\n      // 1. Init: Sync DOM -> Input\n      const current = Data.read(root)(key);\n      if (current !== undefined) Input.set(input)(current);\n\n      // 2. Input -> State (Debounced slightly for performance)\n      hooks.add(on(input)('input', () => {\n        const val = Input.get(input);\n        Data.set(root)(key, val);\n      }));\n\n      // 3. State -> Input\n      hooks.add(Data.bind(root)(key, (val) => {\n        const currentInputVal = Input.get(input);\n        // Only update if different to avoid cursor jumping\n        if (currentInputVal != val) Input.set(input)(val);\n      }));\n    },\n\n    // Generic Cleanup\n    effect: (fn) => hooks.add(fn),\n\n    // Advanced Observers\n    observe: (type, targetEl, cb, opts) => {\n      if (!targetEl) return;\n      const Obs = type === 'intersection' ? IntersectionObserver : ResizeObserver;\n      const observer = new Obs(cb as any, opts);\n      observer.observe(targetEl);\n      hooks.add(() => observer.disconnect());\n    }\n  };\n\n  // 4. Initialize Logic\n  const api = setup(ctx) || {} as API;\n\n  // 5. Return Instance\n  return {\n    ...api,\n    root,\n    destroy: () => {\n      hooks.clear();\n      // If the component added specific cleanup logic in setup, it runs here.\n    }\n  };\n};"],
  "mappings": "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",
  "names": ["require", "el", "node", "attr", "prop", "html", "refs", "httpRes", "rect"]
}
