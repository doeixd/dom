{
  "version": 3,
  "sources": ["../../../src/index.ts"],
  "sourcesContent": ["/**\r\n * fdom (Functional DOM) - v2.0.0\r\n * ==========================================\r\n * A production-grade, target-first, type-safe DOM library.\r\n *\r\n * -----------------------------------------------------------------------------\r\n * üß† DESIGN PHILOSOPHY\r\n * -----------------------------------------------------------------------------\r\n * 1. Target-First: `Action(Element)(Config)` pattern for intuitive chaining.\r\n * 2. Curried: Functions return closures for composition/piping.\r\n * 3. Null-Safe: All functions fail gracefully on `null`/`undefined` targets.\r\n * 4. Type-Safe: Full Generics for HTML Elements, Events, and Return types.\r\n *\r\n * -----------------------------------------------------------------------------\r\n * üìö API DIRECTORY (27 MODULES)\r\n * -----------------------------------------------------------------------------\r\n *\r\n * üü¢ DOM CORE\r\n *    1. Querying ......... find, findAll, closest\r\n *    2. Events ........... on, onDelegated, dispatch\r\n *    3. Manipulation ..... modify, css, tempStyle\r\n *    4. Structure ........ append, prepend, after, before, remove, wrap\r\n *    5. Creation ......... el, html, htmlMany, clone\r\n *\r\n * üîµ STATE & ATTRIBUTES\r\n *    6. Classes .......... cls (add/remove/toggle), watchClass\r\n *    7. Attributes ....... Data (get/set/read/bind), watchAttr, watchText\r\n *    12. Objects ......... Obj (clone, isEqual, pick, omit)\r\n *    14. Refs ............ refs, groupRefs (data-ref handling)\r\n *    16. Cycling ......... cycleClass (State machines)\r\n *\r\n * üü° LIFECYCLE & OBSERVATION\r\n *    8. Lifecycle ........ onReady, onMount, waitFor\r\n *    17. Cleanup ......... stripListeners, instantiate, cloneMany\r\n *    20. Timing .......... debounce, throttle\r\n *    25. Groups .......... createListenerGroup (Batch cleanup)\r\n *    26. Signals ......... Signal (AbortController wrappers)\r\n *\r\n * üü£ LAYOUT & NAVIGATION\r\n *    10. Navigation ...... Traverse (parent, children, siblings, next, prev)\r\n *    11. CSS Utils ....... CssVar, computed, injectStyles, waitTransition\r\n *    15. Color ........... toColorSpace (Color mix utils)\r\n *    18. Geometry ........ rect, offset, isVisible\r\n *    19. Scroll/Focus .... scrollInto, focus, blur\r\n *\r\n * üü† DATA & NETWORK\r\n *    9. URL/Form ......... Params, Form (serialize/populate)\r\n *    13. Collections ..... batch, groupBy\r\n *    21. Storage ......... Local, Session (Typed wrappers)\r\n *    22. Cookies ......... Cookie (get/set/remove)\r\n *    23. Network ......... Http (get/post/put/delete)\r\n *    24. PWA ............. SW (Service Worker reg/post)\r\n *    27. Pub/Sub ......... createBus (Typed Event Emitter)\r\n *\r\n * @module fdom\r\n * @author Patrick Glenn\r\n * @license MIT\r\n */\r\n\r\n// =============================================================================\r\n// 0. TYPES & HELPERS\r\n// =============================================================================\r\n\r\n/**\r\n * Infers a DOM element type from a CSS selector string.\r\n * \r\n * Supports:\r\n * - Tag names: `'div'` ‚Üí `HTMLDivElement`\r\n * - SVG tags: `'svg'` ‚Üí `SVGSVGElement`\r\n * - ID selectors: `'#app'` ‚Üí `HTMLElement`\r\n * - Class selectors: `'.card'` ‚Üí `HTMLElement`\r\n * - Complex selectors: `'div.card'` ‚Üí `HTMLElement`\r\n * \r\n * @template S - The selector string literal type\r\n * \r\n * @example\r\n * ```typescript\r\n * type ButtonEl = ParseSelector<'button'>; // HTMLButtonElement\r\n * type AnchorEl = ParseSelector<'a'>; // HTMLAnchorElement\r\n * type SvgEl = ParseSelector<'svg'>; // SVGSVGElement\r\n * ```\r\n */\r\nexport type ParseSelector<S extends string> =\r\n  S extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[S]\r\n  : S extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[S]\r\n  : S extends `#${string}` ? HTMLElement\r\n  : S extends `.${string}` ? HTMLElement\r\n  : HTMLElement;\r\n\r\n/**\r\n * A cleanup/unsubscribe function returned by event listeners and subscriptions.\r\n * \r\n * Call this function to remove the listener and free resources.\r\n * \r\n * @example\r\n * ```typescript\r\n * const cleanup = on(button)('click', handler);\r\n * // Later...\r\n * cleanup(); // Removes the event listener\r\n * ```\r\n */\r\nexport type Unsubscribe = () => void;\r\n\r\n/**\r\n * Event map for HTML elements, extensible for custom events.\r\n * \r\n * @template T - Additional custom event mappings\r\n * \r\n * @example\r\n * ```typescript\r\n * type MyEvents = EventMap<{\r\n *   'custom:save': CustomEvent<{ id: number }>;\r\n *   'custom:delete': CustomEvent<{ id: number }>;\r\n * }>;\r\n * ```\r\n */\r\nexport type EventMap<T extends Record<string, Event> = {}> = HTMLElementEventMap & T;\r\n\r\n/**\r\n * Extracts the detail type from a CustomEvent.\r\n * \r\n * @template T - The CustomEvent type\r\n * \r\n * @example\r\n * ```typescript\r\n * type SaveEvent = CustomEvent<{ id: number }>;\r\n * type Detail = ExtractEventDetail<SaveEvent>; // { id: number }\r\n * ```\r\n */\r\nexport type ExtractEventDetail<T> = T extends CustomEvent<infer D> ? D : never;\r\n\r\n/**\r\n * Properties for creating/modifying elements.\r\n * \r\n * Supports declarative configuration of:\r\n * - Text content\r\n * - HTML content\r\n * - Inline styles\r\n * - Data attributes\r\n * - CSS classes\r\n * - HTML attributes\r\n * - Form element properties\r\n * \r\n * @example\r\n * ```typescript\r\n * const props: ElementProps = {\r\n *   text: 'Click me',\r\n *   class: { active: true, disabled: false },\r\n *   dataset: { userId: 123, role: 'admin' },\r\n *   style: { color: 'red', fontSize: '16px' },\r\n *   attr: { 'aria-label': 'Submit button' }\r\n * };\r\n * ```\r\n */\r\nexport interface ElementProps {\r\n  /** Sets innerText (safer than html) */\r\n  text?: string;\r\n  /** Sets innerHTML (use with caution - XSS risk) */\r\n  html?: string;\r\n  /** Inline CSS styles */\r\n  style?: Partial<CSSStyleDeclaration>;\r\n  /** Data attributes (data-*) - auto-converts to kebab-case */\r\n  dataset?: Record<string, string | number | boolean | null | undefined>;\r\n  /** CSS classes with boolean toggles */\r\n  class?: Record<string, boolean>;\r\n  /** HTML attributes */\r\n  attr?: Record<string, string | number | boolean | null | undefined>;\r\n  /** Value for form inputs */\r\n  value?: string | number;\r\n  /** Disabled state for form inputs */\r\n  disabled?: boolean;\r\n}\r\n\r\n/**\r\n * Strict element properties with element-specific validation.\r\n * \r\n * Provides better type safety by constraining properties based on element type.\r\n * \r\n * @template T - The HTML element type\r\n * \r\n * @example\r\n * ```typescript\r\n * const inputProps: StrictElementProps<HTMLInputElement> = {\r\n *   value: 'test',\r\n *   disabled: true,\r\n *   attr: { type: 'text', placeholder: 'Enter name' }\r\n * };\r\n * ```\r\n */\r\nexport type StrictElementProps<T extends HTMLElement> = ElementProps & {\r\n  value?: T extends HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement ? string | number : never;\r\n  disabled?: T extends HTMLInputElement | HTMLButtonElement | HTMLSelectElement | HTMLTextAreaElement ? boolean : never;\r\n};\r\n\r\n/**\r\n * Makes all properties in T deeply readonly.\r\n * \r\n * @template T - The type to make readonly\r\n */\r\nexport type DeepReadonly<T> = {\r\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\r\n};\r\n\r\n/**\r\n * Makes all properties in T deeply partial.\r\n * \r\n * @template T - The type to make partial\r\n */\r\nexport type DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n\r\n/**\r\n * Internal: Normalizes content into an array of Nodes.\r\n * \r\n * Handles:\r\n * - Flattening nested arrays\r\n * - Filtering out null/undefined/false\r\n * - Converting strings to text nodes\r\n * - Preserving existing Node instances\r\n * \r\n * @internal\r\n */\r\nconst _nodes = (args: any[]): Node[] =>\r\n  args.flat()\r\n    .filter(x => x != null && x !== false)\r\n    .map(x => x instanceof Node ? x : document.createTextNode(String(x)));\r\n\r\n/**\r\n * Hybrid Function Builder.\r\n * Creates a function that supports both Curried and Imperative usage.\r\n * \r\n * @template T - The Target type (Element, string, etc)\r\n * @template A - The Arguments tuple type\r\n * @template R - The Return type\r\n * \r\n * @example\r\n * const add = def((el: HTMLElement, cls: string) => el.classList.add(cls));\r\n * \r\n * // Usage 1: Imperative (Cleaner DX)\r\n * add(div, 'active');\r\n * \r\n * // Usage 2: Curried (Pipeline friendly)\r\n * pipe(\r\n *   find('.btn'),\r\n *   el => add(el)('active')\r\n * );\r\n */\r\nexport const def = <T, A extends any[], R>(\r\n  // The implementation function takes target + args all at once\r\n  fn: (target: T | null, ...args: A) => R\r\n) => {\r\n  // Overload 1: Called with arguments -> Execute immediately\r\n  function wrapper(target: T | null, ...args: A): R;\r\n\r\n  // Overload 2: Called with just target -> Return curried function\r\n  function wrapper(target: T | null): (...args: A) => R;\r\n\r\n  // Implementation\r\n  function wrapper(target: T | null, ...args: any[]) {\r\n    // If we have extra args, run immediately\r\n    if (args.length > 0) {\r\n      // @ts-ignore - spread is safe here due to generics\r\n      return fn(target, ...args);\r\n    }\r\n    // Otherwise return the closure\r\n    return (...lateArgs: A) => fn(target, ...lateArgs);\r\n  }\r\n\r\n  return wrapper;\r\n};\r\n\r\n// =============================================================================\r\n// 1. QUERYING\r\n// =============================================================================\r\n\r\n/**\r\n * Finds the first element matching the selector within a root.\r\n * \r\n * Returns `null` if no element is found. The return type is automatically\r\n * inferred from the selector when using tag names.\r\n * \r\n * @template S - The CSS selector string (literal type for best inference)\r\n * @param root - The root element to search within (defaults to document)\r\n * @returns A curried function that accepts a selector and returns the matched element or null\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage with type inference\r\n * const btn = find(document)('button'); // HTMLButtonElement | null\r\n * const link = find(document)('a'); // HTMLAnchorElement | null\r\n * \r\n * // Search within a specific container\r\n * const container = document.querySelector('.container');\r\n * const findInContainer = find(container);\r\n * const heading = findInContainer('h1');\r\n * \r\n * // ID and class selectors\r\n * const app = find(document)('#app'); // HTMLElement | null\r\n * const card = find(document)('.card'); // HTMLElement | null\r\n * \r\n * // Null-safe: returns null if root is null\r\n * const maybeRoot = document.querySelector('.missing');\r\n * const result = find(maybeRoot)('div'); // null\r\n * ```\r\n */\r\nexport const find = (root: ParentNode = document) => {\r\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\r\n    return root.querySelector(selector) as ParseSelector<S> | null;\r\n  };\r\n};\r\n\r\n/**\r\n * Finds all elements matching the selector within a root.\r\n * \r\n * Returns an array of matched elements (empty array if none found).\r\n * The element type is automatically inferred from tag name selectors.\r\n * \r\n * @template S - The CSS selector string (literal type for best inference)\r\n * @param root - The root element to search within (defaults to document)\r\n * @returns A curried function that accepts a selector and returns an array of matched elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage with type inference\r\n * const buttons = findAll(document)('button'); // HTMLButtonElement[]\r\n * const links = findAll(document)('a'); // HTMLAnchorElement[]\r\n * \r\n * // Search within a container\r\n * const list = document.querySelector('ul');\r\n * const items = findAll(list)('li'); // HTMLLIElement[]\r\n * \r\n * // Class and attribute selectors\r\n * const cards = findAll(document)('.card'); // HTMLElement[]\r\n * const required = findAll(document)('[required]'); // HTMLElement[]\r\n * \r\n * // Iterate over results\r\n * findAll(document)('input').forEach(input => {\r\n *   console.log(input.value); // Type-safe access to input.value\r\n * });\r\n * \r\n * // Empty array if no matches\r\n * const missing = findAll(document)('.does-not-exist'); // []\r\n * ```\r\n */\r\nexport const findAll = (root: ParentNode = document) => {\r\n  return <S extends string>(selector: S): ParseSelector<S>[] => {\r\n    return Array.from(root.querySelectorAll(selector)) as ParseSelector<S>[];\r\n  };\r\n};\r\n\r\n/**\r\n * Finds the closest ancestor (including self) matching the selector.\r\n * \r\n * Traverses up the DOM tree from the element to find the first ancestor\r\n * that matches the selector. Returns `null` if no match is found or if\r\n * the element is `null`.\r\n * \r\n * @template S - The CSS selector string (literal type for best inference)\r\n * @param element - The starting element (can be null for safe chaining)\r\n * @returns A curried function that accepts a selector and returns the matched ancestor or null\r\n * \r\n * @example\r\n * ```typescript\r\n * // Find parent container\r\n * const button = document.querySelector('button');\r\n * const card = closest(button)('.card'); // HTMLElement | null\r\n * const form = closest(button)('form'); // HTMLFormElement | null\r\n * \r\n * // Useful for event delegation\r\n * on(document)('click', (e) => {\r\n *   const target = e.target as Element;\r\n *   const listItem = closest(target)('li');\r\n *   if (listItem) {\r\n *     console.log('Clicked list item:', listItem);\r\n *   }\r\n * });\r\n * \r\n * // Null-safe: returns null if element is null\r\n * const maybeEl = document.querySelector('.missing');\r\n * const result = closest(maybeEl)('.parent'); // null\r\n * \r\n * // Can match the element itself\r\n * const div = document.querySelector('div.active');\r\n * const match = closest(div)('div'); // Returns div itself\r\n * ```\r\n */\r\nexport const closest = (element: Element | null) => {\r\n  return <S extends string>(selector: S): ParseSelector<S> | null => {\r\n    return element?.closest(selector) as ParseSelector<S> | null;\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 2. EVENTS\r\n// =============================================================================\r\n\r\n/**\n * Attaches an event listener to the target element.\n *\n * Returns a cleanup function to remove the listener. Supports all standard\n * DOM events with full type inference. The handler receives both the event\n * and the target element for convenience.\n *\n * @template T - The event target type (EventTarget or more specific)\n * @template K - The event type key from HTMLElementEventMap\n * @param target - The element to attach the listener to (null-safe)\n * @returns A curried function that accepts event type, handler, and options\n *\n * @example\n * ```typescript\n * // Basic click handler\n * const button = document.querySelector('button');\n * const cleanup = on(button)('click', (e, target) => {\n *   console.log('Clicked!', target); // target is typed as the button\n *   e.preventDefault();\n * });\n *\n * // Later: remove the listener\n * cleanup();\n *\n * // Input events with type inference\n * const input = document.querySelector('input');\n * on(input)('input', (e) => {\n *   console.log(e.target.value); // e is InputEvent\n * });\n *\n * // Keyboard events\n * on(document)('keydown', (e) => {\n *   if (e.key === 'Escape') {\n *     console.log('Escape pressed');\n *   }\n * });\n *\n * // With options (capture, once, passive)\n * on(window)('scroll', handler, { passive: true });\n * on(button)('click', handler, { once: true });\n *\n * // Null-safe: returns no-op cleanup if target is null\n * const missing = document.querySelector('.missing');\n * const noop = on(missing)('click', handler); // Safe, returns () => {}\n * ```\n */\nexport const on = <T extends EventTarget = EventTarget>(target: T | null) => {\n  return <K extends keyof HTMLElementEventMap>(\n    eventType: K,\n    handler: (event: HTMLElementEventMap[K], target: T) => void,\n    options: boolean | AddEventListenerOptions = false\n  ): Unsubscribe => {\n    if (!target) return () => { };\n\n    const listener = (e: Event) => handler(e as HTMLElementEventMap[K], target);\n    target.addEventListener(eventType, listener, options);\n    return () => target.removeEventListener(eventType, listener, options);\n  };\n};\n\r\n/**\r\n * Attaches a **Delegated Event Listener** using event bubbling.\r\n * \r\n * üß† **Architecture**: `Root -> Selector -> Event`\r\n * This ordering allows you to group interactions by the target element type.\r\n * \r\n * üõ°Ô∏è **Type Safety**:\r\n * - The `match` argument is inferred from the CSS selector (e.g. `'button'` -> `HTMLButtonElement`).\r\n * - The `event` argument is inferred from the event name (e.g. `'click'` -> `MouseEvent`).\r\n * \r\n * @param root - The container element (e.g. `<ul>`, `form`, `document`).\r\n * \r\n * @example\r\n * ```typescript\r\n * // 1. Define the scope (e.g. a User Table)\r\n * const table = find(document)('#user-table');\r\n * const onTable = onDelegated(table);\r\n * \r\n * // 2. Define interactions for specific child elements\r\n * // Type inference knows 'tr' is HTMLTableRowElement\r\n * const onRow = onTable('tr');\r\n * \r\n * onRow('click', (e, row) => {\r\n *   console.log('Row clicked', row.dataset.id);\r\n *   cls.toggle(row)('selected');\r\n * });\r\n * \r\n * // 3. Define interactions for buttons\r\n * // Type inference knows 'button.delete' is HTMLButtonElement\r\n * onTable('button.delete')('click', (e, btn) => {\r\n *   e.stopPropagation();\r\n *   const id = btn.dataset.id;\r\n *   api.delete(id);\r\n * });\r\n * ```\r\n */\r\nexport const onDelegated = (root: ParentNode | null = document) => {\r\n  /**\r\n   * @param selector - CSS Selector to match target elements against (e.g. 'li', '.btn')\r\n   */\r\n  return <S extends string>(selector: S) => {\r\n    /**\r\n     * @param eventType - Standard DOM event name (click, input, change, etc)\r\n     * @param handler - Callback receiving the typed Event and the typed Matched Element\r\n     * @param options - EventListener options (capture, passive, etc)\r\n     */\r\n    return <K extends keyof HTMLElementEventMap>(\r\n      eventType: K,\r\n      handler: (event: HTMLElementEventMap[K], match: ParseSelector<S>) => void,\r\n      options: boolean | AddEventListenerOptions = false\r\n    ): Unsubscribe => {\r\n      if (!root) return () => { };\r\n\r\n      const listener = (e: Event) => {\r\n        const target = e.target as Element;\r\n\r\n        // 1. Find the closest ancestor (or self) that matches the selector\r\n        const match = target.closest ? target.closest(selector) : null;\r\n\r\n        // 2. Ensure the match exists AND is actually inside our root container\r\n        // (Prevents edge cases with disconnected nodes or Shadow DOM)\r\n        if (match && root.contains(match)) {\r\n          // @ts-ignore - TS inference here is complex but safe due to ParseSelector\r\n          handler(e as HTMLElementEventMap[K], match as ParseSelector<S>);\r\n        }\r\n      };\r\n\r\n      root.addEventListener(eventType, listener, options);\r\n      return () => root.removeEventListener(eventType, listener, options);\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Dispatches a CustomEvent from the target element.\r\n * \r\n * Creates and dispatches a CustomEvent with optional detail data. The detail\r\n * type is inferred from the provided data. By default, events bubble up the\r\n * DOM tree.\r\n * \r\n * @template T - The type of the detail data\r\n * @param target - The element to dispatch the event from (null-safe)\r\n * @returns A curried function that accepts event name, detail, and options\r\n * \r\n * @example\r\n * ```typescript\r\n * // Simple custom event\r\n * const button = document.querySelector('button');\r\n * dispatch(button)('clicked', { timestamp: Date.now() });\r\n * \r\n * // Typed custom events\r\n * interface SaveEvent {\r\n *   id: number;\r\n *   data: { name: string; email: string };\r\n * }\r\n * dispatch(form)('save', { id: 123, data: formData } as SaveEvent);\r\n * \r\n * // Listen for custom events\r\n * on(button)('clicked' as any, (e: CustomEvent) => {\r\n *   console.log('Detail:', e.detail); // { timestamp: ... }\r\n * });\r\n * \r\n * // Non-bubbling event\r\n * dispatch(element)('custom', data, { bubbles: false });\r\n * \r\n * // Cancelable event\r\n * dispatch(element)('beforeSave', data, { cancelable: true });\r\n * \r\n * // Component communication pattern\r\n * const modal = document.querySelector('.modal');\r\n * dispatch(modal)('modal:close', { reason: 'user-action' });\r\n * \r\n * // Null-safe: does nothing if target is null\r\n * const missing = document.querySelector('.missing');\r\n * dispatch(missing)('event', data); // Safe, no error\r\n * ```\r\n */\r\nexport const dispatch = (target: EventTarget | null) => {\r\n  return <T = any>(eventName: string, detail?: T, options: EventInit = { bubbles: true }) => {\r\n    if (target) {\r\n      target.dispatchEvent(new CustomEvent(eventName, { detail, ...options }));\r\n    }\r\n    return target;\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 3. MANIPULATION (MODIFY & STYLE)\r\n// =============================================================================\r\n\r\n/**\n * Declaratively modifies an element's properties.\n *\n * Provides a unified API for setting text, HTML, styles, classes, attributes,\n * and dataset values. All modifications are applied in a single call. Returns\n * the element for chaining.\n *\n * @template T - The HTML element type\n * @param element - The element to modify (null-safe)\n * @returns A curried function that accepts props and returns the modified element\n *\n * @example\n * ```typescript\n * const button = document.querySelector('button');\n *\n * // Imperative (cleaner DX)\n * modify(button, { text: 'Click me!' });\n *\n * // Curried (pipeline friendly)\n * modify(button)({ text: 'Click me!' });\n *\n * // Multiple properties at once\n * modify(button)({\n *   text: 'Submit',\n *   class: { active: true, disabled: false },\n *   dataset: { userId: '123', action: 'save' },\n *   style: { backgroundColor: 'blue', color: 'white' },\n *   attr: { 'aria-label': 'Submit form', type: 'submit' }\n * });\n *\n * // Form inputs\n * const input = document.querySelector('input');\n * modify(input)({\n *   value: 'John Doe',\n *   disabled: false,\n *   attr: { placeholder: 'Enter name', required: true }\n * });\n *\n * // Conditional classes\n * modify(element)({\n *   class: {\n *     loading: isLoading,\n *     error: hasError,\n *     success: isSuccess\n *   }\n * });\n *\n * // Data attributes (auto-converts to kebab-case)\n * modify(element)({\n *   dataset: {\n *     userId: 123,        // becomes data-user-id=\"123\"\n *     isActive: true,     // becomes data-is-active=\"true\"\n *     config: { a: 1 }    // becomes data-config='{\"a\":1}'\n *   }\n * });\n *\n * // Null-safe: returns null if element is null\n * modify(null)({ text: 'test' }); // null\n * ```\n */\nexport const modify = def(<T extends HTMLElement>(element: T | null, props: ElementProps): T | null => {\n  if (!element) return null;\n\n  if (props.text !== undefined) element.innerText = props.text;\n  if (props.html !== undefined) element.innerHTML = props.html;\n  if (props.value !== undefined) (element as any).value = props.value;\n  if (props.disabled !== undefined) (element as any).disabled = props.disabled;\n\n  if (props.style) Object.assign(element.style, props.style);\n\n  if (props.dataset) {\n    Object.entries(props.dataset).forEach(([k, v]) => {\n      if (v === undefined) return;\n      element.dataset[k] = v === null ? undefined : String(v);\n    });\n  }\n\n  if (props.class) {\n    Object.entries(props.class).forEach(([k, v]) => element.classList.toggle(k, !!v));\n  }\n\n  if (props.attr) {\n    Object.entries(props.attr).forEach(([k, v]) => {\n      if (v === false || v === null || v === undefined) element.removeAttribute(k);\n      else element.setAttribute(k, String(v));\n    });\n  }\n\n  return element;\n});\n\r\n/** \r\n * Sets properties on an element.\r\n *  @alias modify \r\n */\r\nexport const set = modify\r\n\r\n/**\n * Applies inline CSS styles to an element.\n *\n * Merges the provided styles with existing inline styles. For removing styles,\n * set the property to empty string. Returns the element for chaining.\n *\n * @param element - The element to style (null-safe)\n * @returns A curried function that accepts styles and returns the element\n *\n * @example\n * ```typescript\n * const div = document.querySelector('div');\n *\n * // Imperative (cleaner DX)\n * css(div, { color: 'red', fontSize: '16px' });\n *\n * // Curried (pipeline friendly)\n * css(div)({\n *   color: 'red',\n *   fontSize: '16px',\n *   marginTop: '10px'\n * });\n *\n * // CSS custom properties (variables)\n * css(div)({\n *   '--primary-color': '#007bff',\n *   '--spacing': '1rem'\n * } as any);\n *\n * // Remove a style (set to empty string)\n * css(div)({ display: '' });\n *\n * // Animation and transitions\n * css(div)({\n *   transition: 'all 0.3s ease',\n *   transform: 'translateX(100px)',\n *   opacity: '0.5'\n * });\n *\n * // Chaining with modify\n * const element = modify(div)({ text: 'Hello' });\n * css(element)({ color: 'blue' });\n * ```\n */\nexport const css = def((element: HTMLElement | null, styles: Partial<CSSStyleDeclaration>) => {\n  if (element) Object.assign(element.style, styles);\n  return element;\n});\n\r\n/**\r\n * Applies styles temporarily and returns a revert function.\r\n * \r\n * Saves the original style values and applies new ones. The returned function\r\n * restores the original values. Useful for temporary visual states like hover\r\n * effects or loading states.\r\n * \r\n * @param element - The element to style (null-safe)\r\n * @returns A curried function that accepts styles and returns a cleanup function\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Temporarily change opacity\r\n * const revert = tempStyle(div)({ opacity: '0.5' });\r\n * // Later...\r\n * revert(); // Restores original opacity\r\n * \r\n * // Loading state pattern\r\n * const showLoading = () => {\r\n *   const revert = tempStyle(button)({\r\n *     opacity: '0.6',\r\n *     pointerEvents: 'none',\r\n *     cursor: 'wait'\r\n *   });\r\n *   \r\n *   fetchData().finally(() => {\r\n *     revert(); // Restore original styles\r\n *   });\r\n * };\r\n * \r\n * // Animation workflow\r\n * const element = document.querySelector('.box');\r\n * const cleanup = tempStyle(element)({\r\n *   transform: 'scale(1.2)',\r\n *   transition: 'transform 0.3s'\r\n * });\r\n * setTimeout(cleanup, 300); // Revert after animation\r\n * \r\n * // Null-safe: returns no-op if element is null\r\n * const noop = tempStyle(null)({ color: 'red' }); // () => {}\r\n * ```\r\n */\r\nexport const tempStyle = (element: HTMLElement | null) => {\r\n  return (styles: Partial<CSSStyleDeclaration>): Unsubscribe => {\r\n    if (!element) return () => { };\r\n    const original: Record<string, string> = {};\r\n\r\n    // Save original values\r\n    Object.keys(styles).forEach((key) => {\r\n      original[key] = element.style[key as keyof CSSStyleDeclaration] as string;\r\n    });\r\n\r\n    Object.assign(element.style, styles);\r\n\r\n    return () => Object.assign(element.style, original);\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 4. STRUCTURE & TRAVERSAL\r\n// =============================================================================\r\n\r\n/**\n * Appends content to the end of the target element.\n *\n * Accepts multiple arguments of mixed types (strings, Nodes, null, undefined).\n * Strings are automatically converted to text nodes. Null/undefined values are\n * filtered out. Returns the parent for chaining.\n *\n * @param parent - The parent element to append to (null-safe)\n * @returns A curried function that accepts content and returns the parent\n *\n * @example\n * ```typescript\n * const list = document.querySelector('ul');\n *\n * // Imperative (cleaner DX)\n * append(list, item1, item2, item3);\n *\n * // Curried (pipeline friendly)\n * append(list)(item1, item2, item3);\n *\n * // Append a single element\n * const item = document.createElement('li');\n * append(list)(item);\n *\n * // Mix elements and text\n * append(container)(heading, 'Some text', paragraph);\n *\n * // Append text nodes\n * append(div)('Hello', ' ', 'World');\n *\n * // Null values are safely ignored\n * append(list)(item1, null, item2, undefined); // Only appends item1 and item2\n *\n * // Chaining\n * const parent = append(container)(child1);\n * append(parent)(child2);\n * ```\n */\nexport const append = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\n  parent?.append(..._nodes(content));\n  return parent;\n});\n\r\n/**\n * Prepends content to the start of the target element.\n *\n * Inserts content at the beginning, before any existing children. Accepts\n * multiple arguments of mixed types. Returns the parent for chaining.\n *\n * @param parent - The parent element to prepend to (null-safe)\n * @returns A curried function that accepts content and returns the parent\n *\n * @example\n * ```typescript\n * const list = document.querySelector('ul');\n *\n * // Imperative (cleaner DX)\n * prepend(list, firstItem);\n *\n * // Curried (pipeline friendly)\n * prepend(list)(firstItem);\n *\n * // Add header before content\n * const container = document.querySelector('.container');\n * const header = document.createElement('h1');\n * prepend(container)(header);\n * ```\n */\nexport const prepend = def((parent: HTMLElement | null, ...content: (string | Node | null | undefined)[]) => {\n  parent?.prepend(..._nodes(content));\n  return parent;\n});\n\r\n/**\n * Inserts content AFTER the target element as siblings.\n *\n * The content is inserted after the target in the DOM tree, at the same level.\n * Useful for inserting elements without modifying the target's children.\n *\n * @param target - The reference element (null-safe)\n * @returns A curried function that accepts content and returns the target\n *\n * @example\n * ```typescript\n * const header = document.querySelector('h1');\n * const banner = document.createElement('div');\n *\n * // Imperative (cleaner DX)\n * after(header, banner, notice, alert);\n *\n * // Curried (pipeline friendly)\n * after(header)(banner);\n *\n * // Insert multiple elements\n * after(header)(banner, notice, alert);\n * ```\n */\nexport const after = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\n  target?.after(..._nodes(content));\n  return target;\n});\n\r\n/**\n * Inserts content BEFORE the target element as siblings.\n *\n * The content is inserted before the target in the DOM tree, at the same level.\n *\n * @param target - The reference element (null-safe)\n * @returns A curried function that accepts content and returns the target\n *\n * @example\n * ```typescript\n * const footer = document.querySelector('footer');\n * const disclaimer = document.createElement('p');\n *\n * // Imperative (cleaner DX)\n * before(footer, disclaimer);\n *\n * // Curried (pipeline friendly)\n * before(footer)(disclaimer);\n * ```\n */\nexport const before = def((target: Element | null, ...content: (string | Node | null | undefined)[]) => {\n  target?.before(..._nodes(content));\n  return target;\n});\n\r\n/**\r\n * Removes the target element from the DOM.\r\n * \r\n * Detaches the element from its parent. Event listeners attached via\r\n * addEventListener will be garbage collected. Always returns `null` for\r\n * type safety (prevents accidental reuse of removed elements).\r\n * \r\n * @param target - The element to remove (null-safe)\r\n * @returns Always returns `null`\r\n * \r\n * @example\r\n * ```typescript\r\n * const modal = document.querySelector('.modal');\r\n * remove(modal); // Modal is removed from DOM\r\n * \r\n * // Conditional removal\r\n * if (shouldRemove) {\r\n *   remove(element);\r\n * }\r\n * ```\r\n */\r\nexport const remove = (target: Element | null) => {\r\n  target?.remove();\r\n  return null;\r\n};\r\n\r\n/**\r\n * Removes all children from the target element.\r\n * \r\n * More efficient than `innerHTML = ''` and safer (doesn't parse HTML).\r\n * Returns the target for chaining.\r\n * \r\n * @param target - The element to empty (null-safe)\r\n * @returns The target element\r\n * \r\n * @example\r\n * ```typescript\r\n * const container = document.querySelector('.container');\r\n * \r\n * // Clear all content\r\n * empty(container);\r\n * \r\n * // Then add new content\r\n * append(empty(container))(newContent);\r\n * ```\r\n */\r\nexport const empty = (target: Element | null) => {\r\n  if (target) target.replaceChildren();\r\n  return target;\r\n};\r\n\r\n/**\n * Wraps the target element with a wrapper element.\n *\n * Inserts the wrapper before the target in the DOM, then moves the target\n * inside the wrapper. Useful for adding container elements around existing\n * content.\n *\n * @param target - The element to wrap (null-safe)\n * @returns A curried function that accepts a wrapper and returns it\n *\n * @example\n * ```typescript\n * const img = document.querySelector('img');\n * const figure = document.createElement('figure');\n *\n * // Imperative (cleaner DX)\n * wrap(img, figure);\n *\n * // Curried (pipeline friendly)\n * wrap(img)(figure);\n * // DOM: <figure><img /></figure>\n *\n * // Using el() helper\n * wrap(img)(el('figure')({})([]));\n *\n * // Add caption to wrapper\n * const wrapper = wrap(img)(figure);\n * append(wrapper)(el('figcaption')({})(['Image caption']));\n * ```\n */\nexport const wrap = def((target: HTMLElement | null, wrapper: HTMLElement) => {\n  if (target && wrapper && target.parentNode) {\n    target.parentNode.insertBefore(wrapper, target);\n    wrapper.appendChild(target);\n  }\n  return wrapper;\n});\n\r\n// =============================================================================\r\n// 5. CREATION & TEMPLATES\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a DOM element with full type inference.\r\n * \r\n * Returns a curried function for building elements in three stages:\r\n * 1. Tag name (with type inference)\r\n * 2. Properties (text, classes, attributes, etc.)\r\n * 3. Children (elements or text)\r\n * \r\n * The return type is automatically inferred from the tag name.\r\n * \r\n * @template K - The HTML tag name (keyof HTMLElementTagNameMap)\r\n * @param tag - The HTML tag name (e.g., 'div', 'button', 'a')\r\n * @returns A curried function for props, then children, then the element\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic button\r\n * const btn = el('button')({})(['Click me']);\r\n * // btn is typed as HTMLButtonElement\r\n * \r\n * // With properties\r\n * const link = el('a')({\r\n *   attr: { href: '/home' },\r\n *   class: { active: true },\r\n *   text: 'Home'\r\n * })([]);\r\n * // link is typed as HTMLAnchorElement\r\n * \r\n * // Nested elements\r\n * const card = el('div')({\r\n *   class: { card: true }\r\n * })([\r\n *   el('h2')({})(['Title']),\r\n *   el('p')({})(['Description'])\r\n * ]);\r\n * \r\n * // Form input with type inference\r\n * const input = el('input')({\r\n *   attr: { type: 'text', placeholder: 'Enter name' },\r\n *   value: 'John'\r\n * })([]);\r\n * // input is typed as HTMLInputElement\r\n * \r\n * // Partial application for reuse\r\n * const createButton = el('button');\r\n * const primaryBtn = createButton({ class: { primary: true } })(['Save']);\r\n * const secondaryBtn = createButton({ class: { secondary: true } })(['Cancel']);\r\n * ```\r\n */\r\nexport const el = <K extends keyof HTMLElementTagNameMap>(tag: K) => {\r\n  return (props: ElementProps = {}) => {\r\n    return (children: (string | Node)[] = []): HTMLElementTagNameMap[K] => {\r\n      const node = document.createElement(tag);\r\n      modify(node)(props);\r\n      node.append(..._nodes(children));\r\n      return node;\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Creates an element from an HTML template string.\r\n * \r\n * Uses tagged template literals for convenient HTML creation. Interpolated\r\n * values are automatically escaped. Returns the first element in the template.\r\n * \r\n * ‚ö†Ô∏è **XSS Warning**: Only use with trusted content. Do not interpolate\r\n * user input directly without sanitization.\r\n * \r\n * @param strings - Template string parts\r\n * @param values - Interpolated values\r\n * @returns The created HTMLElement\r\n * @throws Error if template doesn't produce an element\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const div = html`<div class=\"container\">Hello</div>`;\r\n * \r\n * // With interpolation\r\n * const name = 'World';\r\n * const greeting = html`<h1>Hello ${name}!</h1>`;\r\n * \r\n * // Complex structure\r\n * const card = html`\r\n *   <div class=\"card\">\r\n *     <h2>${title}</h2>\r\n *     <p>${description}</p>\r\n *   </div>\r\n * `;\r\n * \r\n * // ‚ö†Ô∏è UNSAFE - Don't do this with user input!\r\n * // const unsafe = html`<div>${userInput}</div>`;\r\n * \r\n * // ‚úÖ SAFE - Sanitize user input first\r\n * const safe = html`<div>${sanitize(userInput)}</div>`;\r\n * ```\r\n */\r\nexport const html = (strings: TemplateStringsArray, ...values: any[]): HTMLElement => {\r\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = str.trim();\r\n  const el = tpl.content.firstElementChild;\r\n  if (!el) throw new Error('html: Template did not result in an element');\r\n  return el as HTMLElement;\r\n};\r\n\r\n/**\r\n * Creates a DocumentFragment from an HTML template string.\r\n * \r\n * Like `html()` but returns a DocumentFragment containing all elements\r\n * from the template. Useful for creating multiple sibling elements at once.\r\n * \r\n * ‚ö†Ô∏è **XSS Warning**: Only use with trusted content.\r\n * \r\n * @param strings - Template string parts\r\n * @param values - Interpolated values\r\n * @returns A DocumentFragment containing the created elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // Create multiple list items\r\n * const items = htmlMany`\r\n *   <li>Item 1</li>\r\n *   <li>Item 2</li>\r\n *   <li>Item 3</li>\r\n * `;\r\n * \r\n * const list = document.querySelector('ul');\r\n * list.appendChild(items);\r\n * \r\n * // With interpolation\r\n * const rows = htmlMany`\r\n *   <tr><td>${col1}</td><td>${col2}</td></tr>\r\n *   <tr><td>${col3}</td><td>${col4}</td></tr>\r\n * `;\r\n * ```\r\n */\r\nexport const htmlMany = (strings: TemplateStringsArray, ...values: any[]): DocumentFragment => {\r\n  const str = strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = str.trim();\r\n  return tpl.content;\r\n};\r\n\r\n/**\r\n * Clones a node, preserving its exact type.\r\n * \r\n * Creates a copy of the node and optionally its descendants. The cloned node\r\n * has no parent and is not part of the document. Event listeners are NOT\r\n * copied.\r\n * \r\n * @template T - The node type (preserved in return type)\r\n * @param node - The node to clone (null-safe)\r\n * @returns A curried function that accepts deep flag and returns the clone\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Deep clone (includes children)\r\n * const btnCopy = clone(button)(true);\r\n * // btnCopy is typed as HTMLButtonElement\r\n * \r\n * // Shallow clone (no children)\r\n * const btnShallow = clone(button)(false);\r\n * \r\n * // Template pattern\r\n * const template = el('div')({ class: { card: true } })([\r\n *   el('h2')({})(['Title']),\r\n *   el('p')({})(['Description'])\r\n * ]);\r\n * \r\n * // Create multiple cards from template\r\n * const card1 = clone(template)(true);\r\n * const card2 = clone(template)(true);\r\n * const card3 = clone(template)(true);\r\n * \r\n * // Null-safe\r\n * const missing = document.querySelector('.missing');\r\n * const result = clone(missing)(true); // null\r\n * ```\r\n */\r\nexport const clone = <T extends Node>(node: T | null) => {\r\n  return (deep: boolean = true): T | null => {\r\n    return node ? (node.cloneNode(deep) as T) : null;\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 6. CLASS MANIPULATION\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for manipulating CSS classes on elements.\r\n * \r\n * All methods are null-safe and return the element for chaining (except `has`).\r\n * Provides a functional API for common classList operations.\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Add multiple classes\r\n * cls.add(button)('btn', 'btn-primary', 'active');\r\n * \r\n * // Remove classes\r\n * cls.remove(button)('disabled', 'loading');\r\n * \r\n * // Toggle with optional force\r\n * cls.toggle(button)('active'); // Toggles\r\n * cls.toggle(button)('active', true); // Forces add\r\n * cls.toggle(button)('active', false); // Forces remove\r\n * \r\n * // Replace a class\r\n * cls.replace(button)('btn-primary', 'btn-secondary');\r\n * \r\n * // Check for class\r\n * if (cls.has(button)('active')) {\r\n *   console.log('Button is active');\r\n * }\r\n * \r\n * // Chaining\r\n * cls.add(button)('btn');\r\n * cls.toggle(button)('active');\r\n * ```\r\n */\r\nexport const cls = {\r\n   /**\n    * Adds one or more CSS classes to the element.\n    *\n    * @param el - The element to add classes to (null-safe)\n    * @returns A curried function that accepts class names and returns the element\n    *\n    * @example\n    * ```typescript\n    * // Imperative (cleaner DX)\n    * cls.add(btn, 'active', 'shadow');\n    *\n    * // Curried (pipeline friendly)\n    * cls.add(btn)('active', 'shadow');\n    *\n    * // Add single class\n    * cls.add(div)('active');\n    *\n    * // Add multiple classes\n    * cls.add(div)('card', 'shadow', 'rounded');\n    *\n    * // Null-safe\n    * cls.add(null)('active'); // Returns null\n    * ```\n    */\n   add: def((el: Element | null, ...classes: string[]) => {\n     el?.classList.add(...classes);\n     return el;\n   }),\n\r\n   /**\n    * Removes one or more CSS classes from the element.\n    *\n    * @param el - The element to remove classes from (null-safe)\n    * @returns A curried function that accepts class names and returns the element\n    *\n    * @example\n    * ```typescript\n    * // Imperative (cleaner DX)\n    * cls.remove(btn, 'active', 'shadow');\n    *\n    * // Curried (pipeline friendly)\n    * cls.remove(btn)('active', 'shadow');\n    *\n    * // Remove single class\n    * cls.remove(div)('active');\n    *\n    * // Remove multiple classes\n    * cls.remove(div)('loading', 'disabled', 'error');\n    *\n    * // Safe if class doesn't exist\n    * cls.remove(div)('nonexistent'); // No error\n    * ```\n    */\n   remove: def((el: Element | null, ...classes: string[]) => {\n     el?.classList.remove(...classes);\n     return el;\n   }),\n\r\n   /**\n    * Toggles a CSS class on the element.\n    *\n    * @param el - The element to toggle the class on (null-safe)\n    * @returns A curried function that accepts class name and optional force flag\n    *\n    * @example\n    * ```typescript\n    * // Imperative (cleaner DX)\n    * cls.toggle(btn, 'active');\n    * cls.toggle(btn, 'active', true); // Force add\n    *\n    * // Curried (pipeline friendly)\n    * cls.toggle(btn)('active'); // Adds if absent, removes if present\n    * cls.toggle(btn)('active', true); // Always adds\n    * cls.toggle(btn)('active', false); // Always removes\n    *\n    * // Conditional toggle\n    * cls.toggle(button)('disabled', isLoading);\n    * ```\n    */\n   toggle: def((el: Element | null, className: string, force?: boolean) => {\n     el?.classList.toggle(className, force);\n     return el;\n   }),\n\r\n   /**\n    * Replaces an old class with a new class.\n    *\n    * @param el - The element to modify (null-safe)\n    * @returns A curried function that accepts old and new class names\n    *\n    * @example\n    * ```typescript\n    * // Imperative (cleaner DX)\n    * cls.replace(btn, 'btn-primary', 'btn-secondary');\n    *\n    * // Curried (pipeline friendly)\n    * cls.replace(btn)('btn-primary', 'btn-secondary');\n    *\n    * // Replace theme class\n    * cls.replace(div)('theme-light', 'theme-dark');\n    *\n    * // No effect if old class doesn't exist\n    * cls.replace(div)('nonexistent', 'new'); // No change\n    * ```\n    */\n   replace: def((el: Element | null, oldClass: string, newClass: string) => {\n     el?.classList.replace(oldClass, newClass);\n     return el;\n   }),\n\r\n  /**\r\n   * Checks if the element has a specific class.\r\n   * \r\n   * @param el - The element to check (null-safe)\r\n   * @returns A curried function that accepts a class name and returns boolean\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const button = document.querySelector('button');\r\n   * \r\n   * // Check for class\r\n   * if (cls.has(button)('active')) {\r\n   *   console.log('Button is active');\r\n   * }\r\n   * \r\n   * // Conditional logic\r\n   * const isDisabled = cls.has(button)('disabled');\r\n   * \r\n   * // Null-safe: returns false if element is null\r\n   * cls.has(null)('active'); // false\r\n   * ```\r\n   */\r\n  has: (el: Element | null) => (className: string) => {\r\n    return !!el && el.classList.contains(className);\r\n  }\r\n};\r\n\r\n/**\n * Observes changes to a specific class on an element.\n *\n * Uses MutationObserver to watch for class attribute changes. The callback\n * fires only when the specified class is added or removed (not on other class\n * changes). Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses attribute filtering for efficiency. Consider debouncing\n * the callback if rapid changes are expected.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts class name and callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const modal = document.querySelector('.modal');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchClass(modal, 'open', (isPresent, el) => {\n *   if (isPresent) {\n *     console.log('Modal opened');\n *     document.body.style.overflow = 'hidden';\n *   } else {\n *     console.log('Modal closed');\n *     document.body.style.overflow = '';\n *   }\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchClass(modal)('open', (isPresent, el) => {\n *   if (isPresent) {\n *     console.log('Modal opened');\n *     document.body.style.overflow = 'hidden';\n *   } else {\n *     console.log('Modal closed');\n *     document.body.style.overflow = '';\n *   }\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Watch loading state\n * watchClass(button)('loading', (isLoading) => {\n *   button.disabled = isLoading;\n * });\n *\n * // Sync state between elements\n * watchClass(sidebar)('collapsed', (isCollapsed) => {\n *   cls.toggle(mainContent)('expanded', isCollapsed);\n * });\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchClass(null)('active', callback); // () => {}\n * ```\n */\nexport const watchClass = def((target: Element | null, className: string, callback: (isPresent: boolean, el: Element) => void): Unsubscribe => {\n  if (!target) return () => { };\n  let was = target.classList.contains(className);\n  const obs = new MutationObserver(() => {\n    const is = target.classList.contains(className);\n    if (is !== was) { was = is; callback(is, target); }\n  });\n  obs.observe(target, { attributes: true, attributeFilter: ['class'] });\n  return () => obs.disconnect();\n});\n\r\n\r\n// =============================================================================\r\n// 7. DATASET & ATTRIBUTES\r\n// =============================================================================\r\n\r\nconst toDataAttr = (str: string) => 'data-' + str.replace(/[A-Z]/g, m => \"-\" + m.toLowerCase());\r\n\r\n/**\r\n * Utilities for working with data attributes (data-*).\r\n * \r\n * Provides a functional API for getting, setting, and observing data attributes.\r\n * Automatically handles type conversion (numbers, booleans, JSON) and camelCase\r\n * to kebab-case conversion.\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Set data attributes\r\n * Data.set(div)('userId', 123);        // data-user-id=\"123\"\r\n * Data.set(div)('isActive', true);     // data-is-active=\"true\"\r\n * Data.set(div)('config', { a: 1 });   // data-config='{\"a\":1}'\r\n * \r\n * // Get raw string value\r\n * const userId = Data.get(div)('userId'); // \"123\"\r\n * \r\n * // Read with type inference\r\n * const id = Data.read(div)('userId');     // 123 (number)\r\n * const active = Data.read(div)('isActive'); // true (boolean)\r\n * const config = Data.read(div)('config');   // { a: 1 } (object)\r\n * \r\n * // React to changes\r\n * Data.bind(div)('count', (value) => {\r\n *   console.log('Count changed:', value);\r\n * });\r\n * ```\r\n */\r\nexport const Data = {\r\n  /**\r\n   * Gets the raw string value of a data attribute.\r\n   * \r\n   * Returns the value as-is from the dataset. For type conversion, use `read()`.\r\n   * \r\n   * @template T - The element type (inferred)\r\n   * @param el - The element to get data from (null-safe)\r\n   * @returns A curried function that accepts a key and returns the value or undefined\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * div.dataset.userId = '123';\r\n   * \r\n   * // Get raw value\r\n   * const userId = Data.get(div)('userId'); // \"123\" (string)\r\n   * \r\n   * // CamelCase key\r\n   * const userName = Data.get(div)('userName'); // Accesses data-user-name\r\n   * \r\n   * // Missing attribute\r\n   * const missing = Data.get(div)('missing'); // undefined\r\n   * \r\n   * // Null-safe\r\n   * Data.get(null)('userId'); // undefined\r\n   * ```\r\n   */\r\n  get: (el: HTMLElement | null) => (key: string) => el?.dataset[key],\r\n\r\n   /**\n    * Sets a data attribute value.\n    *\n    * Automatically converts objects to JSON strings and handles null/undefined\n    * by removing the attribute. CamelCase keys are converted to kebab-case.\n    *\n    * @template T - The element type (inferred)\n    * @param el - The element to set data on (null-safe)\n    * @returns A curried function that accepts key and value, returns the element\n    *\n    * @example\n    * ```typescript\n    * const div = document.querySelector('div');\n    *\n    * // Imperative (cleaner DX)\n    * Data.set(div, 'userId', '123');\n    *\n    * // Curried (pipeline friendly)\n    * Data.set(div)('userId', '123');\n    *\n    * // Set number (converted to string)\n    * Data.set(div)('count', 42); // data-count=\"42\"\n    *\n    * // Set boolean\n    * Data.set(div)('isActive', true); // data-is-active=\"true\"\n    *\n    * // Set object (JSON stringified)\n    * Data.set(div)('config', { theme: 'dark', size: 'lg' });\n    * // data-config='{\"theme\":\"dark\",\"size\":\"lg\"}'\n    *\n    * // Remove attribute (null or undefined)\n    * Data.set(div)('userId', null); // Removes data-user-id\n    *\n    * // CamelCase to kebab-case\n    * Data.set(div)('userName', 'John'); // Sets data-user-name=\"John\"\n    *\n    * // Chaining\n    * Data.set(div)('id', 1);\n    * Data.set(div)('name', 'Item');\n    * ```\n    */\n   set: def((el: HTMLElement | null, key: string, val: any) => {\n     if (!el) return el;\n     if (val == null) delete el.dataset[key];\n     else el.dataset[key] = typeof val === 'object' ? JSON.stringify(val) : String(val);\n     return el;\n   }),\n\r\n  /**\r\n   * Reads a data attribute with automatic type inference.\r\n   * \r\n   * Intelligently parses the value:\r\n   * - `\"true\"` ‚Üí `true` (boolean)\r\n   * - `\"false\"` ‚Üí `false` (boolean)\r\n   * - `\"null\"` ‚Üí `null`\r\n   * - `\"123\"` ‚Üí `123` (number)\r\n   * - `'{\"a\":1}'` ‚Üí `{a:1}` (parsed JSON)\r\n   * - Other ‚Üí string\r\n   * \r\n   * @template T - The expected return type\r\n   * @param el - The element to read from (null-safe)\r\n   * @returns A curried function that accepts a key and returns the parsed value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Boolean parsing\r\n   * div.dataset.isActive = 'true';\r\n   * Data.read(div)('isActive'); // true (boolean)\r\n   * \r\n   * // Number parsing\r\n   * div.dataset.count = '42';\r\n   * Data.read(div)('count'); // 42 (number)\r\n   * \r\n   * // JSON parsing\r\n   * div.dataset.config = '{\"theme\":\"dark\"}';\r\n   * Data.read(div)('config'); // { theme: 'dark' }\r\n   * \r\n   * // String fallback\r\n   * div.dataset.name = 'John';\r\n   * Data.read(div)('name'); // \"John\" (string)\r\n   * \r\n   * // Missing attribute\r\n   * Data.read(div)('missing'); // undefined\r\n   * \r\n   * // Type-safe usage\r\n   * interface Config { theme: string; size: string; }\r\n   * const config = Data.read<Config>(div)('config');\r\n   * ```\r\n   */\r\n  read: (el: HTMLElement | null) => (key: string): any => {\r\n    if (!el || !(key in (el.dataset || {}))) return undefined;\r\n    const val = el.dataset[key]!;\r\n    if (val === 'true') return true;\r\n    if (val === 'false') return false;\r\n    if (val === 'null') return null;\r\n    if (!isNaN(Number(val)) && val.trim() !== '') return Number(val);\r\n    try { return JSON.parse(val); } catch { return val; }\r\n  },\r\n\r\n   /**\n    * Observes changes to a data attribute and fires a callback.\n    *\n    * Uses MutationObserver to watch for attribute changes. The callback fires\n    * immediately with the current value, then on every change. Values are\n    * automatically parsed using `Data.read()`.\n    *\n    * @template T - The expected value type\n    * @param el - The element to observe (null-safe)\n    * @returns A curried function that accepts key and callback, returns cleanup function\n    *\n    * @example\n    * ```typescript\n    * const div = document.querySelector('div');\n    *\n    * // Imperative (cleaner DX)\n    * const cleanup = Data.bind(div, 'count', (value, el) => {\n    *   console.log('Count is now:', value);\n    * });\n    *\n    * // Curried (pipeline friendly)\n    * const cleanup = Data.bind(div)('count', (value, el) => {\n    *   console.log('Count is now:', value);\n    *   // Fires immediately with current value\n    *   // Then fires on every change\n    * });\n    *\n    * // Later: stop watching\n    * cleanup();\n    *\n    * // Form validation example\n    * Data.bind(input)('validationError', (error) => {\n    *   if (error) {\n    *     errorDisplay.textContent = error;\n    *     errorDisplay.style.display = 'block';\n    *   } else {\n    *     errorDisplay.style.display = 'none';\n    *   }\n    * });\n    *\n    * // Sync state between components\n    * Data.bind(slider)('value', (value) => {\n    *   valueDisplay.textContent = String(value);\n    * });\n    *\n    * // Null-safe: returns no-op cleanup\n    * const noop = Data.bind(null)('key', callback); // () => {}\n    * ```\n    */\n   bind: def((el: HTMLElement | null, key: string, callback: (val: any, el: HTMLElement) => void): Unsubscribe => {\n     if (!el) return () => { };\n     const attr = toDataAttr(key);\n     const update = () => callback(Data.read(el)(key), el);\n\n     update(); // Initial\n     const obs = new MutationObserver((m) => {\n       if (m.some(x => x.attributeName === attr)) update();\n     });\n     obs.observe(el, { attributes: true, attributeFilter: [attr] });\n     return () => obs.disconnect();\n   })\n};\r\n\r\n/**\n * Observes changes to one or more attributes on an element.\n *\n * Uses MutationObserver to watch for attribute changes. The callback fires\n * whenever any of the specified attributes change, receiving the new value\n * and attribute name. Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses attribute filtering for efficiency. The observer only\n * watches the specified attributes, not all attribute changes.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts attributes and callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const input = document.querySelector('input');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchAttr(input, 'disabled', (value, attrName) => {\n *   console.log(`${attrName} changed to:`, value);\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchAttr(input)('disabled', (value, attrName) => {\n *   console.log(`${attrName} changed to:`, value);\n *   // value is the new attribute value (string | null)\n * });\n *\n * // Watch multiple attributes\n * watchAttr(input)(['value', 'placeholder', 'type'], (value, attrName) => {\n *   console.log(`${attrName} = ${value}`);\n * });\n *\n * // Form validation\n * watchAttr(input)('aria-invalid', (value) => {\n *   if (value === 'true') {\n *     input.classList.add('error');\n *   } else {\n *     input.classList.remove('error');\n *   }\n * });\n *\n * // Sync attributes between elements\n * watchAttr(sourceElement)('title', (value) => {\n *   if (value) targetElement.setAttribute('title', value);\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchAttr(null)('disabled', callback); // () => {}\n * ```\n */\nexport const watchAttr = def((target: Element | null, attrs: string | string[], callback: (val: string | null, attr: string) => void): Unsubscribe => {\n  if (!target) return () => { };\n  const obs = new MutationObserver((muts) => muts.forEach(m => {\n    if (m.attributeName) callback(target.getAttribute(m.attributeName), m.attributeName);\n  }));\n  obs.observe(target, { attributes: true, attributeFilter: Array.isArray(attrs) ? attrs : [attrs] });\n  return () => obs.disconnect();\n});\n\r\n/**\n * Observes changes to the text content of an element.\n *\n * Uses MutationObserver to watch for text content changes. The callback fires\n * whenever the element's textContent changes, receiving the new text value.\n * Returns a cleanup function to stop observing.\n *\n * **Performance**: Watches both characterData (direct text node changes) and\n * childList (when text nodes are added/removed) with subtree enabled.\n *\n * @param target - The element to observe (null-safe)\n * @returns A curried function that accepts a callback, returns cleanup function\n *\n * @example\n * ```typescript\n * const div = document.querySelector('div');\n *\n * // Imperative (cleaner DX)\n * const cleanup = watchText(div, (newText) => {\n *   console.log('Text changed to:', newText);\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = watchText(div)((newText) => {\n *   console.log('Text changed to:', newText);\n * });\n *\n * // Later: stop watching\n * cleanup();\n *\n * // Use in reactive UI\n * const counter = document.querySelector('#counter');\n * watchText(counter)((text) => {\n *   const count = parseInt(text);\n *   if (count > 100) alert('Limit exceeded!');\n * });\n *\n * // Null-safe: returns no-op cleanup\n * const noop = watchText(null)(callback); // () => {}\n * ```\n */\nexport const watchText = def((target: Element | null, callback: (text: string) => void): Unsubscribe => {\n  if (!target) return () => { };\n  const obs = new MutationObserver(() => {\n    callback(target.textContent || '');\n  });\n  obs.observe(target, { characterData: true, childList: true, subtree: true });\n  return () => obs.disconnect();\n});\n\r\n\r\n// =============================================================================\r\n// 8. LIFECYCLE\r\n// =============================================================================\r\n\r\n/**\r\n * Executes a callback when the DOM is fully loaded and parsed.\r\n * \r\n * If the DOM is already ready, the callback executes immediately (synchronously).\r\n * Otherwise, it waits for the DOMContentLoaded event. This is safer than placing\r\n * scripts at the end of the body, as it guarantees DOM availability.\r\n * \r\n * **Timing Guarantee**: The callback will execute exactly once, either immediately\r\n * or when DOMContentLoaded fires. External resources (images, stylesheets) may\r\n * still be loading.\r\n * \r\n * **SSR Considerations**: In server-side rendering contexts, ensure this code\r\n * only runs in the browser (check for `typeof document !== 'undefined'`).\r\n * \r\n * @param fn - The callback to execute when the DOM is ready\r\n * @returns void\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * onReady(() => {\r\n *   console.log('DOM is ready!');\r\n *   const app = document.querySelector('#app');\r\n *   // Safe to manipulate DOM here\r\n * });\r\n * \r\n * // Initialize app\r\n * onReady(() => {\r\n *   const form = document.querySelector('form');\r\n *   on(form)('submit', handleSubmit);\r\n *   \r\n *   const buttons = findAll(document)('button');\r\n *   buttons.forEach(btn => {\r\n *     on(btn)('click', handleClick);\r\n *   });\r\n * });\r\n * \r\n * // Multiple callbacks (each executes independently)\r\n * onReady(() => console.log('First'));\r\n * onReady(() => console.log('Second'));\r\n * \r\n * // SSR-safe usage\r\n * if (typeof document !== 'undefined') {\r\n *   onReady(() => {\r\n *     // Client-side only code\r\n *   });\r\n * }\r\n * \r\n * // Difference from window.onload:\r\n * // - onReady: Fires when DOM is parsed (faster)\r\n * // - window.onload: Fires when all resources loaded (slower)\r\n * ```\r\n */\r\nexport const onReady = (fn: () => void): void => {\r\n  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });\r\n  else fn();\r\n};\r\n\r\n/**\n * Observes when elements matching a selector are added to the DOM.\n *\n * Uses MutationObserver to watch for new elements. The handler fires for:\n * 1. Elements already in the DOM (initial check)\n * 2. Elements added dynamically after setup\n *\n * Each element is tracked using WeakSet to prevent duplicate handler calls.\n * Returns a cleanup function to stop observing.\n *\n * **Performance**: Uses WeakSet for O(1) duplicate checking without memory leaks.\n * The observer watches the entire subtree by default.\n *\n * **SPA Navigation**: Perfect for handling dynamically loaded content in single-page\n * applications where elements appear/disappear without full page reloads.\n *\n * @template S - The CSS selector string\n * @param selector - CSS selector to match elements\n * @returns A curried function that accepts handler, root, and once flag\n *\n * @example\n * ```typescript\n * // Imperative (cleaner DX)\n * const cleanup = onMount('.modal', (modal) => {\n *   console.log('Modal added:', modal);\n *   modal.classList.add('initialized');\n * });\n *\n * // Curried (pipeline friendly)\n * const cleanup = onMount('.modal')((modal) => {\n *   console.log('Modal added:', modal);\n *   modal.classList.add('initialized');\n *\n *   // Setup modal-specific behavior\n *   const closeBtn = modal.querySelector('.close');\n *   on(closeBtn)('click', () => modal.remove());\n * });\n *\n * // Later: stop observing\n * cleanup();\n *\n * // Watch within a specific container\n * const container = document.querySelector('#app');\n * onMount('.dynamic-card')((card) => {\n *   console.log('Card added');\n * }, container);\n *\n * // One-time handler (stops after first match)\n * onMount('#splash-screen')((splash) => {\n *   setTimeout(() => splash.remove(), 3000);\n * }, document, true); // once = true\n *\n * // SPA route handling\n * onMount('[data-page]')((page) => {\n *   const pageName = page.getAttribute('data-page');\n *   console.log('Page loaded:', pageName);\n *\n *   // Initialize page-specific features\n *   initializeAnalytics(pageName);\n *   loadPageData(pageName);\n * });\n *\n * // Lazy-load images as they're added\n * onMount('img[data-src]')((img) => {\n *   const src = img.getAttribute('data-src');\n *   if (src) {\n *     img.setAttribute('src', src);\n *     img.removeAttribute('data-src');\n *   }\n * });\n *\n * // Component initialization pattern\n * onMount('[data-component=\"tooltip\"]')((el) => {\n *   new Tooltip(el); // Initialize tooltip component\n * });\n * ```\n */\nexport const onMount = def((selector: string | null, handler: (el: Element) => void, root: ParentNode = document, once = false): Unsubscribe => {\n  if (!selector) return () => { };\n  const seen = new WeakSet();\n  let foundAny = false;\n  const check = (node: Element) => {\n    if (seen.has(node)) return;\n    if (node.matches(selector)) { seen.add(node); handler(node); foundAny = true; }\n    node.querySelectorAll(selector).forEach(c => {\n      if (!seen.has(c)) { seen.add(c); handler(c); foundAny = true; }\n    });\n  };\n\n  // Initial check\n  root.querySelectorAll(selector).forEach(check);\n\n  const obs = new MutationObserver(muts => muts.forEach(m => {\n    m.addedNodes.forEach(n => { if (n.nodeType === 1) check(n as Element); });\n  }));\n\n  if (once && foundAny) return () => { }; // Already found\n  obs.observe(root, { childList: true, subtree: true });\n  return () => obs.disconnect();\n});\n\r\n/**\n * Waits for a condition to become true on an element.\n *\n * Returns a Promise that resolves when the predicate returns true. Uses\n * MutationObserver to watch for changes. The predicate is checked immediately,\n * then on every mutation until it returns true.\n *\n * **Timeout Recommendation**: Consider adding a timeout wrapper to prevent\n * infinite waiting:\n * ```typescript\n * Promise.race([\n *   waitFor(el, predicate),\n *   wait(5000).then(() => { throw new Error('Timeout'); })\n * ]);\n * ```\n *\n * **Memory Leak Prevention**: The observer automatically disconnects when the\n * condition is met. If the element is null, the promise never resolves (consider\n * null-checking before calling).\n *\n * @param target - The element to observe (null-unsafe: promise won't resolve if null)\n * @returns A curried function that accepts a predicate and returns a Promise\n *\n * @example\n * ```typescript\n * const button = document.querySelector('button');\n *\n * // Imperative (cleaner DX)\n * await waitFor(button, (el) => el.classList.contains('ready'));\n * console.log('Button is ready!');\n *\n * // Curried (pipeline friendly)\n * await waitFor(button)((el) => el.classList.contains('ready'));\n * console.log('Button is ready!');\n *\n * // Wait for specific attribute value\n * await waitFor(input)((el) => el.getAttribute('data-loaded') === 'true');\n * console.log('Data loaded!');\n *\n * // Wait for child count\n * const list = document.querySelector('ul');\n * await waitFor(list)((el) => el.children.length >= 10);\n * console.log('List has at least 10 items');\n *\n * // Wait for text content\n * await waitFor(status)((el) => el.textContent?.includes('Complete'));\n * console.log('Status is complete');\n *\n * // With timeout (recommended)\n * try {\n *   await Promise.race([\n *     waitFor(element)((el) => el.classList.contains('loaded')),\n *     wait(5000).then(() => { throw new Error('Timeout waiting for element'); })\n *   ]);\n *   console.log('Element loaded in time');\n * } catch (e) {\n *   console.error('Timed out:', e);\n * }\n *\n * // Animation completion\n * element.classList.add('animating');\n * await waitFor(element)((el) => !el.classList.contains('animating'));\n * console.log('Animation complete');\n *\n * // Form validation\n * await waitFor(form)((el) => {\n *   const inputs = el.querySelectorAll('input[required]');\n *   return Array.from(inputs).every(input => input.value.length > 0);\n * });\n * console.log('All required fields filled');\n * ```\n */\nexport const waitFor = def((target: Element | null, predicate: (el: Element) => boolean): Promise<Element> => {\n  return new Promise((resolve) => {\n    if (!target) return;\n    if (predicate(target)) return resolve(target);\n    const obs = new MutationObserver(() => {\n      if (predicate(target)) { obs.disconnect(); resolve(target); }\n    });\n    obs.observe(target, { attributes: true, childList: true, subtree: true, characterData: true });\n  });\n});\n\r\n\r\n// =============================================================================\r\n// 9. UTILS (URL, FORM, ETC)\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with URL query parameters.\r\n * \r\n * Provides a functional API for reading and modifying URL search parameters.\r\n * Supports both 'soft' navigation (using pushState) and 'hard' navigation\r\n * (full page reload).\r\n * \r\n * **URL Encoding**: Values are automatically URL-encoded when set.\r\n * \r\n * @example\r\n * ```typescript\r\n * // URL: https://example.com?page=1&sort=name\r\n * \r\n * // Get single parameter\r\n * const page = Params.get('page'); // \"1\"\r\n * const missing = Params.get('missing'); // null\r\n * \r\n * // Get multiple values (for array parameters)\r\n * // URL: ?tags=js&tags=ts&tags=react\r\n * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\r\n * \r\n * // Set parameter (soft navigation - no reload)\r\n * Params.set('page')('2')(); // Updates URL without reload\r\n * // URL becomes: ?page=2&sort=name\r\n * \r\n * // Set parameter (hard navigation - full reload)\r\n * Params.set('page')('2')('hard'); // Reloads page with new URL\r\n * \r\n * // Chaining for multiple updates\r\n * Params.set('page')('1')();\r\n * Params.set('sort')('date')();\r\n * Params.set('filter')('active')();\r\n * ```\r\n */\r\nexport const Params = {\r\n  /**\r\n   * Gets a single query parameter value.\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns The parameter value or null if not found\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // URL: ?id=123&name=John\r\n   * const id = Params.get('id'); // \"123\"\r\n   * const name = Params.get('name'); // \"John\"\r\n   * const missing = Params.get('missing'); // null\r\n   * ```\r\n   */\r\n  get: (key: string) => new URLSearchParams(window.location.search).get(key),\r\n\r\n  /**\r\n   * Gets all values for a query parameter (for array-like parameters).\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns Array of all values for that parameter\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // URL: ?tags=js&tags=ts&tags=react\r\n   * const tags = Params.getAll('tags'); // [\"js\", \"ts\", \"react\"]\r\n   * \r\n   * // URL: ?filter=active\r\n   * const filters = Params.getAll('filter'); // [\"active\"]\r\n   * \r\n   * // Missing parameter\r\n   * const missing = Params.getAll('missing'); // []\r\n   * ```\r\n   */\r\n  getAll: (key: string) => new URLSearchParams(window.location.search).getAll(key),\r\n\r\n  /**\r\n   * Sets a query parameter value.\r\n   * \r\n   * @param key - The parameter name\r\n   * @returns A curried function that accepts value and navigation type\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Soft navigation (no page reload)\r\n   * Params.set('page')('2')(); // Default: soft\r\n   * Params.set('page')('2')('soft');\r\n   * \r\n   * // Hard navigation (full page reload)\r\n   * Params.set('page')('2')('hard');\r\n   * \r\n   * // Pagination example\r\n   * const nextPage = () => {\r\n   *   const current = parseInt(Params.get('page') || '1');\r\n   *   Params.set('page')(String(current + 1))();\r\n   * };\r\n   * \r\n   * // Filter example\r\n   * const applyFilter = (filter: string) => {\r\n   *   Params.set('filter')(filter)();\r\n   *   Params.set('page')('1')(); // Reset to page 1\r\n   *   loadData(); // Fetch filtered data\r\n   * };\r\n   * ```\r\n   */\r\n  set: (key: string) => (val: string) => (type: 'soft' | 'hard' = 'soft') => {\r\n    const u = new URL(window.location.href);\r\n    u.searchParams.set(key, val);\r\n    if (type === 'hard') window.location.href = u.href;\r\n    else window.history.pushState(null, '', u.href);\r\n  }\r\n};\r\n\r\n/**\r\n * Utilities for working with form data.\r\n * \r\n * Provides serialization and population of form fields. Automatically handles\r\n * different input types (text, checkbox, radio, number, select, textarea).\r\n * \r\n * **FormData Compatibility**: For native FormData support, use `new FormData(form)`.\r\n * This utility provides a plain object representation.\r\n * \r\n * @example\r\n * ```typescript\r\n * const form = document.querySelector('form');\r\n * \r\n * // Serialize form to object\r\n * const data = Form.serialize(form);\r\n * // { username: \"john\", email: \"john@example.com\", age: 25, subscribe: true }\r\n * \r\n * // Populate form from object\r\n * Form.populate(form)({\r\n *   username: \"jane\",\r\n *   email: \"jane@example.com\",\r\n *   age: 30,\r\n *   subscribe: false\r\n * });\r\n * \r\n * // Save/load form state\r\n * const saveForm = () => {\r\n *   const data = Form.serialize(form);\r\n *   Local.set('formDraft')(data);\r\n * };\r\n * \r\n * const loadForm = () => {\r\n *   const data = Local.get('formDraft');\r\n *   if (data) Form.populate(form)(data);\r\n * };\r\n * ```\r\n */\r\nexport const Form = {\r\n  /**\r\n   * Serializes form inputs into a plain object.\r\n   * \r\n   * Handles:\r\n   * - Text inputs ‚Üí string\r\n   * - Number inputs ‚Üí number\r\n   * - Checkboxes ‚Üí boolean\r\n   * - Radio buttons ‚Üí string (only checked value)\r\n   * - Select ‚Üí string\r\n   * - Textarea ‚Üí string\r\n   * \r\n   * Only includes inputs with a `name` attribute.\r\n   * \r\n   * @param root - The form or container element\r\n   * @returns Object with field names as keys and values\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const form = document.querySelector('form');\r\n   * const data = Form.serialize(form);\r\n   * \r\n   * // Submit to API\r\n   * await Http.post('/api/submit')(data);\r\n   * \r\n   * // Validate before submit\r\n   * on(form)('submit', (e) => {\r\n   *   e.preventDefault();\r\n   *   const data = Form.serialize(form);\r\n   *   if (validate(data)) {\r\n   *     submitForm(data);\r\n   *   }\r\n   * });\r\n   * \r\n   * // Auto-save draft\r\n   * const inputs = form.querySelectorAll('input, textarea');\r\n   * inputs.forEach(input => {\r\n   *   on(input)('input', debounce(() => {\r\n   *     const data = Form.serialize(form);\r\n   *     Local.set('draft')(data);\r\n   *   }, 500));\r\n   * });\r\n   * ```\r\n   */\r\n  serialize: (root: HTMLElement | null) => {\r\n    const data: Record<string, any> = {};\r\n    if (!root) return data;\r\n    root.querySelectorAll<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>('input, select, textarea').forEach(el => {\r\n      if (!el.name) return;\r\n      if ((el as HTMLInputElement).type === 'checkbox') data[el.name] = (el as HTMLInputElement).checked;\r\n      else if ((el as HTMLInputElement).type === 'radio') { if ((el as HTMLInputElement).checked) data[el.name] = el.value; }\r\n      else if ((el as HTMLInputElement).type === 'number') data[el.name] = Number(el.value);\r\n      else data[el.name] = el.value;\r\n    });\r\n    return data;\r\n  },\r\n\r\n   /**\n    * Populates form inputs from a plain object.\n    *\n    * Matches object keys to input `name` attributes and sets values accordingly.\n    *\n    * @param root - The form or container element\n    * @returns A curried function that accepts data object and returns the root\n    *\n    * @example\n    * ```typescript\n    * const form = document.querySelector('form');\n    *\n    * // Imperative (cleaner DX)\n    * Form.populate(form, {\n    *   username: 'john',\n    *   email: 'john@example.com',\n    *   notifications: true\n    * });\n    *\n    * // Curried (pipeline friendly)\n    * Form.populate(form)({\n    *   username: user.username,\n    *   email: user.email,\n    *   bio: user.bio,\n    *   notifications: user.preferences.notifications\n    * });\n    *\n    * // Load saved data\n    * const savedData = Local.get('formData');\n    * if (savedData) Form.populate(form)(savedData);\n    *\n    * // Reset form to defaults\n    * Form.populate(form)({\n    *   theme: 'light',\n    *   language: 'en',\n    *   notifications: true\n    * });\n    * ```\n    */\n   populate: def((root: HTMLElement | null, data: Record<string, any>) => {\n     if (!root) return root;\n     Object.entries(data).forEach(([k, v]) => {\n       const el = root.querySelector(`[name=\"${k}\"]`) as HTMLInputElement;\n       if (!el) return;\n       if (el.type === 'checkbox' || el.type === 'radio') el.checked = !!v;\n       else el.value = String(v);\n     });\n     return root;\n   })\n};\r\n\r\n/**\r\n * Waits for a specified number of milliseconds.\r\n * \r\n * Returns a Promise that resolves after the delay. Useful for adding delays\r\n * in async functions or creating timeouts.\r\n * \r\n * @param ms - The number of milliseconds to wait\r\n * @returns A Promise that resolves after the delay\r\n * \r\n * @example\r\n * ```typescript\r\n * // Simple delay\r\n * await wait(1000); // Wait 1 second\r\n * console.log('Done waiting');\r\n * \r\n * // Delay in async function\r\n * async function showMessage() {\r\n *   console.log('Loading...');\r\n *   await wait(2000);\r\n *   console.log('Done!');\r\n * }\r\n * \r\n * // Animation timing\r\n * async function animate() {\r\n *   element.classList.add('fade-in');\r\n *   await wait(300);\r\n *   element.classList.remove('fade-in');\r\n * }\r\n * \r\n * // Retry with delay\r\n * async function retryFetch(url: string, retries = 3) {\r\n *   for (let i = 0; i < retries; i++) {\r\n *     try {\r\n *       return await fetch(url);\r\n *     } catch (e) {\r\n *       if (i < retries - 1) await wait(1000 * (i + 1));\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport const wait = (ms: number) => new Promise(r => setTimeout(r, ms));\r\n\r\n/**\r\n * Waits for the next animation frame.\r\n * \r\n * Returns a Promise that resolves on the next requestAnimationFrame callback.\r\n * Useful for ensuring DOM updates are rendered before proceeding.\r\n * \r\n * @returns A Promise that resolves on the next frame\r\n * \r\n * @example\r\n * ```typescript\r\n * // Ensure DOM update is rendered\r\n * element.style.opacity = '0';\r\n * await nextFrame();\r\n * element.style.transition = 'opacity 0.3s';\r\n * element.style.opacity = '1';\r\n * \r\n * // Batch DOM reads after writes\r\n * element.style.width = '100px';\r\n * await nextFrame();\r\n * const width = element.offsetWidth; // Avoids layout thrashing\r\n * \r\n * // Smooth animation sequence\r\n * async function animateSequence() {\r\n *   element.classList.add('step-1');\r\n *   await nextFrame();\r\n *   element.classList.add('step-2');\r\n *   await nextFrame();\r\n *   element.classList.add('step-3');\r\n * }\r\n * ```\r\n */\r\nexport const nextFrame = () => new Promise(r => requestAnimationFrame(r));\r\n\r\n/** CSS Template Literal for highlighting */\r\nexport const cssTemplate = (strings: TemplateStringsArray, ...values: any[]) =>\r\n  strings.reduce((acc, s, i) => acc + s + (values[i] ?? ''), '');\r\n\r\n// =============================================================================\r\n// 10. NAVIGATION (TRAVERSAL)\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for DOM tree traversal.\r\n * \r\n * Provides a functional API for navigating the DOM tree (parent, siblings, children).\r\n * All methods are null-safe and preserve element types where possible.\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.item');\r\n * \r\n * // Navigate to parent\r\n * const parent = Traverse.parent(element);\r\n * \r\n * // Get siblings\r\n * const siblings = Traverse.siblings(element);\r\n * siblings.forEach(sibling => sibling.classList.add('sibling'));\r\n * \r\n * // Navigate to next/previous\r\n * const next = Traverse.next(element);\r\n * const prev = Traverse.prev(element);\r\n * \r\n * // Get all children\r\n * const children = Traverse.children(element);\r\n * ```\r\n */\r\nexport const Traverse = {\r\n  /**\r\n   * Gets the parent element.\r\n   * \r\n   * @param el - The element to get the parent of\r\n   * @returns The parent element or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const listItem = document.querySelector('li');\r\n   * const list = Traverse.parent(listItem); // <ul>\r\n   * \r\n   * // Navigate up multiple levels\r\n   * const grandparent = Traverse.parent(Traverse.parent(element));\r\n   * \r\n   * // Null-safe\r\n   * Traverse.parent(null); // null\r\n   * Traverse.parent(document.documentElement); // null (no parent)\r\n   * ```\r\n   */\r\n  parent: (el: Element | null) => el?.parentElement || null,\r\n\r\n  /**\r\n   * Gets the next sibling element.\r\n   * \r\n   * @param el - The element to get the next sibling of\r\n   * @returns The next sibling element or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const first = document.querySelector('li:first-child');\r\n   * const second = Traverse.next(first);\r\n   * \r\n   * // Iterate through siblings\r\n   * let current = firstElement;\r\n   * while (current) {\r\n   *   console.log(current);\r\n   *   current = Traverse.next(current);\r\n   * }\r\n   * \r\n   * // Null-safe\r\n   * Traverse.next(null); // null\r\n   * Traverse.next(lastElement); // null (no next sibling)\r\n   * ```\r\n   */\r\n  next: (el: Element | null) => el?.nextElementSibling as HTMLElement | null,\r\n\r\n  /**\r\n   * Gets the previous sibling element.\r\n   * \r\n   * @param el - The element to get the previous sibling of\r\n   * @returns The previous sibling element or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const last = document.querySelector('li:last-child');\r\n   * const secondLast = Traverse.prev(last);\r\n   * \r\n   * // Iterate backwards\r\n   * let current = lastElement;\r\n   * while (current) {\r\n   *   console.log(current);\r\n   *   current = Traverse.prev(current);\r\n   * }\r\n   * ```\r\n   */\r\n  prev: (el: Element | null) => el?.previousElementSibling as HTMLElement | null,\r\n\r\n  /**\r\n   * Gets all child elements as an array.\r\n   * \r\n   * @param el - The element to get children of\r\n   * @returns Array of child elements (empty if no children or null)\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const list = document.querySelector('ul');\r\n   * const items = Traverse.children(list); // Array of <li> elements\r\n   * \r\n   * // Process children\r\n   * Traverse.children(container).forEach((child, index) => {\r\n   *   child.dataset.index = String(index);\r\n   * });\r\n   * \r\n   * // Count children\r\n   * const childCount = Traverse.children(element).length;\r\n   * \r\n   * // Null-safe\r\n   * Traverse.children(null); // []\r\n   * ```\r\n   */\r\n  children: (el: Element | null) => el ? Array.from(el.children) as HTMLElement[] : [],\r\n\r\n  /**\r\n   * Gets all sibling elements (excluding the element itself).\r\n   * \r\n   * @param el - The element to get siblings of\r\n   * @returns Array of sibling elements (empty if no siblings or null)\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const activeItem = document.querySelector('.active');\r\n   * const siblings = Traverse.siblings(activeItem);\r\n   * \r\n   * // Remove active class from siblings\r\n   * Traverse.siblings(activeItem).forEach(sibling => {\r\n   *   sibling.classList.remove('active');\r\n   * });\r\n   * \r\n   * // Highlight siblings\r\n   * Traverse.siblings(element).forEach(sibling => {\r\n   *   sibling.style.opacity = '0.5';\r\n   * });\r\n   * \r\n   * // Null-safe\r\n   * Traverse.siblings(null); // []\r\n   * ```\r\n   */\r\n  siblings: (el: Element | null) => {\r\n    if (!el || !el.parentElement) return [];\r\n    return Array.from(el.parentElement.children).filter(c => c !== el) as HTMLElement[];\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 11. CSS VARIABLES & ANIMATION\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with CSS custom properties (variables).\r\n * \r\n * Provides a functional API for getting and setting CSS variables on elements.\r\n * Variables can be set at any level (element, :root, etc.) and will cascade\r\n * according to CSS specificity rules.\r\n * \r\n * **Fallback Values**: When getting variables, you can provide fallback values\r\n * using standard CSS syntax: `var(--color, blue)`.\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.card');\r\n * \r\n * // Set CSS variable\r\n * CssVar.set(element)('--primary-color', '#007bff');\r\n * CssVar.set(element)('--spacing', '1rem');\r\n * \r\n * // Get CSS variable\r\n * const color = CssVar.get(element)('--primary-color'); // \"#007bff\"\r\n * \r\n * // Set on :root for global theme\r\n * CssVar.set(document.documentElement)('--theme', 'dark');\r\n * \r\n * // Dynamic theming\r\n * const setTheme = (theme: 'light' | 'dark') => {\r\n *   const root = document.documentElement;\r\n *   if (theme === 'dark') {\r\n *     CssVar.set(root)('--bg', '#1a1a1a');\r\n *     CssVar.set(root)('--text', '#ffffff');\r\n *   } else {\r\n *     CssVar.set(root)('--bg', '#ffffff');\r\n *     CssVar.set(root)('--text', '#000000');\r\n *   }\r\n * };\r\n * ```\r\n */\r\nexport const CssVar = {\r\n  /**\r\n   * Sets a CSS custom property (variable) on an element.\r\n   * \r\n   * @param el - The element to set the variable on (null-safe)\r\n   * @returns A curried function that accepts name and value, returns the element\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Set single variable\r\n   * CssVar.set(div)('--color', 'red');\r\n   * \r\n   * // Set multiple variables\r\n   * CssVar.set(div)('--width', '100px');\r\n   * CssVar.set(div)('--height', '100px');\r\n   * \r\n   * // Global theme variables\r\n   * const root = document.documentElement;\r\n   * CssVar.set(root)('--primary', '#007bff');\r\n   * CssVar.set(root)('--secondary', '#6c757d');\r\n   * \r\n   * // Dynamic values\r\n   * CssVar.set(element)('--progress', `${percentage}%`);\r\n   * \r\n   * // Null-safe\r\n   * CssVar.set(null)('--color', 'red'); // Returns null\r\n   * ```\r\n   */\r\n  set: (el: HTMLElement | null) => (name: string, value: string) => {\r\n    el?.style.setProperty(name, value);\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Gets the computed value of a CSS custom property.\r\n   * \r\n   * Returns the computed value, which may be inherited from a parent element\r\n   * or :root. The value is trimmed of whitespace.\r\n   * \r\n   * @param el - The element to get the variable from (null-safe)\r\n   * @returns A curried function that accepts name and returns the value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const div = document.querySelector('div');\r\n   * \r\n   * // Get variable value\r\n   * const color = CssVar.get(div)('--primary-color');\r\n   * \r\n   * // Get inherited variable\r\n   * const spacing = CssVar.get(div)('--spacing'); // May come from parent\r\n   * \r\n   * // Use in calculations\r\n   * const width = parseInt(CssVar.get(element)('--width'));\r\n   * \r\n   * // Check if variable is set\r\n   * const hasTheme = CssVar.get(document.documentElement)('--theme') !== '';\r\n   * \r\n   * // Null-safe\r\n   * CssVar.get(null)('--color'); // \"\"\r\n   * ```\r\n   */\r\n  get: (el: HTMLElement | null) => (name: string) => {\r\n    return el ? getComputedStyle(el).getPropertyValue(name).trim() : '';\r\n  }\r\n};\r\n\r\n/**\r\n * Reads a computed CSS property value from an element.\r\n * \r\n * Gets the final computed value of any CSS property, including inherited values,\r\n * cascaded values, and browser defaults. Useful for reading actual rendered values\r\n * rather than inline styles.\r\n * \r\n * **Unit Parsing**: The returned value includes units (e.g., \"16px\", \"1.5em\").\r\n * Parse with `parseInt()` or `parseFloat()` if you need numeric values.\r\n * \r\n * **Computed vs Inline**: This reads computed styles (what's actually rendered),\r\n * not inline styles. Use `element.style.property` for inline styles only.\r\n * \r\n * @param el - The element to read from (null-safe)\r\n * @returns A curried function that accepts a property name and returns the value\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * \r\n * // Get computed width (includes padding, border if box-sizing)\r\n * const width = computed(div)('width'); // \"200px\"\r\n * \r\n * // Get font size\r\n * const fontSize = computed(div)('fontSize'); // \"16px\"\r\n * \r\n * // Get color (returns rgb/rgba)\r\n * const color = computed(div)('color'); // \"rgb(0, 0, 0)\"\r\n * \r\n * // Parse numeric values\r\n * const widthNum = parseInt(computed(div)('width')); // 200\r\n * \r\n * // Check display state\r\n * const isHidden = computed(div)('display') === 'none';\r\n * \r\n * // Get inherited values\r\n * const lineHeight = computed(div)('lineHeight');\r\n * \r\n * // Null-safe\r\n * computed(null)('width'); // \"\"\r\n * ```\r\n */\r\nexport const computed = (el: HTMLElement | null) => (prop: keyof CSSStyleDeclaration): string => {\r\n  if (!el) return '';\r\n  const value = getComputedStyle(el)[prop];\r\n  return typeof value === 'string' ? value : String(value);\r\n};\r\n\r\n/**\r\n * Injects CSS styles into the document.\r\n * \r\n * Creates a <style> element with the provided CSS content and appends it to\r\n * the specified root (defaults to document.head). Returns a cleanup function\r\n * to remove the styles.\r\n * \r\n * **CSP Considerations**: If your site uses Content Security Policy, ensure\r\n * inline styles are allowed or use nonces/hashes.\r\n * \r\n * **Style Precedence**: Injected styles follow normal CSS cascade rules.\r\n * Later injected styles override earlier ones (if same specificity).\r\n * \r\n * **Scoping**: For scoped styles, use a unique class or data attribute as a\r\n * prefix in your CSS selectors.\r\n * \r\n * @param cssContent - The CSS content to inject\r\n * @param root - The node to append the style element to (defaults to document.head)\r\n * @returns A cleanup function that removes the injected styles\r\n * \r\n * @example\r\n * ```typescript\r\n * // Inject global styles\r\n * const cleanup = injectStyles(`\r\n *   body { background: #1a1a1a; color: #fff; }\r\n *   .card { border-radius: 8px; }\r\n * `);\r\n * \r\n * // Later: remove styles\r\n * cleanup();\r\n * \r\n * // Component-specific styles\r\n * const initModal = () => {\r\n *   const cleanup = injectStyles(`\r\n *     .modal { position: fixed; inset: 0; }\r\n *     .modal-backdrop { background: rgba(0,0,0,0.5); }\r\n *   `);\r\n *   \r\n *   return cleanup; // Return for cleanup when modal is destroyed\r\n * };\r\n * \r\n * // Scoped styles\r\n * const cleanup = injectStyles(`\r\n *   [data-theme=\"dark\"] {\r\n *     --bg: #1a1a1a;\r\n *     --text: #ffffff;\r\n *   }\r\n * `);\r\n * \r\n * // Inject into shadow DOM\r\n * const shadow = element.attachShadow({ mode: 'open' });\r\n * injectStyles('.component { color: red; }', shadow);\r\n * \r\n * // Temporary styles (auto-cleanup)\r\n * const showHighlight = async () => {\r\n *   const cleanup = injectStyles('.highlight { background: yellow; }');\r\n *   await wait(3000);\r\n *   cleanup(); // Remove after 3 seconds\r\n * };\r\n * ```\r\n */\r\nexport const injectStyles = (cssContent: string, root: Node = document.head): Unsubscribe => {\r\n  const style = document.createElement('style');\r\n  style.textContent = cssContent;\r\n  root.appendChild(style);\r\n  return () => style.remove();\r\n};\r\n\r\n/**\r\n * Waits for a CSS transition or animation to complete.\r\n * \r\n * Returns a Promise that resolves when the element's transition or animation\r\n * ends. Includes a fallback that resolves immediately if no transition/animation\r\n * is active (duration is 0s or element has display:none).\r\n * \r\n * **Fallback Timeout**: The promise includes a built-in fallback that resolves\r\n * if no transition/animation is detected. For additional safety, wrap in\r\n * `Promise.race()` with a timeout.\r\n * \r\n * **Animation Event Handling**: Listens for both `transitionend` and `animationend`\r\n * events. Automatically cleans up event listeners when resolved.\r\n * \r\n * @param el - The element to wait for (null-safe)\r\n * @returns A Promise that resolves with the element (or null) when complete\r\n * \r\n * @example\r\n * ```typescript\r\n * const modal = document.querySelector('.modal');\r\n * \r\n * // Wait for fade-in animation\r\n * modal.classList.add('fade-in');\r\n * await waitTransition(modal);\r\n * console.log('Animation complete!');\r\n * \r\n * // Smooth hide/remove pattern\r\n * element.classList.add('fade-out');\r\n * await waitTransition(element);\r\n * element.remove(); // Remove after animation\r\n * \r\n * // Sequential animations\r\n * element.classList.add('slide-in');\r\n * await waitTransition(element);\r\n * element.classList.add('pulse');\r\n * await waitTransition(element);\r\n * element.classList.remove('pulse');\r\n * \r\n * // Modal close with animation\r\n * const closeModal = async (modal: HTMLElement) => {\r\n *   modal.classList.remove('show');\r\n *   await waitTransition(modal);\r\n *   modal.style.display = 'none';\r\n * };\r\n * \r\n * // With timeout safety\r\n * try {\r\n *   await Promise.race([\r\n *     waitTransition(element),\r\n *     wait(5000).then(() => { throw new Error('Animation timeout'); })\r\n *   ]);\r\n * } catch (e) {\r\n *   console.error('Animation took too long');\r\n * }\r\n * \r\n * // Null-safe\r\n * await waitTransition(null); // Resolves immediately with null\r\n * ```\r\n */\r\nexport const waitTransition = (el: HTMLElement | null) => new Promise<HTMLElement | null>((resolve) => {\r\n  if (!el) return resolve(null);\r\n\r\n  const onEnd = () => {\r\n    el.removeEventListener('transitionend', onEnd);\r\n    el.removeEventListener('animationend', onEnd);\r\n    resolve(el);\r\n  };\r\n\r\n  el.addEventListener('transitionend', onEnd);\r\n  el.addEventListener('animationend', onEnd);\r\n\r\n  // Fallback: If no transition happens (e.g. display:none or 0s duration), resolve anyway.\r\n  requestAnimationFrame(() => {\r\n    const s = getComputedStyle(el);\r\n    if (s.transitionDuration === '0s' && s.animationDuration === '0s') onEnd();\r\n  });\r\n});\r\n\r\n\r\n// =============================================================================\r\n// 12. OBJECTS & STATE\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with plain JavaScript objects.\r\n * \r\n * Provides functional helpers for common object operations like cloning,\r\n * equality checking, and key picking/omitting.\r\n * \r\n * **Immutability**: These utilities create new objects rather than mutating\r\n * existing ones, following functional programming principles.\r\n * \r\n * **Performance**: For large objects or frequent operations, consider using\r\n * specialized libraries like Lodash or Ramda.\r\n * \r\n * @example\r\n * ```typescript\r\n * const user = { id: 1, name: 'John', email: 'john@example.com', role: 'admin' };\r\n * \r\n * // Deep clone\r\n * const userCopy = Obj.clone(user);\r\n * \r\n * // Check equality\r\n * const isSame = Obj.isEqual(user, userCopy); // true\r\n * \r\n * // Pick specific keys\r\n * const publicData = Obj.pick(user, ['id', 'name']); // { id: 1, name: 'John' }\r\n * \r\n * // Omit sensitive keys\r\n * const safeData = Obj.omit(user, ['email', 'role']); // { id: 1, name: 'John' }\r\n * ```\r\n */\r\nexport const Obj = {\r\n  /**\r\n   * Creates a deep clone of an object.\r\n   * \r\n   * Uses `structuredClone()` if available (modern browsers), falls back to\r\n   * JSON parse/stringify. Note: JSON fallback doesn't preserve functions,\r\n   * undefined values, or circular references.\r\n   * \r\n   * @template T - The type of the object to clone\r\n   * @param obj - The object to clone\r\n   * @returns A deep copy of the object\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const original = { a: 1, b: { c: 2 } };\r\n   * const copy = Obj.clone(original);\r\n   * \r\n   * copy.b.c = 3;\r\n   * console.log(original.b.c); // 2 (unchanged)\r\n   * \r\n   * // Clone arrays\r\n   * const arr = [1, [2, 3], { a: 4 }];\r\n   * const arrCopy = Obj.clone(arr);\r\n   * \r\n   * // Clone complex objects\r\n   * const state = {\r\n   *   user: { id: 1, profile: { name: 'John' } },\r\n   *   settings: { theme: 'dark', notifications: true }\r\n   * };\r\n   * const stateCopy = Obj.clone(state);\r\n   * ```\r\n   */\r\n  clone: <T>(obj: T): T => {\r\n    try { return structuredClone(obj); }\r\n    catch { return JSON.parse(JSON.stringify(obj)); }\r\n  },\r\n\r\n  /**\r\n   * Checks deep equality between two values.\r\n   * \r\n   * Compares values recursively. Uses JSON stringification for deep comparison,\r\n   * so objects with different key orders will be considered different.\r\n   * \r\n   * @param a - First value\r\n   * @param b - Second value\r\n   * @returns True if values are deeply equal\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Primitive equality\r\n   * Obj.isEqual(1, 1); // true\r\n   * Obj.isEqual('a', 'b'); // false\r\n   * \r\n   * // Object equality\r\n   * Obj.isEqual({ a: 1 }, { a: 1 }); // true\r\n   * Obj.isEqual({ a: 1, b: 2 }, { b: 2, a: 1 }); // false (different order)\r\n   * \r\n   * // Nested objects\r\n   * Obj.isEqual(\r\n   *   { user: { name: 'John', age: 30 } },\r\n   *   { user: { name: 'John', age: 30 } }\r\n   * ); // true\r\n   * \r\n   * // Arrays\r\n   * Obj.isEqual([1, 2, 3], [1, 2, 3]); // true\r\n   * Obj.isEqual([1, 2], [2, 1]); // false\r\n   * ```\r\n   */\r\n  isEqual: (a: any, b: any) => a === b || JSON.stringify(a) === JSON.stringify(b),\r\n\r\n  /**\r\n   * Creates a new object with only the specified keys.\r\n   * \r\n   * @template T - The object type\r\n   * @template K - The keys to pick\r\n   * @param obj - The source object\r\n   * @param keys - Array of keys to include\r\n   * @returns A new object with only the specified keys\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const user = {\r\n   *   id: 1,\r\n   *   name: 'John',\r\n   *   email: 'john@example.com',\r\n   *   password: 'secret',\r\n   *   role: 'admin'\r\n   * };\r\n   * \r\n   * // Pick public fields\r\n   * const publicUser = Obj.pick(user, ['id', 'name']);\r\n   * // { id: 1, name: 'John' }\r\n   * \r\n   * // Pick for API response\r\n   * const apiResponse = Obj.pick(user, ['id', 'name', 'email']);\r\n   * \r\n   * // Type-safe picking\r\n   * type User = typeof user;\r\n   * const picked: Pick<User, 'id' | 'name'> = Obj.pick(user, ['id', 'name']);\r\n   * ```\r\n   */\r\n  pick: <T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {\r\n    const ret = {} as Pick<T, K>;\r\n    keys.forEach(k => { if (k in obj) ret[k] = obj[k]; });\r\n    return ret;\r\n  },\r\n\r\n  /**\r\n   * Creates a new object excluding the specified keys.\r\n   * \r\n   * @template T - The object type\r\n   * @template K - The keys to omit\r\n   * @param obj - The source object\r\n   * @param keys - Array of keys to exclude\r\n   * @returns A new object without the specified keys\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const user = {\r\n   *   id: 1,\r\n   *   name: 'John',\r\n   *   email: 'john@example.com',\r\n   *   password: 'secret',\r\n   *   role: 'admin'\r\n   * };\r\n   * \r\n   * // Omit sensitive fields\r\n   * const safeUser = Obj.omit(user, ['password']);\r\n   * // { id: 1, name: 'John', email: 'john@example.com', role: 'admin' }\r\n   * \r\n   * // Omit multiple fields\r\n   * const publicUser = Obj.omit(user, ['password', 'email', 'role']);\r\n   * // { id: 1, name: 'John' }\r\n   * \r\n   * // Type-safe omitting\r\n   * type User = typeof user;\r\n   * const omitted: Omit<User, 'password'> = Obj.omit(user, ['password']);\r\n   * ```\r\n   */\r\n  omit: <T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {\r\n    const ret = { ...obj };\r\n    keys.forEach(k => delete ret[k]);\r\n    return ret as Omit<T, K>;\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 13. COLLECTIONS (BATCHING)\r\n// =============================================================================\r\n\r\n/**\r\n * Applies a function to each element in a collection.\r\n * \r\n * Similar to `Array.forEach()` but works with any iterable or array-like object\r\n * (NodeList, HTMLCollection, etc.). Returns the array for further processing.\r\n * \r\n * **Performance**: For simple iterations, native `forEach()` may be faster.\r\n * Use this when you need to work with non-array collections or want the return value.\r\n * \r\n * **vs forEach**: Unlike `forEach()`, this returns the array, allowing for\r\n * further chaining or processing.\r\n * \r\n * @template T - The element type\r\n * @param list - The collection to iterate over (null-safe)\r\n * @returns A curried function that accepts a callback and returns the array\r\n * \r\n * @example\r\n * ```typescript\r\n * // Work with NodeList\r\n * const items = document.querySelectorAll('li');\r\n * batch(items)((el, index) => {\r\n *   el.dataset.index = String(index);\r\n *   el.classList.add('processed');\r\n * });\r\n * \r\n * // Work with HTMLCollection\r\n * const divs = document.getElementsByTagName('div');\r\n * batch(divs)((div) => {\r\n *   div.style.opacity = '0.5';\r\n * });\r\n * \r\n * // Remove all matching elements\r\n * batch(document.querySelectorAll('.temp'))((el) => el.remove());\r\n * \r\n * // Add event listeners to multiple elements\r\n * batch(document.querySelectorAll('button'))((btn, i) => {\r\n *   on(btn)('click', () => console.log('Button', i, 'clicked'));\r\n * });\r\n * \r\n * // Chain with other operations\r\n * const elements = batch(items)((el) => el.classList.add('active'));\r\n * console.log('Processed', elements.length, 'elements');\r\n * \r\n * // Null-safe\r\n * batch(null)((el) => console.log(el)); // Returns []\r\n * ```\r\n */\r\nexport const batch = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\r\n  return (fn: (el: T, index: number) => void): T[] => {\r\n    if (!list) return [];\r\n    const arr = Array.from(list);\r\n    arr.forEach(fn);\r\n    return arr;\r\n  };\r\n};\r\n\r\n/**\r\n * Groups elements by a key function.\r\n * \r\n * Creates an object where keys are the result of the key function and values\r\n * are arrays of elements that produced that key. Useful for categorizing or\r\n * organizing collections of elements.\r\n * \r\n * **Type Inference**: The key function should return a string. For better type\r\n * safety, consider using a union of string literals as the return type.\r\n * \r\n * **Memory Considerations**: For very large collections, consider processing\r\n * in chunks or using a Map instead of a plain object.\r\n * \r\n * @template T - The element type\r\n * @param list - The collection to group (null-safe)\r\n * @returns A curried function that accepts a key function and returns grouped object\r\n * \r\n * @example\r\n * ```typescript\r\n * // Group by data attribute\r\n * const items = document.querySelectorAll('[data-category]');\r\n * const byCategory = groupBy(items)(el => el.dataset.category || 'uncategorized');\r\n * // { electronics: [...], clothing: [...], uncategorized: [...] }\r\n * \r\n * // Group by tag name\r\n * const elements = document.querySelectorAll('*');\r\n * const byTag = groupBy(elements)(el => el.tagName.toLowerCase());\r\n * // { div: [...], span: [...], button: [...], ... }\r\n * \r\n * // Group by class presence\r\n * const allDivs = document.querySelectorAll('div');\r\n * const byStatus = groupBy(allDivs)(el => \r\n *   el.classList.contains('active') ? 'active' : 'inactive'\r\n * );\r\n * \r\n * // Process groups\r\n * Object.entries(byCategory).forEach(([category, elements]) => {\r\n *   console.log(`${category}: ${elements.length} items`);\r\n *   elements.forEach(el => el.classList.add(`category-${category}`));\r\n * });\r\n * \r\n * // Group form inputs by type\r\n * const inputs = document.querySelectorAll('input');\r\n * const byType = groupBy(inputs)(input => input.type);\r\n * // { text: [...], email: [...], checkbox: [...], ... }\r\n * \r\n * // Null-safe\r\n * groupBy(null)(el => 'key'); // {}\r\n * ```\r\n */\r\nexport const groupBy = <T extends Element>(list: Iterable<T> | ArrayLike<T> | null) => {\r\n  return (keyFn: (el: T) => string): Record<string, T[]> => {\r\n    const groups: Record<string, T[]> = {};\r\n    if (!list) return groups;\r\n    Array.from(list).forEach(el => {\r\n      const k = keyFn(el);\r\n      (groups[k] = groups[k] || []).push(el);\r\n    });\r\n    return groups;\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 14. COMPONENT REFS\r\n// =============================================================================\r\n\r\n/**\r\n * Collects elements with `data-ref` attributes into a typed object.\r\n * \r\n * Scans the root element for children with `data-ref` attributes and creates\r\n * an object mapping ref names to elements. Useful for component-based patterns\r\n * where you need quick access to specific child elements.\r\n * \r\n * **Generic Ref Map**: For type-safe ref access, define an interface for your\r\n * expected refs and cast the result.\r\n * \r\n * **Duplicate Handling**: If multiple elements have the same ref name, only\r\n * the last one is kept. Use `groupRefs()` if you need all duplicates.\r\n * \r\n * @param root - The root element to search within (null-safe)\r\n * @returns Object mapping ref names to elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <form>\r\n * //   <input data-ref=\"username\" />\r\n * //   <input data-ref=\"email\" />\r\n * //   <button data-ref=\"submit\">Submit</button>\r\n * // </form>\r\n * \r\n * const form = document.querySelector('form');\r\n * const { username, email, submit } = refs(form);\r\n * \r\n * // Type-safe access\r\n * on(submit)('click', () => {\r\n *   const data = {\r\n *     username: (username as HTMLInputElement).value,\r\n *     email: (email as HTMLInputElement).value\r\n *   };\r\n *   console.log(data);\r\n * });\r\n * \r\n * // Component pattern\r\n * interface ModalRefs {\r\n *   title: HTMLElement;\r\n *   content: HTMLElement;\r\n *   closeBtn: HTMLElement;\r\n * }\r\n * \r\n * const modal = document.querySelector('.modal');\r\n * const r = refs(modal) as unknown as ModalRefs;\r\n * \r\n * modify(r.title)({ text: 'Welcome!' });\r\n * on(r.closeBtn)('click', () => modal.remove());\r\n * \r\n * // Null-safe\r\n * refs(null); // {}\r\n * ```\r\n */\r\nexport const refs = (root: ParentNode | null): Record<string, HTMLElement> => {\r\n  const r: Record<string, HTMLElement> = {};\r\n  if (root) {\r\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\r\n      if (el.dataset.ref) r[el.dataset.ref] = el;\r\n    });\r\n  }\r\n  return r;\r\n};\r\n\r\n/**\r\n * Collects elements with `data-ref` attributes into arrays.\r\n * \r\n * Like `refs()` but allows multiple elements with the same ref name. Each ref\r\n * name maps to an array of all elements with that ref.\r\n * \r\n * **Array Typing**: All refs are arrays, even if only one element exists.\r\n * This ensures consistent access patterns.\r\n * \r\n * **Duplicate Handling**: Unlike `refs()`, this preserves all elements with\r\n * the same ref name in document order.\r\n * \r\n * @param root - The root element to search within (null-safe)\r\n * @returns Object mapping ref names to arrays of elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <ul>\r\n * //   <li data-ref=\"item\">Item 1</li>\r\n * //   <li data-ref=\"item\">Item 2</li>\r\n * //   <li data-ref=\"item\">Item 3</li>\r\n * //   <button data-ref=\"action\">Delete All</button>\r\n * // </ul>\r\n * \r\n * const list = document.querySelector('ul');\r\n * const { item, action } = groupRefs(list);\r\n * \r\n * console.log(item.length); // 3\r\n * console.log(action.length); // 1\r\n * \r\n * // Process all items\r\n * item.forEach((el, index) => {\r\n *   el.dataset.index = String(index);\r\n * });\r\n * \r\n * // Add listeners to all items\r\n * item.forEach(el => {\r\n *   on(el)('click', () => console.log('Item clicked'));\r\n * });\r\n * \r\n * // Single action button (still an array)\r\n * on(action[0])('click', () => {\r\n *   item.forEach(el => el.remove());\r\n * });\r\n * \r\n * // Null-safe\r\n * groupRefs(null); // {}\r\n * ```\r\n */\r\nexport const groupRefs = (root: ParentNode | null): Record<string, HTMLElement[]> => {\r\n  const r: Record<string, HTMLElement[]> = {};\r\n  if (root) {\r\n    root.querySelectorAll<HTMLElement>('[data-ref]').forEach(el => {\r\n      const k = el.dataset.ref;\r\n      if (k) (r[k] = r[k] || []).push(el);\r\n    });\r\n  }\r\n  return r;\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 15. COLOR UTILS\r\n// =============================================================================\r\n\r\n/**\r\n * Converts a color to a specific color space.\r\n * \r\n * Uses CSS `color-mix()` to convert colors between color spaces like sRGB,\r\n * Display P3, etc. Requires a browser environment and modern browser support.\r\n * \r\n * **Browser Support**: Requires support for `color-mix()` function (modern browsers).\r\n * Check compatibility before using in production.\r\n * \r\n * **Color Space Literal Types**: Common values include 'srgb', 'display-p3',\r\n * 'rec2020', 'a98-rgb', 'prophoto-rgb'.\r\n * \r\n * @param color - The color to convert (any valid CSS color)\r\n * @param space - The target color space (defaults to 'srgb')\r\n * @returns The color in the specified color space\r\n * \r\n * @example\r\n * ```typescript\r\n * // Convert to Display P3 (wider gamut)\r\n * const p3Blue = toColorSpace('blue', 'display-p3');\r\n * \r\n * // Convert hex to P3\r\n * const p3Red = toColorSpace('#ff0000', 'display-p3');\r\n * \r\n * // Convert named color\r\n * const p3Green = toColorSpace('green', 'display-p3');\r\n * \r\n * // Use in dynamic theming\r\n * const primaryColor = '#007bff';\r\n * const p3Primary = toColorSpace(primaryColor, 'display-p3');\r\n * CssVar.set(document.documentElement)('--primary-p3', p3Primary);\r\n * \r\n * // Check browser support\r\n * try {\r\n *   const converted = toColorSpace('red', 'display-p3');\r\n *   console.log('P3 supported:', converted);\r\n * } catch (e) {\r\n *   console.log('P3 not supported, using fallback');\r\n * }\r\n * ```\r\n */\r\nexport const toColorSpace = (color: string, space: string = 'srgb'): string => {\r\n  const div = document.createElement('div');\r\n  div.style.color = `color-mix(in ${space}, ${color} 100%, transparent)`;\r\n  document.body.appendChild(div);\r\n  const res = getComputedStyle(div).color;\r\n  div.remove();\r\n  return res;\r\n};\r\n\r\n// =============================================================================\r\n// 16. CLASS CYCLING & STATE MACHINES\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a function that cycles through a list of CSS classes.\r\n * \r\n * Returns a function that, when called, removes the current class and adds\r\n * the next one in the list. Useful for state machines, loading indicators,\r\n * or any cyclical UI states.\r\n * \r\n * **State Machine Type Inference**: For better type safety, define your states\r\n * as a const array with `as const` assertion.\r\n * \r\n * **State Persistence**: The current state is tracked internally. If you need\r\n * to persist state across page reloads, store the current index in localStorage.\r\n * \r\n * @param target - The element to cycle classes on (null-safe)\r\n * @returns A curried function that accepts class array and returns cycle function\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Loading states\r\n * const nextState = cycleClass(button)(['idle', 'loading', 'success', 'error']);\r\n * \r\n * on(button)('click', async () => {\r\n *   nextState(); // idle -> loading\r\n *   try {\r\n *     await fetchData();\r\n *     nextState(); // loading -> success\r\n *   } catch (e) {\r\n *     nextState(); // success -> error (or loading -> error)\r\n *   }\r\n * });\r\n * \r\n * // Traffic light simulation\r\n * const light = document.querySelector('.traffic-light');\r\n * const nextLight = cycleClass(light)(['red', 'yellow', 'green']);\r\n * setInterval(nextLight, 2000); // Cycle every 2 seconds\r\n * \r\n * // Theme cycling\r\n * const themeBtn = document.querySelector('.theme-toggle');\r\n * const cycleTheme = cycleClass(document.documentElement)(\r\n *   ['theme-light', 'theme-dark', 'theme-auto']\r\n * );\r\n * on(themeBtn)('click', cycleTheme);\r\n * \r\n * // Animation states\r\n * const box = document.querySelector('.box');\r\n * const animate = cycleClass(box)(['bounce', 'shake', 'pulse', 'spin']);\r\n * on(box)('click', animate);\r\n * \r\n * // Null-safe\r\n * const noop = cycleClass(null)(['a', 'b']); // Returns () => {}\r\n * ```\r\n */\r\nexport const cycleClass = (target: Element | null) => {\r\n  return (classes: string[]): (() => void) => {\r\n    if (!target) return () => { };\r\n\r\n    return () => {\r\n      const currentIdx = classes.findIndex(c => target.classList.contains(c));\r\n\r\n      // Remove current class if found\r\n      if (currentIdx > -1) target.classList.remove(classes[currentIdx]);\r\n\r\n      // Add next class\r\n      const nextIdx = (currentIdx + 1) % classes.length;\r\n      target.classList.add(classes[nextIdx]);\r\n    };\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 17. CLEANUP & TEMPLATES\r\n// =============================================================================\r\n\r\n/**\r\n * Removes all event listeners from an element by cloning it.\r\n * \r\n * Creates a clone of the element and replaces the original with the clone.\r\n * This effectively removes ALL event listeners (both those added via\r\n * addEventListener and inline handlers). The element type is preserved.\r\n * \r\n * **Side Effects**: This is a destructive operation that removes ALL listeners,\r\n * including those you may want to keep. Use with caution.\r\n * \r\n * **Memory Leak Prevention**: Useful when you need to completely reset an\r\n * element's event handlers, especially with third-party libraries that may\r\n * have attached listeners you can't easily remove.\r\n * \r\n * @template T - The element type (preserved in return)\r\n * @param element - The element to strip listeners from (null-safe)\r\n * @returns The cloned element with no listeners, or null\r\n * \r\n * @example\r\n * ```typescript\r\n * const button = document.querySelector('button');\r\n * \r\n * // Add some listeners\r\n * button.addEventListener('click', handler1);\r\n * button.addEventListener('click', handler2);\r\n * button.onclick = handler3;\r\n * \r\n * // Remove ALL listeners\r\n * const cleanButton = stripListeners(button);\r\n * // cleanButton has no listeners, but same content/attributes\r\n * \r\n * // Use case: Reset third-party widget\r\n * const widget = document.querySelector('.third-party-widget');\r\n * const cleanWidget = stripListeners(widget);\r\n * // Now you can attach your own listeners\r\n * \r\n * // Use case: Memory leak cleanup\r\n * const oldElement = document.querySelector('.leaky');\r\n * const fresh = stripListeners(oldElement);\r\n * // Old listeners are garbage collected\r\n * \r\n * // Null-safe\r\n * stripListeners(null); // Returns null\r\n * \r\n * // Note: Element must have a parent\r\n * const orphan = document.createElement('div');\r\n * stripListeners(orphan); // Returns orphan unchanged (no parent)\r\n * ```\r\n */\r\nexport const stripListeners = <T extends Element>(element: T | null): T | null => {\r\n  if (!element || !element.parentNode) return element;\r\n  const copy = element.cloneNode(true) as T;\r\n  element.replaceWith(copy);\r\n  return copy;\r\n};\r\n\r\n/**\r\n * Instantiates a <template> element by ID or reference.\r\n * \r\n * Clones the template's content and optionally applies properties to the\r\n * first element in the fragment. Returns a DocumentFragment that can be\r\n * appended to the DOM.\r\n * \r\n * **Template Pattern**: Templates are great for reusable HTML structures.\r\n * Define once in HTML, instantiate many times in JavaScript.\r\n * \r\n * **Prop Application**: Properties are applied only to the first element child\r\n * in the fragment. For complex templates, use refs or selectors after appending.\r\n * \r\n * @param templateOrSelector - Template element or selector string\r\n * @returns A curried function that accepts props and returns a DocumentFragment\r\n * @throws Error if template is not found or invalid\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <template id=\"card-template\">\r\n * //   <div class=\"card\">\r\n * //     <h3 class=\"title\"></h3>\r\n * //     <p class=\"description\"></p>\r\n * //   </div>\r\n * // </template>\r\n * \r\n * // Instantiate template\r\n * const card = instantiate('#card-template')({\r\n *   class: { featured: true },\r\n *   dataset: { id: '123' }\r\n * });\r\n * \r\n * append(container)(card);\r\n * \r\n * // Multiple instances\r\n * const cards = [\r\n *   { title: 'Card 1', id: '1' },\r\n *   { title: 'Card 2', id: '2' },\r\n *   { title: 'Card 3', id: '3' }\r\n * ].map(data => {\r\n *   const card = instantiate('#card-template')({\r\n *     dataset: { id: data.id }\r\n *   });\r\n *   // Modify after instantiation\r\n *   const title = card.querySelector('.title');\r\n *   if (title) title.textContent = data.title;\r\n *   return card;\r\n * });\r\n * \r\n * // Use with template reference\r\n * const template = document.querySelector('#row-template') as HTMLTemplateElement;\r\n * const row = instantiate(template)({ class: { new: true } });\r\n * \r\n * // No props\r\n * const simple = instantiate('#simple-template')();\r\n * ```\r\n */\r\nexport const instantiate = (templateOrSelector: string | HTMLTemplateElement) => {\r\n  return (rootProps: ElementProps = {}): DocumentFragment => {\r\n    const tpl = typeof templateOrSelector === 'string'\r\n      ? document.querySelector(templateOrSelector) as HTMLTemplateElement\r\n      : templateOrSelector;\r\n\r\n    if (!tpl || !('content' in tpl)) {\r\n      throw new Error(`instantiate: Invalid template '${templateOrSelector}'`);\r\n    }\r\n\r\n    const content = tpl.content.cloneNode(true) as DocumentFragment;\r\n\r\n    // Apply props to the first actual element in the fragment\r\n    if (Object.keys(rootProps).length > 0 && content.firstElementChild) {\r\n      modify(content.firstElementChild as HTMLElement)(rootProps);\r\n    }\r\n\r\n    return content;\r\n  };\r\n};\r\n\r\n/**\r\n * Creates multiple deep clones of a node.\r\n * \r\n * Useful for creating skeleton screens, placeholder lists, or any scenario\r\n * where you need multiple copies of the same element structure.\r\n * \r\n * **Deep Cloning**: Each clone includes all descendants and their attributes,\r\n * but NOT event listeners.\r\n * \r\n * @param element - The node to clone (null-safe)\r\n * @returns A curried function that accepts count and returns array of clones\r\n * \r\n * @example\r\n * ```typescript\r\n * const template = document.querySelector('.card-template');\r\n * \r\n * // Create 5 skeleton cards\r\n * const skeletons = cloneMany(template)(5);\r\n * skeletons.forEach(card => append(container)(card));\r\n * \r\n * // Loading placeholders\r\n * const placeholder = document.querySelector('.placeholder');\r\n * const placeholders = cloneMany(placeholder)(10);\r\n * append(list)(...placeholders);\r\n * \r\n * // Generate list items\r\n * const listItem = el('li')({ class: { item: true } })([]);\r\n * const items = cloneMany(listItem)(20);\r\n * items.forEach((item, i) => {\r\n *   modify(item)({ text: `Item ${i + 1}` });\r\n * });\r\n * append(ul)(...items);\r\n * \r\n * // Null-safe\r\n * cloneMany(null)(5); // Returns []\r\n * ```\r\n */\r\nexport const cloneMany = (element: Node | null) => {\r\n  return (count: number): Node[] => {\r\n    if (!element) return [];\r\n    return Array.from({ length: count }).map(() => element.cloneNode(true));\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 18. GEOMETRY & DIMENSIONS\r\n// =============================================================================\r\n\r\n/**\r\n * Gets the bounding client rectangle of an element.\r\n * \r\n * Returns a DOMRect with position and size information. Safe for null elements\r\n * (returns an empty rect at origin). The rect is relative to the viewport.\r\n * \r\n * **Reflow Considerations**: Reading layout properties like this triggers a reflow.\r\n * Batch reads together and separate from writes for better performance.\r\n * \r\n * @param element - The element to get bounds for (null-safe)\r\n * @returns DOMRect with position and size, or empty rect if null\r\n * \r\n * @example\r\n * ```typescript\r\n * const div = document.querySelector('div');\r\n * const bounds = rect(div);\r\n * \r\n * console.log(bounds.width, bounds.height);\r\n * console.log(bounds.top, bounds.left);\r\n * console.log(bounds.right, bounds.bottom);\r\n * \r\n * // Check if element is in viewport\r\n * const inViewport = (\r\n *   bounds.top >= 0 &&\r\n *   bounds.left >= 0 &&\r\n *   bounds.bottom <= window.innerHeight &&\r\n *   bounds.right <= window.innerWidth\r\n * );\r\n * \r\n * // Calculate center point\r\n * const centerX = bounds.left + bounds.width / 2;\r\n * const centerY = bounds.top + bounds.height / 2;\r\n * \r\n * // Null-safe\r\n * rect(null); // DOMRect(0, 0, 0, 0)\r\n * ```\r\n */\r\nexport const rect = (element: Element | null): DOMRect => {\r\n  return element ? element.getBoundingClientRect() : new DOMRect(0, 0, 0, 0);\r\n};\r\n\r\n/**\r\n * Gets the element's position relative to the document.\r\n * \r\n * Returns the absolute position from the top-left of the document, accounting\r\n * for scroll position. Unlike `getBoundingClientRect()`, this gives document\r\n * coordinates, not viewport coordinates.\r\n * \r\n * **Viewport Calculation**: Adds current scroll position to viewport coordinates.\r\n * \r\n * @param element - The element to get position for (null-safe)\r\n * @returns Object with top and left coordinates, or {0, 0} if null\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.target');\r\n * const pos = offset(element);\r\n * \r\n * console.log('Distance from document top:', pos.top);\r\n * console.log('Distance from document left:', pos.left);\r\n * \r\n * // Scroll to element position\r\n * window.scrollTo({\r\n *   top: pos.top - 100, // 100px offset from top\r\n *   behavior: 'smooth'\r\n * });\r\n * \r\n * // Calculate distance between elements\r\n * const pos1 = offset(element1);\r\n * const pos2 = offset(element2);\r\n * const distance = Math.sqrt(\r\n *   Math.pow(pos2.left - pos1.left, 2) +\r\n *   Math.pow(pos2.top - pos1.top, 2)\r\n * );\r\n * \r\n * // Null-safe\r\n * offset(null); // { top: 0, left: 0 }\r\n * ```\r\n */\r\nexport const offset = (element: HTMLElement | null) => {\r\n  if (!element) return { top: 0, left: 0 };\r\n  const box = element.getBoundingClientRect();\r\n  const doc = document.documentElement;\r\n  return {\r\n    top: box.top + window.scrollY - doc.clientTop,\r\n    left: box.left + window.scrollX - doc.clientLeft\r\n  };\r\n};\r\n\r\n/**\r\n * Checks if an element is visible in the DOM.\r\n * \r\n * An element is considered visible if it has non-zero dimensions (width or height).\r\n * This checks if the element consumes space in the layout, not if it's actually\r\n * in the viewport or has `visibility: visible`.\r\n * \r\n * **Note**: This doesn't check `visibility`, `opacity`, or viewport position.\r\n * It only checks if the element has layout dimensions.\r\n * \r\n * @param element - The element to check (null-safe)\r\n * @returns True if element has non-zero width or height\r\n * \r\n * @example\r\n * ```typescript\r\n * const element = document.querySelector('.target');\r\n * \r\n * if (isVisible(element)) {\r\n *   console.log('Element is rendered');\r\n * }\r\n * \r\n * // Check before animating\r\n * if (isVisible(element)) {\r\n *   element.classList.add('animate');\r\n * }\r\n * \r\n * // Hidden elements return false\r\n * element.style.display = 'none';\r\n * isVisible(element); // false\r\n * \r\n * // Zero-sized elements return false\r\n * element.style.width = '0';\r\n * element.style.height = '0';\r\n * isVisible(element); // false\r\n * \r\n * // Null-safe\r\n * isVisible(null); // false\r\n * ```\r\n */\r\nexport const isVisible = (element: HTMLElement | null): boolean => {\r\n  return !!(element && (element.offsetWidth > 0 || element.offsetHeight > 0));\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 19. SCROLL & FOCUS\r\n// =============================================================================\r\n\r\n/**\r\n * Scrolls an element into view.\r\n * \r\n * Uses the native `scrollIntoView()` API with customizable options. Returns\r\n * the element for chaining. Defaults to smooth scrolling with 'start' alignment.\r\n * \r\n * **Accessibility**: Ensure focus management accompanies scrolling for keyboard users.\r\n * \r\n * **Browser Differences**: Smooth scrolling may not work in all browsers.\r\n * The behavior gracefully degrades to instant scrolling.\r\n * \r\n * @param element - The element to scroll into view (null-safe)\r\n * @returns A curried function that accepts options and returns the element\r\n * \r\n * @example\r\n * ```typescript\r\n * const section = document.querySelector('#section-3');\r\n * \r\n * // Smooth scroll to element\r\n * scrollInto(section)();\r\n * \r\n * // Custom options\r\n * scrollInto(section)({\r\n *   behavior: 'smooth',\r\n *   block: 'center',\r\n *   inline: 'nearest'\r\n * });\r\n * \r\n * // Instant scroll\r\n * scrollInto(section)({ behavior: 'auto' });\r\n * \r\n * // Scroll to bottom of element\r\n * scrollInto(section)({ block: 'end' });\r\n * \r\n * // Navigation with scroll\r\n * on(navLink)('click', (e) => {\r\n *   e.preventDefault();\r\n *   const target = document.querySelector(navLink.hash);\r\n *   scrollInto(target)();\r\n *   focus(target)(); // Also focus for accessibility\r\n * });\r\n * \r\n * // Null-safe\r\n * scrollInto(null)(); // No-op, returns null\r\n * ```\r\n */\r\nexport const scrollInto = (element: Element | null) => {\r\n  return (options: ScrollIntoViewOptions = { behavior: 'smooth', block: 'start' }) => {\r\n    element?.scrollIntoView(options);\r\n    return element;\r\n  };\r\n};\r\n\r\n/**\r\n * Sets focus on an element.\r\n * \r\n * Safely focuses an element with optional focus options. Returns the element\r\n * for chaining. Null-safe.\r\n * \r\n * **Accessibility**: Essential for keyboard navigation and screen readers.\r\n * Always ensure focusable elements have visible focus indicators.\r\n * \r\n * @param element - The element to focus (null-safe)\r\n * @returns A curried function that accepts options and returns the element\r\n * \r\n * @example\r\n * ```typescript\r\n * const input = document.querySelector('input');\r\n * \r\n * // Basic focus\r\n * focus(input)();\r\n * \r\n * // Prevent scroll on focus\r\n * focus(input)({ preventScroll: true });\r\n * \r\n * // Focus after modal opens\r\n * const modal = document.querySelector('.modal');\r\n * modal.classList.add('open');\r\n * const firstInput = modal.querySelector('input');\r\n * focus(firstInput)();\r\n * \r\n * // Focus management in forms\r\n * on(form)('submit', (e) => {\r\n *   e.preventDefault();\r\n *   const firstError = form.querySelector('.error');\r\n *   if (firstError) {\r\n *     scrollInto(firstError)();\r\n *     focus(firstError)();\r\n *   }\r\n * });\r\n * \r\n * // Null-safe\r\n * focus(null)(); // No-op, returns null\r\n * ```\r\n */\r\nexport const focus = (element: HTMLElement | null) => {\r\n  return (options?: FocusOptions) => {\r\n    element?.focus(options);\r\n    return element;\r\n  };\r\n};\r\n\r\n/**\r\n * Removes focus from an element.\r\n * \r\n * Blurs the element, removing keyboard focus. Returns the element for chaining.\r\n * \r\n * **Accessibility**: Use carefully - removing focus can disorient keyboard users.\r\n * Usually better to move focus to another element rather than blur.\r\n * \r\n * @param element - The element to blur (null-safe)\r\n * @returns The element\r\n * \r\n * @example\r\n * ```typescript\r\n * const input = document.querySelector('input');\r\n * \r\n * // Remove focus\r\n * blur(input);\r\n * \r\n * // Close dropdown on blur\r\n * on(dropdown)('blur', () => {\r\n *   dropdown.classList.remove('open');\r\n * });\r\n * \r\n * // Validate on blur\r\n * on(input)('blur', () => {\r\n *   if (!input.value) {\r\n *     input.classList.add('error');\r\n *   }\r\n * });\r\n * \r\n * // Null-safe\r\n * blur(null); // No-op, returns null\r\n * ```\r\n */\r\nexport const blur = (element: HTMLElement | null) => {\r\n  element?.blur();\r\n  return element;\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 20. TIMING UTILS (DEBOUNCE / THROTTLE)\r\n// =============================================================================\r\n\r\n/**\r\n * Debounces a function, delaying execution until after a pause in calls.\r\n * \r\n * Creates a debounced version of the function that delays invoking until after\r\n * `ms` milliseconds have elapsed since the last time it was called. Perfect for\r\n * handling rapid events like typing, resizing, or scrolling.\r\n * \r\n * @template T - The function type to debounce\r\n * @param fn - The function to debounce\r\n * @param ms - The number of milliseconds to delay\r\n * @returns A debounced version of the function\r\n * \r\n * @example\r\n * ```typescript\r\n * // Search as user types (waits for pause)\r\n * const searchInput = document.querySelector('input');\r\n * const performSearch = debounce((query: string) => {\r\n *   console.log('Searching for:', query);\r\n *   // API call here\r\n * }, 300);\r\n * \r\n * on(searchInput)('input', (e) => {\r\n *   performSearch((e.target as HTMLInputElement).value);\r\n * });\r\n * \r\n * // Auto-save after user stops typing\r\n * const autoSave = debounce((content: string) => {\r\n *   localStorage.setItem('draft', content);\r\n *   console.log('Saved!');\r\n * }, 1000);\r\n * \r\n * on(textarea)('input', (e) => {\r\n *   autoSave((e.target as HTMLTextAreaElement).value);\r\n * });\r\n * \r\n * // Window resize handler\r\n * const handleResize = debounce(() => {\r\n *   console.log('Window resized to:', window.innerWidth);\r\n *   // Expensive layout calculations here\r\n * }, 250);\r\n * \r\n * on(window)('resize', handleResize);\r\n * ```\r\n */\r\nexport const debounce = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\r\n  let timeoutId: ReturnType<typeof setTimeout>;\r\n  return (...args: Parameters<T>): void => {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => fn(...args), ms);\r\n  };\r\n};\r\n\r\n/**\r\n * Throttles a function, limiting how often it can be called.\r\n * \r\n * Creates a throttled version that only invokes the function at most once per\r\n * `ms` milliseconds. Unlike debounce, throttle ensures the function is called\r\n * regularly during continuous events. Perfect for scroll, mousemove, or other\r\n * high-frequency events.\r\n * \r\n * @template T - The function type to throttle\r\n * @param fn - The function to throttle\r\n * @param ms - The minimum time between calls in milliseconds\r\n * @returns A throttled version of the function\r\n * \r\n * @example\r\n * ```typescript\r\n * // Scroll progress indicator (updates max once per 16ms)\r\n * const updateScrollProgress = throttle(() => {\r\n *   const scrollPercent = (window.scrollY / document.body.scrollHeight) * 100;\r\n *   progressBar.style.width = `${scrollPercent}%`;\r\n * }, 16); // ~60fps\r\n * \r\n * on(window)('scroll', updateScrollProgress);\r\n * \r\n * // Mouse tracking (limits updates)\r\n * const trackMouse = throttle((e: MouseEvent) => {\r\n *   console.log('Mouse at:', e.clientX, e.clientY);\r\n *   // Update parallax effect, etc.\r\n * }, 50);\r\n * \r\n * on(document)('mousemove', trackMouse);\r\n * \r\n * // Infinite scroll (check max once per 200ms)\r\n * const checkInfiniteScroll = throttle(() => {\r\n *   const scrollBottom = window.scrollY + window.innerHeight;\r\n *   if (scrollBottom >= document.body.scrollHeight - 100) {\r\n *     loadMoreItems();\r\n *   }\r\n * }, 200);\r\n * \r\n * on(window)('scroll', checkInfiniteScroll);\r\n * \r\n * // Difference from debounce:\r\n * // - Debounce: Waits for pause, then executes once\r\n * // - Throttle: Executes regularly during continuous events\r\n * ```\r\n */\r\nexport const throttle = <T extends (...args: any[]) => any>(fn: T, ms: number) => {\r\n  let lastTime = 0;\r\n  return (...args: Parameters<T>): void => {\r\n    const now = Date.now();\r\n    if (now - lastTime >= ms) {\r\n      fn(...args);\r\n      lastTime = now;\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 21. WEB STORAGE (LOCAL & SESSION)\r\n// =============================================================================\r\n\r\n/**\r\n * Factory for creating typed storage wrappers.\r\n * \r\n * Creates storage utilities that automatically handle JSON serialization/deserialization.\r\n * Used internally to create `Local` and `Session` storage objects.\r\n * \r\n * **Generic Type Inference**: Use type parameters for type-safe storage access.\r\n * \r\n * **Schema Validation**: For production apps, consider adding schema validation\r\n * to ensure stored data matches expected types.\r\n * \r\n * **Quota Limits**: Most browsers limit localStorage to ~5-10MB. Check quota\r\n * before storing large amounts of data.\r\n * \r\n * **Error Handling**: Storage operations can fail (quota exceeded, private browsing).\r\n * Wrap in try-catch for production use.\r\n * \r\n * @param provider - The Storage object (localStorage or sessionStorage)\r\n * @returns Object with get, set, remove, and clear methods\r\n */\r\nconst createStorage = (provider: Storage) => ({\r\n  /**\r\n   * Gets a value from storage and parses it.\r\n   * \r\n   * Attempts to parse as JSON. If parsing fails, returns the raw string.\r\n   * Returns null if the key doesn't exist.\r\n   * \r\n   * @template T - The expected type of the stored value\r\n   * @param key - The storage key\r\n   * @returns The parsed value or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Get with type inference\r\n   * interface User { id: number; name: string; }\r\n   * const user = Local.get<User>('user');\r\n   * \r\n   * // Get primitive\r\n   * const count = Local.get<number>('count');\r\n   * \r\n   * // Get with fallback\r\n   * const theme = Local.get<string>('theme') || 'light';\r\n   * ```\r\n   */\r\n  get: <T>(key: string): T | null => {\r\n    const val = provider.getItem(key);\r\n    if (!val) return null;\r\n    try { return JSON.parse(val) as T; }\r\n    catch { return val as unknown as T; }\r\n  },\r\n\r\n  /**\r\n   * Sets a value in storage (auto-stringifies objects).\r\n   * \r\n   * Objects are JSON stringified. Primitives are converted to strings.\r\n   * \r\n   * @param key - The storage key\r\n   * @returns A curried function that accepts the value\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Store object\r\n   * Local.set('user')({ id: 1, name: 'John' });\r\n   * \r\n   * // Store primitive\r\n   * Local.set('count')(42);\r\n   * Local.set('theme')('dark');\r\n   * \r\n   * // Error handling\r\n   * try {\r\n   *   Local.set('largeData')(hugeObject);\r\n   * } catch (e) {\r\n   *   console.error('Storage quota exceeded');\r\n   * }\r\n   * ```\r\n   */\r\n  set: (key: string) => (value: any): void => {\r\n    const val = typeof value === 'object' ? JSON.stringify(value) : String(value);\r\n    provider.setItem(key, val);\r\n  },\r\n\r\n  /**\r\n   * Removes a key from storage.\r\n   * \r\n   * @param key - The storage key to remove\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * Local.remove('user');\r\n   * Session.remove('tempData');\r\n   * ```\r\n   */\r\n  remove: (key: string) => provider.removeItem(key),\r\n\r\n  /**\r\n   * Clears all storage.\r\n   * \r\n   * **Warning**: This removes ALL keys from the storage, not just those\r\n   * created by your app. Use with caution.\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Clear all localStorage\r\n   * Local.clear();\r\n   * \r\n   * // Clear session storage\r\n   * Session.clear();\r\n   * ```\r\n   */\r\n  clear: () => provider.clear()\r\n});\r\n\r\n/**\r\n * localStorage wrapper with automatic JSON serialization.\r\n * \r\n * Provides type-safe access to localStorage with automatic parsing/stringification.\r\n * Data persists across browser sessions until explicitly cleared.\r\n * \r\n * **Quota Limits**: ~5-10MB in most browsers. Check `navigator.storage.estimate()`\r\n * for available quota.\r\n * \r\n * **Error Handling**: Can throw QuotaExceededError. Wrap in try-catch for production.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Store user data\r\n * interface User { id: number; name: string; email: string; }\r\n * const user: User = { id: 1, name: 'John', email: 'john@example.com' };\r\n * Local.set('user')(user);\r\n * \r\n * // Retrieve user data\r\n * const savedUser = Local.get<User>('user');\r\n * if (savedUser) {\r\n *   console.log(savedUser.name);\r\n * }\r\n * \r\n * // Store app settings\r\n * Local.set('settings')({\r\n *   theme: 'dark',\r\n *   language: 'en',\r\n *   notifications: true\r\n * });\r\n * \r\n * // Remove item\r\n * Local.remove('tempData');\r\n * \r\n * // Clear all\r\n * Local.clear();\r\n * ```\r\n */\r\nexport const Local = createStorage(window.localStorage);\r\n/**\r\n * sessionStorage wrapper with automatic JSON serialization.\r\n * \r\n * Provides type-safe access to sessionStorage. Data persists only for the\r\n * current browser session (tab). Cleared when the tab is closed.\r\n * \r\n * **Use Cases**: Temporary data, form drafts, wizard state, tab-specific settings.\r\n * \r\n * **Quota Limits**: Similar to localStorage (~5-10MB).\r\n * \r\n * @example\r\n * ```typescript\r\n * // Store temporary form data\r\n * Session.set('formDraft')({\r\n *   name: 'John',\r\n *   email: 'john@example.com',\r\n *   message: 'Hello...'\r\n * });\r\n * \r\n * // Retrieve on page reload\r\n * const draft = Session.get('formDraft');\r\n * if (draft) {\r\n *   Form.populate(form)(draft);\r\n * }\r\n * \r\n * // Multi-step wizard\r\n * Session.set('wizardStep')(2);\r\n * Session.set('wizardData')({ step1: {...}, step2: {...} });\r\n * \r\n * // Clear on completion\r\n * Session.remove('wizardStep');\r\n * Session.remove('wizardData');\r\n * ```\r\n */\r\nexport const Session = createStorage(window.sessionStorage);\r\n\r\n\r\n// =============================================================================\r\n// 22. COOKIES\r\n// =============================================================================\r\n\r\n/**\r\n * Utilities for working with browser cookies.\r\n * \r\n * Provides a simple API for getting, setting, and removing cookies with\r\n * automatic URL encoding/decoding.\r\n * \r\n * **Security**: Cookies are sent with every request to the domain. Use `secure`\r\n * and `httpOnly` flags for sensitive data. Consider using localStorage for\r\n * client-side only data.\r\n * \r\n * **Size Limits**: Cookies are limited to ~4KB per cookie, ~20 cookies per domain.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Set a cookie\r\n * Cookie.set('theme')('dark')({ days: 30 });\r\n * \r\n * // Get a cookie\r\n * const theme = Cookie.get('theme'); // \"dark\"\r\n * \r\n * // Remove a cookie\r\n * Cookie.remove('theme');\r\n * ```\r\n */\r\nexport const Cookie = {\r\n  /**\r\n   * Gets a cookie value by name.\r\n   * \r\n   * Returns the decoded cookie value or null if not found.\r\n   * \r\n   * @param name - The cookie name\r\n   * @returns The decoded cookie value or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const token = Cookie.get('auth_token');\r\n   * if (token) {\r\n   *   // User is authenticated\r\n   * }\r\n   * \r\n   * const userId = Cookie.get('user_id');\r\n   * const preferences = Cookie.get('prefs');\r\n   * ```\r\n   */\r\n  get: (name: string): string | null => {\r\n    const v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');\r\n    return v ? decodeURIComponent(v[2]) : null;\r\n  },\r\n\r\n  /**\r\n   * Sets a cookie with optional expiration and security settings.\r\n   * \r\n   * **Security Options**:\r\n   * - `secure`: Only send over HTTPS (recommended for production)\r\n   * - `path`: Limit cookie to specific path (defaults to '/')\r\n   * - `days`: Expiration in days (omit for session cookie)\r\n   * \r\n   * @param name - The cookie name\r\n   * @returns A curried function that accepts value and options\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Session cookie (expires when browser closes)\r\n   * Cookie.set('session_id')('abc123')();\r\n   * \r\n   * // Persistent cookie (7 days)\r\n   * Cookie.set('theme')('dark')({ days: 7 });\r\n   * \r\n   * // Secure cookie (HTTPS only)\r\n   * Cookie.set('auth_token')('secret')({ days: 1, secure: true });\r\n   * \r\n   * // Path-specific cookie\r\n   * Cookie.set('admin_pref')('value')({ path: '/admin', days: 30 });\r\n   * \r\n   * // Remember me (1 year)\r\n   * Cookie.set('remember')('true')({ days: 365 });\r\n   * ```\r\n   */\r\n  set: (name: string) => (value: string) => (options: { days?: number, path?: string, secure?: boolean } = {}) => {\r\n    let d = new Date();\r\n    d.setTime(d.getTime() + 24 * 60 * 60 * 1000 * (options.days || 0));\r\n    document.cookie = `${name}=${encodeURIComponent(value)}`\r\n      + `;path=${options.path || '/'}`\r\n      + (options.days ? `;expires=${d.toUTCString()}` : '')\r\n      + (options.secure ? ';secure' : '');\r\n  },\r\n\r\n  /**\r\n   * Removes a cookie by setting its expiration to the past.\r\n   * \r\n   * @param name - The cookie name to remove\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Logout: remove auth cookie\r\n   * Cookie.remove('auth_token');\r\n   * \r\n   * // Clear preferences\r\n   * Cookie.remove('theme');\r\n   * Cookie.remove('language');\r\n   * ```\r\n   */\r\n  remove: (name: string) => {\r\n    Cookie.set(name)('')({ days: -1 });\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 23. NETWORK (FETCH WRAPPER)\r\n// =============================================================================\r\n\r\n/**\r\n * HTTP utilities - A lightweight, functional wrapper around the Fetch API.\r\n * \r\n * Provides type-safe HTTP methods with automatic JSON handling, error checking,\r\n * and a curried API for flexible composition.\r\n * \r\n * **Error Handling**: All methods throw on non-2xx responses. Wrap in try-catch\r\n * for production use.\r\n * \r\n * **CORS Considerations**: \r\n * - Credentials are not included by default. Add `credentials: 'include'` to headers for cookies.\r\n * - Preflight requests (OPTIONS) are handled automatically by the browser.\r\n * - Server must set appropriate CORS headers (Access-Control-Allow-Origin, etc.).\r\n * \r\n * **Type Safety**: Use generic type parameters for response typing.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define response types\r\n * interface User { id: number; name: string; email: string; }\r\n * interface ApiError { error: string; code: number; }\r\n * \r\n * // GET with type safety\r\n * try {\r\n *   const user = await Http.get<User>('/api/user/123');\r\n *   console.log(user.name);\r\n * } catch (error) {\r\n *   console.error('Failed to fetch user:', error);\r\n * }\r\n * \r\n * // POST with curried API\r\n * const response = await Http.post('/api/users')\r\n *   ({ name: 'John', email: 'john@example.com' })\r\n *   ({ 'Authorization': 'Bearer token123' });\r\n * \r\n * // Error handling with typed responses\r\n * try {\r\n *   const data = await Http.get<User>('/api/user');\r\n * } catch (err) {\r\n *   if (err instanceof Error) {\r\n *     // Parse error message for status code\r\n *     if (err.message.includes('404')) {\r\n *       console.log('User not found');\r\n *     }\r\n *   }\r\n * }\r\n * \r\n * // Retry pattern\r\n * async function fetchWithRetry<T>(\r\n *   url: string,\r\n *   maxRetries = 3,\r\n *   delay = 1000\r\n * ): Promise<T> {\r\n *   for (let i = 0; i < maxRetries; i++) {\r\n *     try {\r\n *       return await Http.get<T>(url);\r\n *     } catch (error) {\r\n *       if (i === maxRetries - 1) throw error;\r\n *       await wait(delay * (i + 1)); // Exponential backoff\r\n *     }\r\n *   }\r\n *   throw new Error('Max retries exceeded');\r\n * }\r\n * \r\n * // CORS with credentials\r\n * const data = await Http.get<User>(\r\n *   'https://api.example.com/user',\r\n *   { 'credentials': 'include' } as any\r\n * );\r\n * ```\r\n */\r\n\r\n\r\n\r\n// =============================================================================\r\n// 24. SERVICE WORKER\r\n// =============================================================================\r\n\r\n/**\r\n * Service Worker utilities for Progressive Web Apps (PWAs).\r\n * \r\n * Provides helpers for registering service workers, handling updates, and\r\n * communicating with the service worker.\r\n * \r\n * **Browser Support**: Check for 'serviceWorker' in navigator before using.\r\n * \r\n * **Lifecycle Events**:\r\n * 1. **Installing**: Service worker is being installed\r\n * 2. **Installed/Waiting**: New version is waiting to activate\r\n * 3. **Activating**: Service worker is taking control\r\n * 4. **Activated**: Service worker is controlling the page\r\n * \r\n * **Update Strategy**: Service workers update when:\r\n * - User navigates to a page in scope\r\n * - An event like push/sync occurs\r\n * - You call `registration.update()`\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic registration\r\n * const registration = await SW.register('/sw.js');\r\n * if (registration) {\r\n *   console.log('Service worker registered');\r\n * }\r\n * \r\n * // Handle updates\r\n * const reg = await SW.register('/sw.js');\r\n * if (reg) {\r\n *   reg.addEventListener('updatefound', () => {\r\n *     const newWorker = reg.installing;\r\n *     newWorker?.addEventListener('statechange', () => {\r\n *       if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\r\n *         // New version available\r\n *         if (confirm('New version available! Reload?')) {\r\n *           window.location.reload();\r\n *         }\r\n *       }\r\n *     });\r\n *   });\r\n * }\r\n * \r\n * // Send message to service worker\r\n * SW.post({ type: 'CACHE_CLEAR' });\r\n * SW.post({ type: 'SKIP_WAITING' });\r\n * ```\r\n */\r\nexport const SW = {\r\n  /**\r\n   * Registers a service worker script.\r\n   * \r\n   * **Registration Scope**: By default, the scope is the directory containing\r\n   * the service worker file. You can override this in registration options.\r\n   * \r\n   * **Update Check**: The browser checks for updates to the service worker\r\n   * script on navigation. Byte-for-byte comparison is used.\r\n   * \r\n   * **Error Handling**: Returns null if registration fails or if service workers\r\n   * are not supported. Check the return value before using.\r\n   * \r\n   * @param scriptPath - Path to the service worker script (e.g., '/sw.js')\r\n   * @param options - Optional registration options\r\n   * @returns Promise resolving to ServiceWorkerRegistration or null\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic registration\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   console.log('SW registered with scope:', reg.scope);\r\n   * }\r\n   * \r\n   * // Custom scope\r\n   * const reg = await SW.register('/sw.js', { scope: '/app/' });\r\n   * \r\n   * // Check for updates manually\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   // Check for updates every hour\r\n   *   setInterval(() => reg.update(), 60 * 60 * 1000);\r\n   * }\r\n   * \r\n   * // Listen for lifecycle events\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   // New service worker installing\r\n   *   reg.addEventListener('updatefound', () => {\r\n   *     const installing = reg.installing;\r\n   *     console.log('New service worker installing...');\r\n   *     \r\n   *     installing?.addEventListener('statechange', () => {\r\n   *       console.log('State changed to:', installing.state);\r\n   *       // States: installing, installed, activating, activated, redundant\r\n   *     });\r\n   *   });\r\n   * }\r\n   * \r\n   * // Skip waiting and activate immediately\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg?.waiting) {\r\n   *   // Tell waiting SW to skip waiting\r\n   *   SW.post({ type: 'SKIP_WAITING' });\r\n   * }\r\n   * \r\n   * // Unregister service worker\r\n   * const reg = await SW.register('/sw.js');\r\n   * if (reg) {\r\n   *   await reg.unregister();\r\n   *   console.log('Service worker unregistered');\r\n   * }\r\n   * ```\r\n   */\r\n  register: async (\r\n    scriptPath: string,\r\n    options?: RegistrationOptions\r\n  ): Promise<ServiceWorkerRegistration | null> => {\r\n    if ('serviceWorker' in navigator) {\r\n      try {\r\n        const reg = await navigator.serviceWorker.register(scriptPath, options);\r\n        return reg;\r\n      } catch (e) {\r\n        //console.error('SW Registration Failed:', e);\r\n        return null;\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n\r\n  /**\r\n   * Posts a message to the active service worker.\r\n   * \r\n   * **Controller**: The \"controller\" is the service worker that controls the\r\n   * current page. It's null if no service worker is active.\r\n   * \r\n   * **Message Format**: Use a consistent message format with a `type` field\r\n   * for routing in the service worker.\r\n   * \r\n   * **Response Handling**: To receive responses, listen for 'message' events\r\n   * on navigator.serviceWorker.\r\n   * \r\n   * @param message - The message to send (typically an object with a 'type' field)\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Clear cache\r\n   * SW.post({ type: 'CACHE_CLEAR' });\r\n   * \r\n   * // Skip waiting (activate new service worker immediately)\r\n   * SW.post({ type: 'SKIP_WAITING' });\r\n   * \r\n   * // Custom message with data\r\n   * SW.post({\r\n   *   type: 'CACHE_URLS',\r\n   *   urls: ['/page1.html', '/page2.html']\r\n   * });\r\n   * \r\n   * // Two-way communication\r\n   * // Send message\r\n   * SW.post({ type: 'GET_CACHE_SIZE' });\r\n   * \r\n   * // Listen for response\r\n   * navigator.serviceWorker.addEventListener('message', (event) => {\r\n   *   if (event.data.type === 'CACHE_SIZE') {\r\n   *     console.log('Cache size:', event.data.size);\r\n   *   }\r\n * });\r\n   * \r\n   * // Sync data when online\r\n   * SW.post({\r\n   *   type: 'SYNC_DATA',\r\n   *   data: { userId: 123, updates: [...] }\r\n   * });\r\n   * \r\n   * // Check if controller exists before posting\r\n   * if (navigator.serviceWorker?.controller) {\r\n   *   SW.post({ type: 'PING' });\r\n   * } else {\r\n   *   console.log('No active service worker');\r\n   * }\r\n   * ```\r\n   */\r\n  post: (message: any) => {\r\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\r\n      navigator.serviceWorker.controller.postMessage(message);\r\n    }\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 25. EVENT LIFECYCLE & CLEANUP (LISTENER GROUPS)\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a manager for grouping multiple event listeners and subscriptions.\r\n * \r\n * Essential for preventing memory leaks in Single Page Applications (SPAs)\r\n * and component-based architectures. Allows batch cleanup of all listeners\r\n * when a component unmounts or a feature is disabled.\r\n * \r\n * **Use Cases**:\r\n * - React useEffect cleanup\r\n * - Vue onUnmounted hooks\r\n * - Modal/dialog lifecycle management\r\n * - Feature toggle cleanup\r\n * - Page navigation cleanup\r\n * \r\n * **Memory Leak Prevention**: Always call `clear()` when the component/feature\r\n * is destroyed to prevent memory leaks from orphaned event listeners.\r\n * \r\n * @returns Object with `add` and `clear` methods for managing subscriptions\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic usage\r\n * const group = createListenerGroup();\r\n * \r\n * // Add multiple listeners\r\n * group.add(on(button)('click', handleClick));\r\n * group.add(on(window)('resize', handleResize));\r\n * group.add(on(document)('keydown', handleKeydown));\r\n * \r\n * // Later: cleanup all at once\r\n * group.clear(); // Removes all 3 listeners\r\n * \r\n * // React integration\r\n * function MyComponent() {\r\n *   useEffect(() => {\r\n *     const listeners = createListenerGroup();\r\n *     \r\n *     listeners.add(on(button)('click', handleClick));\r\n *     listeners.add(on(window)('scroll', handleScroll));\r\n *     listeners.add(Data.bind(element)('count', handleCountChange));\r\n *     \r\n *     // Cleanup on unmount\r\n *     return () => listeners.clear();\r\n *   }, []);\r\n * }\r\n * \r\n * // Vue 3 Composition API\r\n * import { onUnmounted } from 'vue';\r\n * \r\n * export default {\r\n *   setup() {\r\n *     const listeners = createListenerGroup();\r\n *     \r\n *     listeners.add(on(button.value)('click', handleClick));\r\n *     listeners.add(on(window)('resize', handleResize));\r\n *     \r\n *     onUnmounted(() => {\r\n *       listeners.clear();\r\n *     });\r\n *   }\r\n * }\r\n * \r\n * // Modal lifecycle\r\n * class Modal {\r\n *   private listeners = createListenerGroup();\r\n *   \r\n *   open() {\r\n *     this.listeners.add(on(this.closeBtn)('click', () => this.close()));\r\n *     this.listeners.add(on(this.overlay)('click', () => this.close()));\r\n *     this.listeners.add(on(document)('keydown', (e) => {\r\n *       if (e.key === 'Escape') this.close();\r\n *     }));\r\n *   }\r\n *   \r\n *   close() {\r\n *     this.listeners.clear(); // Clean up all listeners\r\n *     remove(this.element);\r\n *   }\r\n * }\r\n * \r\n * // Feature toggle\r\n * const featureListeners = createListenerGroup();\r\n * \r\n * function enableFeature() {\r\n *   featureListeners.add(on(button)('click', featureHandler));\r\n *   featureListeners.add(watchClass(element)('active', handleActiveChange));\r\n * }\r\n * \r\n * function disableFeature() {\r\n *   featureListeners.clear(); // Remove all feature listeners\r\n * }\r\n * \r\n * // Page navigation cleanup\r\n * let currentPageListeners = createListenerGroup();\r\n * \r\n * function navigateTo(page: string) {\r\n *   // Clean up previous page\r\n *   currentPageListeners.clear();\r\n *   \r\n *   // Set up new page\r\n *   currentPageListeners = createListenerGroup();\r\n *   currentPageListeners.add(on(pageElement)('click', handlePageClick));\r\n *   // ... more listeners\r\n * }\r\n * \r\n * // Combining with other cleanup\r\n * const group = createListenerGroup();\r\n * \r\n * // Add regular listeners\r\n * group.add(on(button)('click', handler));\r\n * \r\n * // Add custom cleanup logic\r\n * group.add(() => {\r\n *   console.log('Custom cleanup');\r\n *   clearInterval(intervalId);\r\n *   cancelAnimationFrame(rafId);\r\n * });\r\n * \r\n * group.clear(); // Runs all cleanup functions\r\n * ```\r\n */\r\nexport const createListenerGroup = () => {\r\n  const unsubs: Unsubscribe[] = [];\r\n  return {\r\n    /**\r\n     * Registers a cleanup function or unsubscribe callback.\r\n     * \r\n     * @param fn - The cleanup function to register\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * const group = createListenerGroup();\r\n     * \r\n     * // Add event listener cleanup\r\n     * group.add(on(button)('click', handler));\r\n     * \r\n     * // Add observer cleanup\r\n     * group.add(watchClass(element)('active', callback));\r\n     * \r\n     * // Add custom cleanup\r\n     * group.add(() => {\r\n     *   clearTimeout(timeoutId);\r\n     *   worker.terminate();\r\n     * });\r\n     * ```\r\n     */\r\n    add: (fn: Unsubscribe) => {\r\n      unsubs.push(fn);\r\n    },\r\n\r\n    /**\r\n     * Executes all registered cleanup functions and clears the list.\r\n     * \r\n     * **Order**: Cleanup functions are called in the order they were added.\r\n     * \r\n     * **Idempotent**: Safe to call multiple times - subsequent calls do nothing.\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * const group = createListenerGroup();\r\n     * group.add(on(btn)('click', handler));\r\n     * group.add(on(window)('resize', resizeHandler));\r\n     * \r\n     * group.clear(); // Removes both listeners\r\n     * group.clear(); // Safe to call again - does nothing\r\n     * ```\r\n     */\r\n    clear: () => {\r\n      unsubs.forEach(fn => fn());\r\n      unsubs.length = 0;\r\n    }\r\n  };\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 26. SIGNALS & CONTROLLERS (ABORTCONTROLLER)\r\n// =============================================================================\r\n\r\n/**\r\n * AbortController and AbortSignal utilities for cancellable operations.\r\n * \r\n * Provides helpers for creating abort signals, timeout signals, and wrapping\r\n * promises with cancellation support. Essential for managing async operations\r\n * that may need to be cancelled (fetch requests, animations, long computations).\r\n * \r\n * **Use Cases**:\r\n * - Cancel fetch requests when component unmounts\r\n * - Timeout long-running operations\r\n * - Cancel animations or intervals\r\n * - Abort expensive computations\r\n * \r\n * **Signal Composition**: Multiple operations can share the same signal,\r\n * allowing batch cancellation.\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic cancellation\r\n * const { signal, abort } = Signal.create();\r\n * fetch('/api/data', { signal });\r\n * // Later: abort the request\r\n * abort();\r\n * \r\n * // Timeout pattern\r\n * const timeoutSignal = Signal.timeout(5000);\r\n * try {\r\n *   const data = await fetch('/api/slow', { signal: timeoutSignal });\r\n * } catch (error) {\r\n *   if (error.name === 'AbortError') {\r\n *     console.log('Request timed out');\r\n *   }\r\n * }\r\n * \r\n * // Wrap non-fetch promises\r\n * const { signal, abort } = Signal.create();\r\n * const result = await Signal.wrap(\r\n *   longRunningComputation(),\r\n *   signal\r\n * );\r\n * ```\r\n */\r\nexport const Signal = {\r\n  /**\r\n   * Creates a new AbortController and returns its signal and abort function.\r\n   * \r\n   * **Pattern**: Destructure to get both signal and abort function.\r\n   * \r\n   * **Cleanup**: Call abort() to cancel all operations using this signal.\r\n   * \r\n   * @returns Object with `signal` (AbortSignal) and `abort` function\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic usage\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * fetch('/api/users', { signal })\r\n   *   .then(res => res.json())\r\n   *   .catch(err => {\r\n   *     if (err.name === 'AbortError') {\r\n   *       console.log('Request was cancelled');\r\n   *     }\r\n   *   });\r\n   * \r\n   * // Cancel the request\r\n   * abort();\r\n   * \r\n   * // React component cleanup\r\n   * function UserList() {\r\n   *   useEffect(() => {\r\n   *     const { signal, abort } = Signal.create();\r\n   *     \r\n   *     fetch('/api/users', { signal })\r\n   *       .then(res => res.json())\r\n   *       .then(setUsers);\r\n   *     \r\n   *     return () => abort(); // Cancel on unmount\r\n   *   }, []);\r\n   * }\r\n   * \r\n   * // Multiple operations with same signal\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * Promise.all([\r\n   *   fetch('/api/users', { signal }),\r\n   *   fetch('/api/posts', { signal }),\r\n   *   fetch('/api/comments', { signal })\r\n   * ]);\r\n   * \r\n   * // Abort all three requests at once\r\n   * abort();\r\n   * \r\n   * // Conditional abort\r\n   * const { signal, abort } = Signal.create();\r\n   * const button = document.querySelector('button');\r\n   * \r\n   * on(button)('click', () => {\r\n   *   fetch('/api/data', { signal });\r\n   * });\r\n   * \r\n   * on(button)('click', () => {\r\n   *   abort(); // Cancel if clicked again\r\n   * });\r\n   * ```\r\n   */\r\n  create: () => {\r\n    const c = new AbortController();\r\n    return { signal: c.signal, abort: () => c.abort() };\r\n  },\r\n\r\n  /**\r\n   * Creates an AbortSignal that automatically aborts after a timeout.\r\n   * \r\n   * **Browser Support**: Uses native `AbortSignal.timeout()` if available,\r\n   * falls back to manual implementation for older browsers.\r\n   * \r\n   * **Use Case**: Prevent operations from running indefinitely.\r\n   * \r\n   * @param ms - Timeout in milliseconds\r\n   * @returns An AbortSignal that aborts after the specified time\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Timeout fetch request after 5 seconds\r\n   * try {\r\n   *   const response = await fetch('/api/data', {\r\n   *     signal: Signal.timeout(5000)\r\n   *   });\r\n   *   const data = await response.json();\r\n   * } catch (error) {\r\n   *   if (error.name === 'AbortError') {\r\n   *     console.log('Request timed out after 5 seconds');\r\n   *   }\r\n   * }\r\n   * \r\n   * // Different timeouts for different endpoints\r\n   * const fastEndpoint = fetch('/api/fast', {\r\n   *   signal: Signal.timeout(1000)\r\n   * });\r\n   * \r\n   * const slowEndpoint = fetch('/api/slow', {\r\n   *   signal: Signal.timeout(10000)\r\n   * });\r\n   * \r\n   * // Timeout with fallback\r\n   * async function fetchWithFallback(url: string) {\r\n   *   try {\r\n   *     return await fetch(url, { signal: Signal.timeout(3000) });\r\n   *   } catch (error) {\r\n   *     if (error.name === 'AbortError') {\r\n   *       // Return cached data or default\r\n   *       return getCachedData(url);\r\n   *     }\r\n   *     throw error;\r\n   *   }\r\n   * }\r\n   * \r\n   * // Timeout for non-fetch operations\r\n   * const result = await Signal.wrap(\r\n   *   expensiveComputation(),\r\n   *   Signal.timeout(5000)\r\n   * );\r\n   * ```\r\n   */\r\n  timeout: (ms: number): AbortSignal => {\r\n    // Use native if available, fallback for older browsers\r\n    if ('timeout' in AbortSignal) return AbortSignal.timeout(ms);\r\n    const c = new AbortController();\r\n    setTimeout(() => c.abort(), ms);\r\n    return c.signal;\r\n  },\r\n\r\n  /**\r\n   * Wraps a Promise to make it abortable via an AbortSignal.\r\n   * \r\n   * **Behavior**: If the signal aborts, the promise rejects with AbortError.\r\n   * The original promise continues running but its result is ignored.\r\n   * \r\n   * **Error Handling**: Always check for `error.name === 'AbortError'` to\r\n   * distinguish cancellation from other errors.\r\n   * \r\n   * @template T - The promise result type\r\n   * @param promise - The promise to wrap\r\n   * @param signal - Optional AbortSignal to control cancellation\r\n   * @returns The wrapped promise that can be cancelled\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Wrap async function\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * async function processData() {\r\n   *   await wait(1000);\r\n   *   return { result: 'done' };\r\n   * }\r\n   * \r\n   * const result = await Signal.wrap(processData(), signal);\r\n   * \r\n   * // Cancel before completion\r\n   * setTimeout(() => abort(), 500);\r\n   * \r\n   * // Timeout pattern\r\n   * try {\r\n   *   const result = await Signal.wrap(\r\n   *     longComputation(),\r\n   *     Signal.timeout(5000)\r\n   *   );\r\n   * } catch (error) {\r\n   *   if (error.name === 'AbortError') {\r\n   *     console.log('Computation timed out');\r\n   *   }\r\n * }\r\n   * \r\n   * // Animation loop with cancellation\r\n   * async function animateWithCancel(signal: AbortSignal) {\r\n   *   for (let i = 0; i < 100; i++) {\r\n   *     if (signal.aborted) break;\r\n   *     await Signal.wrap(nextFrame(), signal);\r\n   *     element.style.opacity = String(i / 100);\r\n   *   }\r\n   * }\r\n   * \r\n   * const { signal, abort } = Signal.create();\r\n   * animateWithCancel(signal);\r\n   * // Later: abort()\r\n   * \r\n   * // Race with timeout\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * try {\r\n   *   const result = await Promise.race([\r\n   *     Signal.wrap(fetchData(), signal),\r\n   *     wait(5000).then(() => { throw new Error('Timeout'); })\r\n   *   ]);\r\n   * } catch (error) {\r\n   *   console.error('Failed or timed out:', error);\r\n   * }\r\n   * \r\n   * // Cleanup on abort\r\n   * const { signal, abort } = Signal.create();\r\n   * \r\n   * signal.addEventListener('abort', () => {\r\n   *   console.log('Operation cancelled, cleaning up...');\r\n   *   cleanup();\r\n   * });\r\n   * \r\n   * await Signal.wrap(operation(), signal);\r\n   * ```\r\n   */\r\n  wrap: <T>(promise: Promise<T>, signal?: AbortSignal): Promise<T> => {\r\n    if (!signal) return promise;\r\n    if (signal.aborted) return Promise.reject(new DOMException('Aborted', 'AbortError'));\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const abortHandler = () => {\r\n        reject(new DOMException('Aborted', 'AbortError'));\r\n        signal.removeEventListener('abort', abortHandler);\r\n      };\r\n\r\n      signal.addEventListener('abort', abortHandler);\r\n\r\n      promise.then(\r\n        val => { signal.removeEventListener('abort', abortHandler); resolve(val); },\r\n        err => { signal.removeEventListener('abort', abortHandler); reject(err); }\r\n      );\r\n    });\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 27. APP-WIDE PUB/SUB (TYPED EVENT BUS)\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a strongly-typed event bus for application-wide communication.\r\n * \r\n * Provides a type-safe pub/sub system using native EventTarget under the hood.\r\n * Perfect for decoupling components without the overhead of heavy state\r\n * management libraries.\r\n * \r\n * **Type Safety**: Define your event map as a type parameter for full\r\n * IntelliSense support and compile-time checking.\r\n * \r\n * **vs Native Events**: Unlike DOM events, this provides:\r\n * - Type-safe event names and payloads\r\n * - No DOM dependency (works anywhere)\r\n * - Simpler API focused on pub/sub patterns\r\n * \r\n * **Performance**: Uses native EventTarget, so it's as fast as DOM events.\r\n * \r\n * **Memory**: Remember to unsubscribe when components unmount to prevent leaks.\r\n * \r\n * @template Events - Event map type: `{ eventName: payloadType }`\r\n * @returns Object with `on`, `emit`, and `once` methods\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define event types\r\n * interface AppEvents {\r\n *   'user:login': { id: number; name: string; };\r\n *   'user:logout': void;\r\n *   'cart:add': { productId: string; quantity: number; };\r\n *   'cart:remove': { productId: string; };\r\n *   'notification:show': { message: string; type: 'success' | 'error'; };\r\n * }\r\n * \r\n * // Create typed bus\r\n * const bus = createBus<AppEvents>();\r\n * \r\n * // Subscribe with full type safety\r\n * const unsubscribe = bus.on('user:login', (data) => {\r\n *   console.log(`User ${data.name} logged in`); // data is typed!\r\n *   updateUI(data.id);\r\n * });\r\n * \r\n * // Emit events\r\n * bus.emit('user:login', { id: 123, name: 'John' });\r\n * bus.emit('user:logout'); // void events don't need data\r\n * \r\n * // Cleanup\r\n * unsubscribe();\r\n * \r\n * // One-time listeners\r\n * bus.once('user:login', (data) => {\r\n *   console.log('First login:', data.name);\r\n *   // Automatically unsubscribes after first call\r\n * });\r\n * \r\n * // Cross-component communication\r\n * // Component A\r\n * bus.on('cart:add', ({ productId, quantity }) => {\r\n *   updateCartUI(productId, quantity);\r\n *   showNotification(`Added ${quantity} items`);\r\n * });\r\n * \r\n * // Component B\r\n * function addToCart(productId: string, qty: number) {\r\n *   bus.emit('cart:add', { productId, quantity: qty });\r\n * }\r\n * \r\n * // React integration\r\n * function CartBadge() {\r\n *   const [count, setCount] = useState(0);\r\n *   \r\n *   useEffect(() => {\r\n *     const unsub1 = bus.on('cart:add', ({ quantity }) => {\r\n *       setCount(c => c + quantity);\r\n *     });\r\n *     \r\n *     const unsub2 = bus.on('cart:remove', () => {\r\n *       setCount(c => c - 1);\r\n *     });\r\n *     \r\n *     return () => {\r\n *       unsub1();\r\n *       unsub2();\r\n *     };\r\n *   }, []);\r\n *   \r\n *   return <span>{count}</span>;\r\n * }\r\n * \r\n * // Global notification system\r\n * const notifications = createBus<{\r\n *   show: { message: string; type: 'info' | 'success' | 'error'; };\r\n *   hide: void;\r\n * }>();\r\n * \r\n * notifications.on('show', ({ message, type }) => {\r\n *   const toast = createToast(message, type);\r\n *   append(document.body)(toast);\r\n * });\r\n * \r\n * // Anywhere in your app\r\n * notifications.emit('show', {\r\n *   message: 'Saved successfully!',\r\n *   type: 'success'\r\n * });\r\n * ```\r\n */\r\nexport const createBus = <Events extends Record<string, any>>() => {\r\n  const target = new EventTarget();\r\n\r\n  return {\r\n    /**\r\n     * Subscribes to an event.\r\n     * \r\n     * **Type Safety**: Event name and data are fully typed based on the Events map.\r\n     * \r\n     * **Cleanup**: Always store and call the returned unsubscribe function to\r\n     * prevent memory leaks.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to listen for\r\n     * @param handler - Callback function receiving typed event data\r\n     * @returns Unsubscribe function to remove the listener\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'data:updated': { id: number; value: string; };\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Subscribe\r\n     * const unsub = bus.on('data:updated', (data) => {\r\n     *   console.log(`Data ${data.id} = ${data.value}`);\r\n     * });\r\n     * \r\n     * // Unsubscribe\r\n     * unsub();\r\n     * \r\n     * // Multiple subscribers\r\n     * const unsub1 = bus.on('data:updated', updateUI);\r\n     * const unsub2 = bus.on('data:updated', logChange);\r\n     * const unsub3 = bus.on('data:updated', syncToServer);\r\n     * \r\n     * // Cleanup all\r\n     * [unsub1, unsub2, unsub3].forEach(fn => fn());\r\n     * ```\r\n     */\r\n    on: <K extends keyof Events & string>(\r\n      event: K,\r\n      handler: (data: Events[K]) => void\r\n    ): Unsubscribe => {\r\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\r\n      target.addEventListener(event, listener);\r\n      return () => target.removeEventListener(event, listener);\r\n    },\r\n\r\n    /**\r\n     * Emits an event with typed data.\r\n     * \r\n     * **Type Checking**: TypeScript ensures you provide the correct data type\r\n     * for each event.\r\n     * \r\n     * **Synchronous**: All handlers are called synchronously in registration order.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to emit\r\n     * @param data - The event data (type-checked against Events map)\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'save': { id: number; data: object; };\r\n     *   'delete': { id: number; };\r\n     *   'clear': void;\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Valid emissions\r\n     * bus.emit('save', { id: 1, data: { name: 'John' } });\r\n     * bus.emit('delete', { id: 1 });\r\n     * bus.emit('clear'); // void event\r\n     * \r\n     * // TypeScript errors:\r\n     * // bus.emit('save', { id: 1 }); // Missing 'data'\r\n     * // bus.emit('delete', {}); // Missing 'id'\r\n     * // bus.emit('clear', {}); // Unexpected data\r\n     * \r\n     * // Conditional emit\r\n     * if (hasChanges) {\r\n     *   bus.emit('save', { id, data: formData });\r\n     * }\r\n     * ```\r\n     */\r\n    emit: <K extends keyof Events & string>(event: K, data: Events[K]) => {\r\n      target.dispatchEvent(new CustomEvent(event, { detail: data }));\r\n    },\r\n\r\n    /**\r\n     * Subscribes to an event for one-time execution.\r\n     * \r\n     * **Auto-Unsubscribe**: The handler is automatically removed after the\r\n     * first time it's called.\r\n     * \r\n     * **Use Cases**: Initialization events, one-time confirmations, first-load actions.\r\n     * \r\n     * @template K - Event name (inferred from Events)\r\n     * @param event - The event name to listen for\r\n     * @param handler - Callback function (called only once)\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * interface Events {\r\n     *   'app:ready': void;\r\n     *   'user:firstLogin': { userId: number; };\r\n     * }\r\n     * \r\n     * const bus = createBus<Events>();\r\n     * \r\n     * // Run once when app is ready\r\n     * bus.once('app:ready', () => {\r\n     *   console.log('App initialized');\r\n     *   loadUserPreferences();\r\n     * });\r\n     * \r\n     * // First login bonus\r\n     * bus.once('user:firstLogin', ({ userId }) => {\r\n     *   showWelcomeModal(userId);\r\n     *   grantSignupBonus(userId);\r\n     * });\r\n     * \r\n     * // Emit multiple times - handler only runs once\r\n     * bus.emit('app:ready');\r\n     * bus.emit('app:ready'); // Handler doesn't run again\r\n     * ```\r\n     */\r\n    once: <K extends keyof Events & string>(\r\n      event: K,\r\n      handler: (data: Events[K]) => void\r\n    ): void => {\r\n      const listener = (e: Event) => handler((e as CustomEvent).detail);\r\n      target.addEventListener(event, listener, { once: true });\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 28. FLUENT WRAPPER ($)\r\n// =============================================================================\r\n\r\n/**\r\n * Wraps a single element in a fluent object with all fdom functions pre-bound.\r\n * \r\n * Provides an object-oriented, method-chaining API as an alternative to the\r\n * functional style. All methods return the wrapper (except getters), enabling\r\n * jQuery-like chaining.\r\n * \r\n * **vs Functional Style**:\r\n * - **Fluent**: `$(btn).addClass('active').css({ color: 'red' }).on('click', handler)`\r\n * - **Functional**: `cls.add(btn)('active'); css(btn)({ color: 'red' }); on(btn)('click', handler)`\r\n * \r\n * **When to Use**:\r\n * - **Fluent ($)**: When performing multiple operations on the same element\r\n * - **Functional**: When working with multiple elements or in functional pipelines\r\n * \r\n * **Type Preservation**: The generic type parameter preserves the element type\r\n * throughout the chain.\r\n * \r\n * **Null Safety**: All methods handle null elements gracefully.\r\n * \r\n * @template T - The HTML element type (inferred from input)\r\n * @param target - The element to wrap (null-safe)\r\n * @returns Fluent wrapper object with all fdom methods pre-bound\r\n * \r\n * @example\r\n * ```typescript\r\n * // Basic chaining\r\n * const button = document.querySelector('button');\r\n * $(button)\r\n *   .modify({ text: 'Click me' })\r\n *   .addClass('btn', 'btn-primary')\r\n *   .css({ padding: '10px 20px' })\r\n *   .on('click', () => console.log('Clicked!'));\r\n * \r\n * // vs Functional style (same result)\r\n * modify(button)({ text: 'Click me' });\r\n * cls.add(button)('btn', 'btn-primary');\r\n * css(button)({ padding: '10px 20px' });\r\n * on(button)('click', () => console.log('Clicked!'));\r\n * \r\n * // Type preservation\r\n * const input = document.querySelector('input');\r\n * $(input)\r\n *   .modify({ value: 'test' })\r\n *   .val('new value')  // Type-safe: knows it's an input\r\n *   .onInput((val) => console.log(val));\r\n * \r\n * // Conditional chaining\r\n * $(element)\r\n *   .addClass('base')\r\n *   .toggleClass('active', isActive)\r\n *   .css({ opacity: isVisible ? '1' : '0' });\r\n * \r\n * // Event handling with chaining\r\n * $(form)\r\n *   .on('submit', (e) => {\r\n *     e.preventDefault();\r\n *     const data = Form.serialize(form);\r\n *     submitData(data);\r\n *   })\r\n *   .on('reset', () => console.log('Form reset'));\r\n * \r\n * // Access raw element\r\n * const wrapped = $(button);\r\n * const raw = wrapped.raw; // Get underlying HTMLElement\r\n * \r\n * // Complex UI setup\r\n * $(modal)\r\n *   .addClass('modal')\r\n *   .css({ display: 'none' })\r\n *   .on('click', (e) => {\r\n *     if (e.target === modal) closeModal();\r\n *   })\r\n *   .append(\r\n *     el('div')({ class: { 'modal-content': true } })([\r\n *       el('h2')({})(['Modal Title']),\r\n *       el('p')({})(['Modal content'])\r\n *     ])\r\n *   );\r\n * \r\n * // Animation with chaining\r\n * $(element)\r\n *   .addClass('fade-in')\r\n *   .waitTransition()\r\n *   .then(() => {\r\n *     $(element).removeClass('fade-in').addClass('visible');\r\n *   });\r\n * \r\n * // Null-safe operations\r\n * const missing = document.querySelector('.nonexistent');\r\n * $(missing).addClass('test'); // No error, safely ignored\r\n * \r\n * // Comparison: Fluent vs Functional\r\n * // Fluent: Better for single-element operations\r\n * $(button).addClass('active').css({ color: 'red' });\r\n * \r\n * // Functional: Better for multiple elements\r\n * [button1, button2, button3].forEach(btn => {\r\n *   cls.add(btn)('active');\r\n *   css(btn)({ color: 'red' });\r\n * });\r\n * \r\n * // Or use $$ for batch operations\r\n * $$('.button').addClass('active').css({ color: 'red' });\r\n * ```\r\n */\r\nexport const $ = <T extends HTMLElement>(target: T | null) => {\r\n  // Helper to bind target-first functions and return wrapper for chaining\r\n  const chain = <F extends (t: any) => (...args: any[]) => any>(fn: F) =>\r\n    (...args: Parameters<ReturnType<F>>) => {\r\n      if (target) fn(target)(...args);\r\n      return wrapper;\r\n    };\r\n\r\n  const wrapper = {\r\n    /**\r\n     * The raw underlying HTMLElement.\r\n     * @type {T | null}\r\n     */\r\n    raw: target,\r\n\r\n    // =========================================\r\n    // EVENTS\r\n    // =========================================\r\n\r\n    /**\n     * Adds an event listener.\n     * @param event - Event name (e.g., 'click', 'submit')\n     * @param handler - Function to handle the event\n     * @param options - Event options (capture, passive, etc.)\n     * @returns {this} Fluent wrapper for chaining\n     */\n    on: chain(on),\n\r\n    /**\r\n     * Dispatches a custom event.\r\n     * @param name - Name of the event\r\n     * @param detail - Data to pass with the event\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    dispatch: chain(dispatch),\r\n\r\n    // =========================================\r\n    // MANIPULATION\r\n    // =========================================\r\n\r\n    /**\r\n     * Modifies element properties (text, html, class, etc.).\r\n     * @param props - Object of properties to set\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    modify: chain(modify),\r\n\r\n    /**\r\n     * Applies inline CSS styles.\r\n     * @param styles - Object of CSS properties (camelCase or kebab-case)\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    css: chain(css),\r\n\r\n    /**\r\n     * Applies temporary styles that revert after a delay.\r\n     * @param styles - Styles to apply\r\n     * @param ms - Optional duration in ms to revert styles\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    tempStyle: (styles: Partial<CSSStyleDeclaration>, ms?: number) => {\r\n      if (target) {\r\n        const revert = tempStyle(target)(styles);\r\n        if (ms) setTimeout(revert, ms);\r\n      }\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // STRUCTURE\r\n    // =========================================\r\n\r\n    /**\r\n     * Appends children to this element.\r\n     * @param children - Elements or strings to append\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    append: chain(append),\r\n\r\n    /**\r\n     * Prepends children to this element.\r\n     * @param children - Elements or strings to prepend\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    prepend: chain(prepend),\r\n\r\n    /**\r\n     * Inserts content after this element.\r\n     * @param content - Elements or strings to insert\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    after: chain(after),\r\n\r\n    /**\r\n     * Inserts content before this element.\r\n     * @param content - Elements or strings to insert\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    before: chain(before),\r\n\r\n    /**\r\n     * Removes this element from the DOM.\r\n     * @returns {void}\r\n     */\r\n    remove: () => { if (target) remove(target); },\r\n\r\n    /**\r\n     * Removes all children from this element.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    empty: () => { if (target) empty(target); return wrapper; },\r\n\r\n    /**\r\n     * Wraps this element with another element.\r\n     * @param wrapperEl - The wrapping element\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    wrap: chain(wrap),\r\n\r\n    /**\r\n     * Clones this element.\r\n     * @returns {HTMLElement} The cloned element (not wrapped)\r\n     */\r\n    clone: () => target ? clone(target) : null,\r\n\r\n    // =========================================\r\n    // CLASSES\r\n    // =========================================\r\n\r\n    /**\r\n     * Adds one or more classes.\r\n     * @param classes - Class names to add\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    addClass: chain(cls.add),\r\n\r\n    /**\r\n     * Removes one or more classes.\r\n     * @param classes - Class names to remove\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    removeClass: chain(cls.remove),\r\n\r\n    /**\r\n     * Toggles a class (conditionally or always).\r\n     * @param className - Class to toggle\r\n     * @param force - Optional boolean to force add/remove\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    toggleClass: chain(cls.toggle),\r\n\r\n    /**\r\n     * Replaces one class with another.\r\n     * @param oldClass - Class to remove\r\n     * @param newClass - Class to add\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    replaceClass: chain(cls.replace),\r\n\r\n    /**\r\n     * Checks if the element has a class.\r\n     * @param className - Class to check\r\n     * @returns {boolean} True if class exists\r\n     */\r\n    hasClass: (className: string) => target ? cls.has(target)(className) : false,\r\n\r\n    /**\r\n     * Watches for class changes.\r\n     * @param callback - Function called when classes change\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    //watchClass: (callback: (classes: string[]) => void) => target ? watchClass(target)(callback) : () => { },\r\n\r\n    /**\r\n     * Cycles through a list of classes (removes current, adds next).\r\n     * @param classes - Array of classes to cycle\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    cycleClass: chain(cycleClass),\r\n\r\n    // =========================================\r\n    // DATA & ATTRIBUTES\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets a data attribute value (raw string).\r\n     * @param key - Attribute name (without 'data-')\r\n     * @returns {string | undefined} Raw value\r\n     */\r\n    dataGet: (key: string) => target ? Data.get(target)(key) : undefined,\r\n\r\n    /**\r\n     * Sets a data attribute.\r\n     * @param key - Attribute name\r\n     * @param val - Value to set (automatically stringified)\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    dataSet: chain(Data.set),\r\n\r\n    /**\r\n     * Reads and parses a data attribute.\r\n     * @param key - Attribute name\r\n     * @returns {any} Parsed value (JSON, number, boolean, string)\r\n     */\r\n    dataRead: (key: string) => target ? Data.read(target)(key) : undefined,\r\n\r\n    /**\r\n     * Binds a callback to data attribute changes.\r\n     * @param key - Attribute to watch\r\n     * @param handler - Callback receiving new parsed value\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    dataBind: (key: string, handler: (val: any) => void) => target ? Data.bind(target)(key, handler) : () => { },\r\n\r\n    /**\r\n     * Watches an attribute for changes.\r\n     * @param attr - Attribute name\r\n     * @param handler - Callback receiving new value\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    watchAttr: (attr: string, handler: (val: string | null) => void) => target ? watchAttr(target)(attr, handler) : () => { },\r\n\r\n    /**\r\n     * Watches text content for changes.\r\n     * @param handler - Callback receiving new text\r\n     * @returns {Unsubscribe} Function to stop watching\r\n     */\r\n    watchText: (handler: (text: string | null) => void) => target ? watchText(target)(handler) : () => { },\r\n\r\n    // =========================================\r\n    // INPUTS & FORMS\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets or sets the value.\r\n     * - No args: Gets value (smart typed)\r\n     * - Arg provided: Sets value\r\n     * @param newVal - Value to set\r\n     * @returns {any | this} Value if getting, wrapper if setting\r\n     */\r\n    val: (newVal?: any) => {\r\n      if (newVal === undefined) return Input.get(target as unknown as FormElement);\r\n      Input.set(target as unknown as FormElement)(newVal);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Gets files from an input[type=\"file\"].\r\n     * @returns {File[]} Array of files\r\n     */\r\n    files: () => Input.files(target as unknown as HTMLInputElement),\r\n\r\n    /**\r\n     * Listens for input events (keystrokes).\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onInput: (handler: (val: any, e: Event) => void) => target ? Input.watch(target as unknown as FormElement)(handler) : () => { },\r\n\r\n    /**\r\n     * Listens for input events with debounce.\r\n     * @param ms - Debounce delay in ms\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onInputDebounced: (ms: number, handler: (val: any, e: Event) => void) => target ? Input.watchDebounced(target as unknown as FormElement)(handler as unknown as any, ms) : () => { },\r\n\r\n    /**\r\n     * Listens for change events (blur/enter).\r\n     * @param handler - Callback receiving parsed value\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onChange: (handler: (val: any, e: Event) => void) => target ? Input.change(target as unknown as FormElement)(handler) : () => { },\r\n\r\n    /**\r\n     * Selects all text in the input.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    selectText: () => { Input.select(target as unknown as HTMLInputElement); return wrapper; },\r\n\r\n    /**\r\n     * Validates the input using HTML5 validation API.\r\n     * @returns {boolean} True if valid\r\n     */\r\n    validate: () => target ? Input.validate(target as unknown as FormElement) : false,\r\n\r\n    // =========================================\r\n    // KEYBOARD\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for a specific key press.\r\n     * @param key - Key to listen for (e.g., 'Enter', 'Escape')\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onKey: (key: string, handler: (e: KeyboardEvent) => void) => {\r\n      if (target) Key.is(target)(key, handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for the Tab key.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onTab: (handler: (e: KeyboardEvent) => void) => {\r\n      if (target) Key.onTab(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for Arrow keys.\r\n     * @param handler - Callback receiving direction and event\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onArrow: (handler: (dir: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\r\n      if (target) Key.onArrow(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // FOCUS\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for focus event.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocus: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.on(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for blur event.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onBlur: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onBlur(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for focusin (bubbles).\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocusIn: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onIn(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Listens for focusout (bubbles).\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    onFocusOut: (handler: (e: FocusEvent) => void) => {\r\n      if (target) Focus.onOut(target)(handler);\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Traps focus within this element (for modals/dialogs).\r\n     * @returns {Unsubscribe} Function to disable trap\r\n     */\r\n    trapFocus: () => Focus.trap(target),\r\n\r\n    // =========================================\r\n    // POINTER & TEXT\r\n    // =========================================\r\n\r\n    /**\r\n     * Listens for clicks outside this element.\r\n     * @param handler - Callback function\r\n     * @returns {Unsubscribe} Function to stop listening\r\n     */\r\n    clickOutside: (handler: () => void) => {\r\n      if (!target) return () => { };\r\n      const listener = (e: Event) => {\r\n        if (target && !target.contains(e.target as Node)) handler();\r\n      };\r\n      document.addEventListener('click', listener);\r\n      return () => document.removeEventListener('click', listener);\r\n    },\r\n\r\n    /**\r\n     * Checks if element contains text.\r\n     * @param text - String or RegExp to search\r\n     * @returns {boolean} True if found\r\n     */\r\n    hasText: (text: string | RegExp) => target ? !!Text.find(target)(text) : false,\r\n\r\n    /**\r\n     * Finds the first text node matching the pattern.\r\n     * @param text - String or RegExp to search\r\n     * @param selector - Optional selector to scope search\r\n     * @returns {Text | null} The found text node\r\n     */\r\n    findText: (text: string | RegExp, selector?: string) => target ? Text.find(target)(text, selector) : null,\r\n\r\n    /**\r\n     * Finds all text nodes matching the pattern.\r\n     * @param text - String or RegExp to search\r\n     * @param selector - Optional selector to scope search\r\n     * @returns {Text[]} Array of found text nodes\r\n     */\r\n    findAllText: (text: string | RegExp, selector?: string) => target ? Text.findAll(target)(text, selector) : [],\r\n\r\n    /**\r\n     * Replaces text content.\r\n     * @param search - String or RegExp to find\r\n     * @param replace - Replacement string\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    replaceText: (search: string | RegExp, replace: string) => {\r\n      if (target) Text.replace(target)(search, replace);\r\n      return wrapper;\r\n    },\r\n\r\n    // =========================================\r\n    // VIEW TRANSITIONS\r\n    // =========================================\r\n\r\n    /**\r\n     * Sets the view-transition-name.\r\n     * @param name - Transition name\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    transitionName: chain(ViewTransitions.name),\r\n\r\n    /**\r\n     * Removes the view-transition-name.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    removeTransitionName: () => { ViewTransitions.unname(target); return wrapper; },\r\n\r\n    /**\r\n     * Runs a view transition focusing on this element.\r\n     * @param name - Temporary transition name\r\n     * @param updateFn - Function to run during transition\r\n     * @returns {Promise<void>} Promise resolving when done\r\n     */\r\n    transitionWith: (name: string, updateFn: () => void) => ViewTransitions.tempName(target)(name)(updateFn),\r\n\r\n    // =========================================\r\n    // TRAVERSAL\r\n    // =========================================\r\n\r\n    /** Parent element */\r\n    parent: Traverse.parent(target),\r\n    /** Next sibling element */\r\n    next: Traverse.next(target),\r\n    /** Previous sibling element */\r\n    prev: Traverse.prev(target),\r\n    /** Child elements */\r\n    children: Traverse.children(target),\r\n    /** Sibling elements */\r\n    siblings: Traverse.siblings(target),\r\n\r\n    // =========================================\r\n    // GEOMETRY & UI\r\n    // =========================================\r\n\r\n    /**\r\n     * Gets the bounding client rect.\r\n     * @returns {DOMRect | undefined}\r\n     */\r\n    rect: () => rect(target),\r\n\r\n    /**\r\n     * Gets the element's offset position.\r\n     * @returns {{ top: number, left: number } | undefined}\r\n     */\r\n    offset: () => offset(target),\r\n\r\n    /**\r\n     * Scrolls the element into view.\r\n     * @param arg - Scroll options or boolean\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    scrollInto: (arg?: boolean | ScrollIntoViewOptions) => { target?.scrollIntoView(arg); return wrapper; },\r\n\r\n    /**\r\n     * Focuses the element.\r\n     * @param options - Focus options\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    focus: (options?: FocusOptions) => { target?.focus(options); return wrapper; },\r\n\r\n    /**\r\n     * Blurs the element.\r\n     * @returns {this} Fluent wrapper for chaining\r\n     */\r\n    blur: () => { target?.blur(); return wrapper; },\r\n\r\n    // =========================================\r\n    // UTILS\r\n    // =========================================\r\n\r\n    /**\r\n     * Waits for CSS transitions to complete.\r\n     * @returns {Promise<void>}\r\n     */\r\n    waitTransition: () => waitTransition(target)\r\n  };\r\n\r\n  return wrapper;\r\n};\r\n\r\n/**\r\n * Turns a DOM tree into a component object by mapping `data-ref` nodes.\r\n * \r\n * **Pattern**: Use `data-ref=\"name\"` in HTML to mark elements. This function\r\n * gathers them into a strongly-typed object for easy access.\r\n * \r\n * **Type Safety**: Pass a generic type to define the expected refs.\r\n * \r\n * **Performance**: Scans the tree once on initialization. Much faster than\r\n * repeated `querySelector` calls.\r\n * \r\n * @template T - Interface defining the expected refs (e.g. `{ title: HTMLElement }`)\r\n * @param rootOrSelector - The root element or a selector string\r\n * @returns Object containing the root and all mapped refs\r\n * \r\n * @example\r\n * ```typescript\r\n * // HTML:\r\n * // <div id=\"card\">\r\n * //   <h1 data-ref=\"title\"></h1>\r\n * //   <button data-ref=\"btn\"></button>\r\n * //   <input data-ref=\"input\" type=\"text\">\r\n * // </div>\r\n * \r\n * // Define types\r\n * interface CardRefs {\r\n *   title: HTMLHeadingElement;\r\n *   btn: HTMLButtonElement;\r\n *   input: HTMLInputElement;\r\n * }\r\n * \r\n * // Initialize\r\n * const card = component<CardRefs>('#card');\r\n * \r\n * // Access refs directly (type-safe)\r\n * card.title.textContent = 'Hello World';\r\n * card.input.value = 'Initial value';\r\n * \r\n * // Use with fluent API\r\n * $(card.btn).on('click', () => {\r\n *   console.log(card.input.value);\r\n * });\r\n * \r\n * // Component Factory Pattern\r\n * function createCard(data: any) {\r\n *   const el = clone(template);\r\n *   const cmp = component<CardRefs>(el);\r\n *   \r\n *   cmp.title.textContent = data.title;\r\n *   \r\n *   return cmp;\r\n * }\r\n * ```\r\n */\r\nexport const component = <T extends Record<string, HTMLElement>>(rootOrSelector: HTMLElement | string | null) => {\r\n  const root = typeof rootOrSelector === 'string' ? find(document)(rootOrSelector) : rootOrSelector;\r\n  if (!root) return {} as T & { root: null };\r\n\r\n  // Get all refs\r\n  const nodes = refs(root) as T;\r\n\r\n  return {\r\n    root,\r\n    ...nodes\r\n  };\r\n};\r\n\r\n/**\r\n * Wraps a LIST of elements for batch operations.\r\n * \r\n * **Batch Processing**: Calling a method applies it to ALL elements in the list.\r\n * \r\n * **Performance**: Optimized for batch DOM updates.\r\n * \r\n * **Parallel Operations**: Methods run sequentially on each element, but\r\n * can be conceptually treated as parallel updates.\r\n * \r\n * @param selectorOrList - Selector string, Array of Elements, or NodeList\r\n * @returns Fluent wrapper for the list of elements\r\n * \r\n * @example\r\n * ```typescript\r\n * // Select and update multiple elements\r\n * $$('.btn')\r\n *   .addClass('active')\r\n *   .css({ opacity: '1' })\r\n *   .on('click', handler);\r\n * \r\n * // Filter and map\r\n * $$('input')\r\n *   .filter((el) => el.value === '')\r\n *   .addClass('error');\r\n * \r\n * // Batch event handling\r\n * const unsubscribeAll = $$('.item').on('click', (e) => {\r\n *   console.log('Item clicked');\r\n * });\r\n * \r\n * // Cleanup\r\n * unsubscribeAll();\r\n * \r\n * // Complex batch update\r\n * $$('.card')\r\n *   .removeClass('selected')\r\n *   .modify({ title: 'Reset' })\r\n *   .css({ transform: 'none' });\r\n * \r\n * // Functional map (returns array of results)\r\n * const values = $$('input').map(el => el.value);\r\n * \r\n * // Chaining with filter\r\n * $$('li')\r\n *   .filter((el, i) => i % 2 === 0) // Evens\r\n *   .css({ background: '#eee' });\r\n * ```\r\n */\r\nexport const $$ = (selectorOrList: string | Element[] | NodeListOf<Element>) => {\r\n  const elements = typeof selectorOrList === 'string'\r\n    ? findAll(document)(selectorOrList)\r\n    : Array.from(selectorOrList) as HTMLElement[];\r\n\r\n  // Helper to map a function over all elements\r\n  const map = (fn: any) => (arg: any, arg2?: any) => {\r\n    elements.forEach(el => fn(el)(arg, arg2));\r\n    return wrapper; // Return self for chaining\r\n  };\r\n\r\n  const wrapper = {\r\n    raw: elements,\r\n\r\n    // Batch Operations\r\n    modify: map(modify),\r\n    css: map(css),\r\n    addClass: map(cls.add),\r\n    removeClass: map(cls.remove),\r\n    toggleClass: map(cls.toggle),\r\n    attr: map((el: any) => (attr: any) => modify(el)({ attr })),\r\n\r\n    // Batch Events\r\n    on: (evt: any, handler: any) => {\r\n      const unsubs = elements.map(el => on(el)(evt, handler));\r\n      return () => unsubs.forEach(u => u()); // Return batch unsubscribe\r\n    },\r\n\r\n    // Batch Traversal / Manipulation\r\n    remove: () => elements.forEach(el => remove(el)),\r\n    empty: () => elements.forEach(el => empty(el)),\r\n\r\n    // Functional map (standard array map)\r\n    map: <T>(fn: (el: HTMLElement, i: number) => T) => elements.map(fn),\r\n    filter: (fn: (el: HTMLElement, i: number) => boolean) => elements.filter(fn)\r\n  };\r\n\r\n  return wrapper;\r\n};\r\n\r\n/**\r\n * Creates a Proxy object where properties are 2-way bound to the element's dataset.\r\n * \r\n * **Reactivity**: Assigning to properties updates the DOM `data-*` attributes.\r\n * Reading properties reads from the DOM.\r\n * \r\n * **Type Safety**: Use a generic interface to define the expected data structure.\r\n * \r\n * **Limitations**:\r\n * - Only stores strings (or JSON serialized values)\r\n * - Performance cost of DOM access on every read/write\r\n * - Property names are converted to kebab-case (e.g. `userId` -> `data-user-id`)\r\n * \r\n * @template T - Interface defining the store shape\r\n * @param element - The element to bind to\r\n * @returns Proxy object mirroring the element's dataset\r\n * \r\n * @example\r\n * ```typescript\r\n * // Define state shape\r\n * interface UserState {\r\n *   userId: number;\r\n *   isAdmin: boolean;\r\n *   theme: 'light' | 'dark';\r\n *   preferences: { notifications: boolean };\r\n * }\r\n * \r\n * // Create store\r\n * const state = store<UserState>(document.body);\r\n * \r\n * // Write to DOM (updates data-attributes)\r\n * state.userId = 123;          // data-user-id=\"123\"\r\n * state.isAdmin = true;        // data-is-admin=\"true\"\r\n * state.theme = 'dark';        // data-theme=\"dark\"\r\n * state.preferences = { notifications: true }; // JSON serialized\r\n * \r\n * // Read from DOM\r\n * console.log(state.userId); // 123 (typed as number)\r\n * \r\n * // Reactivity with MutationObserver\r\n * Data.bind(document.body)('user-id', (newId) => {\r\n *   console.log('User ID changed to:', newId);\r\n * });\r\n * \r\n * // Delete property\r\n * delete state.theme; // Removes data-theme attribute\r\n * ```\r\n */\r\nexport const store = <T extends Record<string, any> = Record<string, any>>(element: HTMLElement | null) => {\r\n  if (!element) return {} as T;\r\n\r\n  return new Proxy({}, {\r\n    get: (_, prop: string) => Data.read(element)(prop),\r\n    set: (_, prop: string, value: any) => {\r\n      Data.set(element)(prop, value);\r\n      return true;\r\n    },\r\n    deleteProperty: (_, prop: string) => {\r\n      Data.set(element)(prop, null);\r\n      return true;\r\n    },\r\n    // Allow iteration over current dataset\r\n    ownKeys: () => Reflect.ownKeys(element.dataset),\r\n    getOwnPropertyDescriptor: (_, _key) => ({\r\n      enumerable: true,\r\n      configurable: true,\r\n    })\r\n  }) as T;\r\n};\r\n\r\n/**\r\n * Wraps a form or container to manage input values, validation, and submission.\r\n * \r\n * **Features**:\r\n * - Automatic serialization of all inputs\r\n * - Population of inputs from data objects\r\n * - Simplified submit handling with `preventDefault`\r\n * - Batch clearing of inputs\r\n * \r\n * **Validation**: Combine with `Input.validate` or custom logic in submit handler.\r\n * \r\n * @param target - Form element or selector\r\n * @returns Form wrapper object\r\n * \r\n * @example\r\n * ```typescript\r\n * const f = form('#login-form');\r\n * \r\n * // Get all values\r\n * const data = f.values();\r\n * console.log(data.username, data.password);\r\n * \r\n * // Pre-fill form\r\n * f.set({\r\n *   username: 'admin',\r\n *   rememberMe: true\r\n * });\r\n * \r\n * // Handle submit\r\n * f.submit((data, e) => {\r\n *   // Validations\r\n *   if (!data.username) {\r\n *     alert('Username required');\r\n *     return;\r\n *   }\r\n *   \r\n *   // API call\r\n *   api.login(data).catch(err => {\r\n *     console.error(err);\r\n *     f.clear(); // Clear on error if needed\r\n *   });\r\n * });\r\n * \r\n * // Clear form\r\n * f.clear();\r\n * ```\r\n */\r\nexport const form = (target: HTMLElement | string | null) => {\r\n  const el = typeof target === 'string' ? find(document)(target) : target;\r\n\r\n  return {\r\n    raw: el,\r\n    /** Get all values as object */\r\n    values: () => Form.serialize(el),\r\n    /** Set values from object */\r\n    set: (data: Record<string, any>) => Form.populate(el)(data),\r\n    /** Clear all inputs */\r\n    clear: () => {\r\n      if (!el) return;\r\n      el.querySelectorAll('input, select, textarea').forEach((i: any) => {\r\n        if (i.type === 'checkbox' || i.type === 'radio') i.checked = false;\r\n        else i.value = '';\r\n      });\r\n    },\r\n    /** Short hand for on('submit') with preventDefault and serialization */\r\n    submit: (handler: (data: any, e: Event) => void) => {\r\n      return on(el)('submit', (e) => {\r\n        e.preventDefault();\r\n        handler(Form.serialize(el), e);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 29. INPUTS & CONTROLS\r\n// =============================================================================\r\n\r\nexport type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\r\n\r\nexport const Input = {\r\n  /**\r\n   * Smart Getter. Automatically handles:\r\n   * - Checkbox/Radio -> boolean\r\n   * - Number/Range -> number\r\n   * - File -> FileList\r\n   * - Select/Text -> string\r\n   * \r\n   * @example const val = Input.get(input);\r\n   */\r\n  get: (el: FormElement | null): any => {\r\n    if (!el) return undefined;\r\n    if (el instanceof HTMLInputElement) {\r\n      if (el.type === 'checkbox' || el.type === 'radio') return el.checked;\r\n      if (el.type === 'number' || el.type === 'range') return el.valueAsNumber;\r\n      if (el.type === 'file') return el.files;\r\n      if (el.type === 'date') return el.valueAsDate;\r\n    }\r\n    return el.value;\r\n  },\r\n\r\n  /**\r\n   * Smart Setter. Automatically handles checkboxes, numbers, etc.\r\n   * \r\n   * @example Input.set(checkbox)(true);\r\n   */\r\n  set: (el: FormElement | null) => (val: any) => {\r\n    if (!el) return el;\r\n    if (el instanceof HTMLInputElement) {\r\n      if (el.type === 'checkbox' || el.type === 'radio') {\r\n        el.checked = !!val;\r\n      } else if (el.type === 'file') {\r\n        // Read-only usually, but clearing allowed\r\n        if (!val) el.value = '';\r\n      } else if (el.type === 'date' && val instanceof Date) {\r\n        el.valueAsDate = val;\r\n      } else {\r\n        el.value = String(val);\r\n      }\r\n    } else {\r\n      el.value = String(val);\r\n    }\r\n    // Trigger event so listeners know it changed programmatically\r\n    el.dispatchEvent(new Event('input', { bubbles: true }));\r\n    el.dispatchEvent(new Event('change', { bubbles: true }));\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of Files from a file input (easier than FileList).\r\n   */\r\n  files: (el: HTMLInputElement | null): File[] => {\r\n    return el && el.files ? Array.from(el.files) : [];\r\n  },\r\n\r\n  /**\r\n   * Watches the 'input' event (keystrokes).\r\n   * callback receives the *parsed* value, not the event.\r\n   * \r\n   * @example Input.watch(search)(query => filterList(query));\r\n   */\r\n  watch: (el: FormElement | null) => {\r\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const handler = (e: Event) => callback(Input.get(el), e);\r\n      el.addEventListener('input', handler);\r\n      return () => el.removeEventListener('input', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Watches the 'input' event with a DEBOUNCE.\r\n   * Perfect for search bars.\r\n   * \r\n   * @example Input.watchDebounced(search)(query => api.search(query), 500);\r\n   */\r\n  watchDebounced: (el: FormElement | null) => {\r\n    return (callback: (val: any) => void, ms: number): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const d = debounce((_e) => callback(Input.get(el)), ms);\r\n      el.addEventListener('input', d);\r\n      return () => el.removeEventListener('input', d);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Watches the 'change' event (blur/enter/selection).\r\n   * \r\n   * @example Input.change(dropdown)(val => console.log('Selected', val));\r\n   */\r\n  change: (el: FormElement | null) => {\r\n    return (callback: (val: any, e: Event) => void): Unsubscribe => {\r\n      if (!el) return () => { };\r\n      const handler = (e: Event) => callback(Input.get(el), e);\r\n      el.addEventListener('change', handler);\r\n      return () => el.removeEventListener('change', handler);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Selects all text in the input/textarea.\r\n   */\r\n  select: (el: HTMLInputElement | HTMLTextAreaElement | null) => {\r\n    el?.select();\r\n    return el;\r\n  },\r\n\r\n  /**\r\n   * Checks validity and returns boolean. \r\n   * Optionally sets custom validity message.\r\n   */\r\n  validate: (el: FormElement | null) => (msg?: string): boolean => {\r\n    if (!el) return false;\r\n    if (msg !== undefined) el.setCustomValidity(msg);\r\n    return el.checkValidity();\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 30. EVENT HELPERS\r\n// =============================================================================\r\n\r\nexport const Evt = {\r\n  /**\r\n   * Stops propagation (bubbling) of the event.\r\n   * Can be used as a wrapper for handlers.\r\n   * \r\n   * @example on(btn)('click', Evt.stop(handler));\r\n   */\r\n  stop: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.stopPropagation();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Prevents default behavior.\r\n   * \r\n   * @example on(form)('submit', Evt.prevent(submitHandler));\r\n   */\r\n  prevent: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.preventDefault();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Stops propagation AND prevents default.\r\n   */\r\n  kill: <E extends Event>(fn?: (e: E) => void) => (e: E) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    if (fn) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Filters an event handler to only run for specific keys.\r\n   * \r\n   * @example on(input)('keydown', Evt.key('Enter', search));\r\n   */\r\n  key: (keyOrKeys: string | string[], fn: (e: KeyboardEvent) => void) => (e: KeyboardEvent) => {\r\n    const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\r\n    if (keys.includes(e.key)) fn(e);\r\n  },\r\n\r\n  /**\r\n   * Checks if the event triggered exactly on the element (not a child).\r\n   */\r\n  isSelf: (e: Event) => e.target === e.currentTarget,\r\n\r\n  /**\r\n   * Gets the coordinate of the event relative to the viewport.\r\n   * Handles Mouse and Touch events uniformly.\r\n   */\r\n  pointer: (e: MouseEvent | TouchEvent | Event) => {\r\n    if ('touches' in e) {\r\n      const t = (e as TouchEvent).touches[0] || (e as TouchEvent).changedTouches[0];\r\n      return { x: t.clientX, y: t.clientY };\r\n    }\r\n    return { x: (e as MouseEvent).clientX, y: (e as MouseEvent).clientY };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 31. KEYBOARD & FOCUS INTERACTIONS\r\n// =============================================================================\r\n\r\nexport const Key = {\r\n  /**\r\n   * Listens for a specific key press.\r\n   * @example Key.is(input)('Enter', onSubmit);\r\n   */\r\n  is: (target: EventTarget | null) => (key: string, handler: (e: KeyboardEvent) => void) => {\r\n    return on(target)('keydown', (e) => {\r\n      if (e.key === key) handler(e as KeyboardEvent);\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Listens for the 'Tab' key.\r\n   * Useful for trapping focus or form navigation logic.\r\n   */\r\n  onTab: (target: EventTarget | null) => (handler: (e: KeyboardEvent) => void) => {\r\n    return on(target)('keydown', (e) => {\r\n      if (e.key === 'Tab') handler(e as KeyboardEvent);\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Listens for any Arrow key.\r\n   * Handler receives the direction ('Up' | 'Down' | 'Left' | 'Right').\r\n   * \r\n   * @example \r\n   * Key.onArrow(menu)((dir, e) => {\r\n   *   if (dir === 'Down') focusNext();\r\n   * });\r\n   */\r\n  onArrow: (target: EventTarget | null) => {\r\n    return (handler: (direction: 'Up' | 'Down' | 'Left' | 'Right', e: KeyboardEvent) => void) => {\r\n      return on(target)('keydown', (e) => {\r\n        if (e.key.startsWith('Arrow')) {\r\n          const dir = e.key.replace('Arrow', '') as 'Up' | 'Down' | 'Left' | 'Right';\r\n          handler(dir, e as KeyboardEvent);\r\n        }\r\n      });\r\n    };\r\n  }\r\n};\r\n\r\nexport const Focus = {\r\n  /**\r\n   * Standard Focus event.\r\n   */\r\n  on: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focus', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Standard Blur event.\r\n   */\r\n  onBlur: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('blur', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Focus In (Bubbles).\r\n   * Useful for detecting if ANY child within a container gained focus.\r\n   */\r\n  onIn: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focusin', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Focus Out (Bubbles).\r\n   * Useful for detecting if focus left a container entirely.\r\n   */\r\n  onOut: (target: HTMLElement | null) => (handler: (e: FocusEvent) => void) => {\r\n    return on(target)('focusout', handler as any);\r\n  },\r\n\r\n  /**\r\n   * Traps focus within an element (Accessibility).\r\n   * Prevents Tab from leaving the target container.\r\n   */\r\n  trap: (target: HTMLElement | null) => {\r\n    if (!target) return () => { };\r\n\r\n    const handler = (e: KeyboardEvent) => {\r\n      if (e.key !== 'Tab') return;\r\n\r\n      const focusables = target.querySelectorAll<HTMLElement>(\r\n        'a[href], button, textarea, input, select, [tabindex]:not([tabindex=\"-1\"])'\r\n      );\r\n      const first = focusables[0];\r\n      const last = focusables[focusables.length - 1];\r\n\r\n      if (e.shiftKey) {\r\n        if (document.activeElement === first) {\r\n          e.preventDefault();\r\n          last.focus();\r\n        }\r\n      } else {\r\n        if (document.activeElement === last) {\r\n          e.preventDefault();\r\n          first.focus();\r\n        }\r\n      }\r\n    };\r\n\r\n    target.addEventListener('keydown', handler);\r\n    return () => target.removeEventListener('keydown', handler);\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 32. TEXT QUERYING\r\n// =============================================================================\r\n\r\nexport const Text = {\r\n  /**\r\n   * Finds all elements containing the specified text or matching a Regex.\r\n   * \r\n   * @example\r\n   * // Find all buttons saying \"Submit\"\r\n   * const btns = Text.findAll(document)('Submit', 'button');\r\n   * \r\n   * // Find using Regex\r\n   * const prices = Text.findAll(table)(/$\\d+\\.\\d{2}/);\r\n   */\r\n  findAll: (root: Element | Document = document) => {\r\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element[] => {\r\n      const matches = new Set<Element>();\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n\r\n      let node: Node | null;\r\n      while ((node = walker.nextNode())) {\r\n        const parent = node.parentElement;\r\n        const content = node.nodeValue || '';\r\n\r\n        // 1. Check if parent matches selector\r\n        if (!parent || !parent.matches(selector)) continue;\r\n\r\n        // 2. Check text match\r\n        const isMatch = typeof textOrRegex === 'string'\r\n          ? content.includes(textOrRegex)\r\n          : textOrRegex.test(content);\r\n\r\n        if (isMatch) matches.add(parent);\r\n      }\r\n\r\n      return Array.from(matches);\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Finds the FIRST element containing the text.\r\n   * \r\n   * @example\r\n   * const btn = Text.find(form)('Save');\r\n   */\r\n  find: (root: Element | Document = document) => {\r\n    return (textOrRegex: string | RegExp, selector: string = '*'): Element | null => {\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n      let node: Node | null;\r\n\r\n      while ((node = walker.nextNode())) {\r\n        const parent = node.parentElement;\r\n        const content = node.nodeValue || '';\r\n\r\n        if (!parent || !parent.matches(selector)) continue;\r\n\r\n        const isMatch = typeof textOrRegex === 'string'\r\n          ? content.includes(textOrRegex)\r\n          : textOrRegex.test(content);\r\n\r\n        if (isMatch) return parent;\r\n      }\r\n      return null;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Replaces text in the target's descendants.\r\n   * Safe wrapper that only touches text nodes, preserving HTML structure.\r\n   * \r\n   * @example\r\n   * Text.replace(document.body)('foo', 'bar');\r\n   */\r\n  replace: (root: Element | null) => {\r\n    return (searchValue: string | RegExp, replaceValue: string) => {\r\n      if (!root) return root;\r\n      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\r\n      let node: Node | null;\r\n\r\n      while ((node = walker.nextNode())) {\r\n        const val = node.nodeValue || '';\r\n        if (typeof searchValue === 'string' ? val.includes(searchValue) : searchValue.test(val)) {\r\n          node.nodeValue = val.replace(searchValue, replaceValue);\r\n        }\r\n      }\r\n      return root;\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 33. VIEW TRANSITIONS\r\n// =============================================================================\r\n\r\n// Type shim for environments where ViewTransition isn't in 'lib' yet\r\ninterface ViewTransition {\r\n  finished: Promise<void>;\r\n  ready: Promise<void>;\r\n  updateCallbackDone: Promise<void>;\r\n  skipTransition(): void;\r\n}\r\n\r\nexport const ViewTransitions = {\r\n  /** Checks if View Transitions are supported. */\r\n  isSupported: () => 'startViewTransition' in document,\r\n\r\n  /**\r\n   * Sets the `view-transition-name` on an element.\r\n   * Essential for connecting elements across DOM updates.\r\n   * \r\n   * @example View.name(img)('hero-image');\r\n   */\r\n  name: (target: HTMLElement | null) => (name: string) => {\r\n    if (target) target.style.viewTransitionName = name;\r\n    return target;\r\n  },\r\n\r\n  /** Removes the view-transition-name. */\r\n  unname: (target: HTMLElement | null) => {\r\n    if (target) target.style.removeProperty('view-transition-name');\r\n    return target;\r\n  },\r\n\r\n  /**\r\n   * Starts a global View Transition.\r\n   * Gracefully falls back to immediate execution if not supported.\r\n   * \r\n   * @example\r\n   * ViewTransitions.start(() => {\r\n   *   // Update DOM here\r\n   *   document.body.append(newPage);\r\n   * });\r\n   */\r\n  start: (updateCallback: () => Promise<void> | void): ViewTransition | null => {\r\n    if (!('startViewTransition' in document)) {\r\n      updateCallback();\r\n      return null;\r\n    }\r\n    // @ts-ignore\r\n    return document.startViewTransition(updateCallback);\r\n  },\r\n\r\n  /**\r\n   * Starts a transition with a specific class applied to the document element.\r\n   * Useful for defining different animations (e.g. 'slide-left' vs 'slide-right').\r\n   * \r\n   * @example ViewTransitions.withClass('slide-back')(() => history.back());\r\n   */\r\n  withClass: (className: string) => (updateCallback: () => Promise<void> | void) => {\r\n    document.documentElement.classList.add(className);\r\n\r\n    const transition = ViewTransitions.start(updateCallback);\r\n\r\n    if (transition) {\r\n      transition.finished.finally(() => document.documentElement.classList.remove(className));\r\n    } else {\r\n      document.documentElement.classList.remove(className);\r\n    }\r\n    return transition;\r\n  },\r\n\r\n  /**\r\n   * Applies a transition name to an element ONLY for the duration of the next transition.\r\n   * Auto-cleans up the name when the transition finishes.\r\n   * \r\n   * @example View.tempName(img)('hero-morph')(async () => updateDOM());\r\n   */\r\n  tempName: (target: HTMLElement | null) => (name: string) => {\r\n    return (updateCallback: () => Promise<void> | void) => {\r\n      if (!target) return ViewTransitions.start(updateCallback);\r\n\r\n      target.style.viewTransitionName = name;\r\n      const transition = ViewTransitions.start(updateCallback);\r\n\r\n      if (transition) {\r\n        transition.finished.finally(() => target.style.removeProperty('view-transition-name'));\r\n      } else {\r\n        target.style.removeProperty('view-transition-name');\r\n      }\r\n      return transition;\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 34. ASYNC & PROMISES\r\n// =============================================================================\r\n\r\nexport const Async = {\r\n  /**\r\n   * Wraps a value or Promise in a Promise (safe normalization).\r\n   */\r\n  resolve: <T>(v: T | PromiseLike<T>): Promise<T> => Promise.resolve(v),\r\n\r\n  /**\r\n   * Sleeps for N milliseconds.\r\n   * @example await Async.sleep(1000);\r\n   */\r\n  sleep: (ms: number) => new Promise(resolve => setTimeout(resolve, ms)),\r\n\r\n  /**\r\n   * Waits for the next Animation Frame.\r\n   */\r\n  nextFrame: () => new Promise(resolve => requestAnimationFrame(resolve)),\r\n\r\n  /**\r\n   * Retries a function N times with exponential backoff.\r\n   * \r\n   * @example\r\n   * const data = await Async.retry(() => api.get(), { retries: 3 });\r\n   */\r\n  retry: <T>(\r\n    fn: () => Promise<T>,\r\n    options: { retries?: number, delay?: number, factor?: number } = {}\r\n  ): Promise<T> => {\r\n    const { retries = 3, delay = 100, factor = 2 } = options;\r\n\r\n    return fn().catch(err => {\r\n      if (retries <= 0) throw err;\r\n      return Async.sleep(delay).then(() =>\r\n        Async.retry(fn, { retries: retries - 1, delay: delay * factor, factor })\r\n      );\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Races a promise against a timeout.\r\n   * Throws 'TimeoutError' if time limit exceeded.\r\n   * \r\n   * @example\r\n   * await Async.timeout(fetch('/long'), 5000);\r\n   */\r\n  timeout: <T>(promise: Promise<T>, ms: number): Promise<T> => {\r\n    return Promise.race([\r\n      promise,\r\n      new Promise<T>((_, reject) => setTimeout(() => reject(new Error('TimeoutError')), ms))\r\n    ]);\r\n  },\r\n\r\n  /**\r\n   * Limits concurrency of a map function.\r\n   * Useful for batch processing without flooding the network.\r\n   * \r\n   * @example\r\n   * await Async.map(userIds, fetchUser, 2); // 2 at a time\r\n   */\r\n  map: async <T, R>(\r\n    items: T[],\r\n    fn: (item: T, index: number) => Promise<R>,\r\n    concurrency: number = Infinity\r\n  ): Promise<R[]> => {\r\n    const results: R[] = [];\r\n    const queue = items.map((item, i) => ({ item, i }));\r\n\r\n    const worker = async () => {\r\n      while (queue.length > 0) {\r\n        const { item, i } = queue.shift()!;\r\n        results[i] = await fn(item, i);\r\n      }\r\n    };\r\n\r\n    await Promise.all(Array.from({ length: Math.min(items.length, concurrency) }, worker));\r\n    return results;\r\n  },\r\n\r\n  /**\r\n   * Creates a \"Deferred\" promise object (exposed resolve/reject).\r\n   * \r\n   * @example\r\n   * const { promise, resolve } = Async.defer();\r\n   */\r\n  defer: <T>() => {\r\n    let resolve!: (value: T | PromiseLike<T>) => void;\r\n    let reject!: (reason?: any) => void;\r\n    const promise = new Promise<T>((res, rej) => { resolve = res; reject = rej; });\r\n    return { promise, resolve, reject };\r\n  },\r\n\r\n  /**\r\n   * Wraps a promise to make it \"Cancelable\" (wrapper only).\r\n   * Note: Does not stop the underlying operation, just ignores the result.\r\n   */\r\n  cancelable: <T>(promise: Promise<T>) => {\r\n    let isCanceled = false;\r\n    const wrapped = new Promise<T>((resolve, reject) => {\r\n      promise.then(\r\n        val => !isCanceled && resolve(val),\r\n        err => !isCanceled && reject(err)\r\n      );\r\n    });\r\n    return {\r\n      promise: wrapped,\r\n      cancel: () => { isCanceled = true; }\r\n    };\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 35. TASK QUEUE\r\n// =============================================================================\r\n\r\n/**\r\n * Creates a Task Queue with concurrency control.\r\n * Useful for throttling API calls, toasts, or sequential animations.\r\n * \r\n * @example\r\n * const q = createQueue({ concurrency: 1 });\r\n * q.add(() => api.save(A));\r\n * q.add(() => api.save(B));\r\n * await q.drain();\r\n */\r\nexport const createQueue = (options: { concurrency?: number, autoStart?: boolean } = {}) => {\r\n  type Task<T = any> = () => Promise<T> | T;\r\n\r\n  const concurrency = options.concurrency || 1;\r\n  const queue: { fn: Task, resolve: Function, reject: Function }[] = [];\r\n  let active = 0;\r\n  let isPaused = !options.autoStart && options.autoStart !== undefined;\r\n\r\n  // Event listeners\r\n  const listeners: Record<string, Function[]> = {\r\n    drain: [],\r\n    error: []\r\n  };\r\n\r\n  const next = () => {\r\n    if (isPaused || active >= concurrency || queue.length === 0) {\r\n      if (active === 0 && queue.length === 0) listeners.drain.forEach(fn => fn());\r\n      return;\r\n    }\r\n\r\n    const job = queue.shift();\r\n    if (!job) return;\r\n\r\n    active++;\r\n\r\n    Promise.resolve()\r\n      .then(() => job.fn())\r\n      .then(res => job.resolve(res))\r\n      .catch(err => {\r\n        listeners.error.forEach(fn => fn(err));\r\n        job.reject(err);\r\n      })\r\n      .finally(() => {\r\n        active--;\r\n        next();\r\n      });\r\n\r\n    next(); // Try to start more if concurrency allows\r\n  };\r\n\r\n  return {\r\n    /** Adds a task to the queue. Returns a promise that resolves when the task finishes. */\r\n    add: <T>(fn: Task<T>): Promise<T> => {\r\n      return new Promise((resolve, reject) => {\r\n        queue.push({ fn, resolve, reject });\r\n        next();\r\n      });\r\n    },\r\n\r\n    /** Pauses processing. Active tasks complete, but new ones wait. */\r\n    pause: () => { isPaused = true; },\r\n\r\n    /** Resumes processing. */\r\n    resume: () => { isPaused = false; next(); },\r\n\r\n    /** Clears all pending tasks. */\r\n    clear: () => { queue.length = 0; },\r\n\r\n    /** Returns the number of pending + active tasks. */\r\n    size: () => queue.length + active,\r\n\r\n    /** Returns a promise that resolves when all tasks are complete. */\r\n    drain: () => new Promise<void>(resolve => {\r\n      if (active === 0 && queue.length === 0) return resolve();\r\n      listeners.drain.push(resolve);\r\n    }),\r\n\r\n    /** Listen for errors (globally for the queue). */\r\n    onError: (fn: (err: any) => void) => listeners.error.push(fn)\r\n  };\r\n};\r\n\r\n// =============================================================================\r\n// 36. HISTORY & URL STATE\r\n// =============================================================================\r\n\r\n/**\r\n * Valid types for URL Query Parameters.\r\n */\r\nexport type QueryValue = string | number | boolean | null | undefined;\r\nexport type QueryParams = Record<string, QueryValue | QueryValue[]>;\r\n\r\nexport const History = {\r\n  /**\r\n   * Updates the URL Query Parameters with new values.\r\n   * Merges with existing params. Pass `null` or `undefined` to remove a key.\r\n   * Handles arrays as repeated params (e.g., `?tag=a&tag=b`).\r\n   * \r\n   * Order: params -> (mode?)\r\n   * \r\n   * @example \r\n   * // Results in ?page=2&sort=desc\r\n   * History.query({ page: 2, sort: 'desc' })(); \r\n   * \r\n   * // Replace history instead of push\r\n   * History.query({ tab: 'settings' })('replace');\r\n   */\r\n  query: (params: QueryParams) => (mode: 'push' | 'replace' = 'push') => {\r\n    const url = new URL(window.location.href);\r\n\r\n    Object.entries(params).forEach(([k, v]) => {\r\n      // 1. Remove existing keys to overwrite/clear them\r\n      url.searchParams.delete(k);\r\n\r\n      // 2. Set new values\r\n      if (v === null || v === undefined || v === '') return;\r\n\r\n      if (Array.isArray(v)) {\r\n        v.forEach(item => url.searchParams.append(k, String(item)));\r\n      } else {\r\n        url.searchParams.set(k, String(v));\r\n      }\r\n    });\r\n\r\n    const method = mode === 'replace' ? 'replaceState' : 'pushState';\r\n    window.history[method](window.history.state, '', url.href);\r\n  },\r\n\r\n  /**\r\n   * Reads current Query Parameters into a typed Object.\r\n   * Note: duplicate keys (arrays) will return the *last* value, \r\n   * use `History.readQueryAll()` if you expect arrays.\r\n   * \r\n   * @template T\r\n   * @returns {T}\r\n   * \r\n   * @example \r\n   * const { page, sort } = History.readQuery<{ page: string, sort: string }>();\r\n   */\r\n  readQuery: <T extends Record<string, string>>(): T => {\r\n    return Object.fromEntries(new URLSearchParams(window.location.search)) as unknown as T;\r\n  },\r\n\r\n  /**\r\n   * Reads Query Parameters, ensuring all values are arrays.\r\n   * Useful for filters like `?tags=a&tags=b`.\r\n   */\r\n  readQueryAll: (): Record<string, string[]> => {\r\n    const params: Record<string, string[]> = {};\r\n    new URLSearchParams(window.location.search).forEach((val, key) => {\r\n      (params[key] = params[key] || []).push(val);\r\n    });\r\n    return params;\r\n  },\r\n\r\n  /**\r\n   * Pushes a new entry onto the history stack with optional state.\r\n   * \r\n   * @template T - Type of the state object\r\n   * @example History.push('/profile', { userId: 123 });\r\n   */\r\n  push: <T = any>(path: string, state?: T) => {\r\n    window.history.pushState(state, '', path);\r\n  },\r\n\r\n  /**\r\n   * Replaces the current history entry.\r\n   * \r\n   * @template T - Type of the state object\r\n   * @example History.replace(window.location.pathname, { scrolled: true });\r\n   */\r\n  replace: <T = any>(path: string, state?: T) => {\r\n    window.history.replaceState(state, '', path);\r\n  },\r\n\r\n  /**\r\n   * Gets the current history state object with Type Safety.\r\n   * \r\n   * @template T\r\n   * @example const state = History.state<{ userId: number }>();\r\n   */\r\n  state: <T>(): T | null => {\r\n    return window.history.state as T;\r\n  },\r\n\r\n  /**\r\n   * Navigates back in history.\r\n   */\r\n  back: () => window.history.back(),\r\n\r\n  /**\r\n   * Navigates forward in history.\r\n   */\r\n  forward: () => window.history.forward(),\r\n\r\n  /**\r\n   * Reloads the current page.\r\n   */\r\n  reload: () => window.location.reload(),\r\n\r\n  /**\r\n   * Listens for history changes (Back/Forward buttons).\r\n   * Returns a cleanup function.\r\n   * \r\n   * @example \r\n   * const stop = History.onPop(e => console.log('Navigated to', e.state));\r\n   */\r\n  onPop: (handler: (e: PopStateEvent) => void): Unsubscribe => {\r\n    window.addEventListener('popstate', handler);\r\n    return () => window.removeEventListener('popstate', handler);\r\n  },\r\n\r\n  /**\r\n   * Serializes an object to a Unicode-safe Base64 string.\r\n   * Useful for storing complex state in the URL hash.\r\n   * \r\n   * @example window.location.hash = History.encodeState({ filters: [...] });\r\n   */\r\n  encodeState: (state: any): string => {\r\n    try {\r\n      const json = JSON.stringify(state);\r\n      // encodeURIComponent handles Unicode chars that btoa chokes on\r\n      return btoa(encodeURIComponent(json).replace(/%([0-9A-F]{2})/g,\r\n        (_, p1) => String.fromCharCode(parseInt(p1, 16))\r\n      ));\r\n    } catch { return ''; }\r\n  },\r\n\r\n  /**\r\n   * Deserializes a Base64 string back to an object.\r\n   */\r\n  decodeState: <T>(str: string): T | null => {\r\n    try {\r\n      const json = decodeURIComponent(Array.prototype.map.call(atob(str),\r\n        (c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\r\n      ).join(''));\r\n      return JSON.parse(json);\r\n    } catch { return null; }\r\n  },\r\n\r\n  /**\r\n * Two-way binds a form input to a URL Query Parameter.\r\n * \r\n * Features:\r\n * 1. Sets input value from URL on load.\r\n * 2. Updates URL on input change (debounced).\r\n * 3. Updates input on PopState (Back/Forward button).\r\n * \r\n * Order: paramName -> debounceMs -> element\r\n * \r\n * @example \r\n * const searchInput = find(document)('#search');\r\n * History.syncToUrl('q', 300)(searchInput);\r\n */\r\n  syncToUrl: (paramName: string, debounceMs = 300) => (target: HTMLElement | null): Unsubscribe => {\r\n    if (!target) return () => { };\r\n\r\n    // Determine if element is Checkbox/Radio or Text-like\r\n    const isCheckable = (target as HTMLInputElement).type === 'checkbox' || (target as HTMLInputElement).type === 'radio';\r\n\r\n    // 1. READ: Function to update DOM from URL\r\n    const updateFromUrl = () => {\r\n      const val = new URLSearchParams(window.location.search).get(paramName);\r\n      if (val === null) return; // No param = do nothing (or clear?)\r\n\r\n      if (isCheckable) {\r\n        (target as HTMLInputElement).checked = val === 'true';\r\n      } else {\r\n        (target as HTMLInputElement).value = val;\r\n      }\r\n    };\r\n\r\n    // 2. WRITE: Function to update URL from DOM\r\n    const updateToUrl = debounce(() => {\r\n      const val = isCheckable\r\n        ? String((target as HTMLInputElement).checked)\r\n        : (target as HTMLInputElement).value;\r\n\r\n      History.query({ [paramName]: val })('replace');\r\n    }, debounceMs);\r\n\r\n    // 3. BIND: Attach listeners\r\n    updateFromUrl(); // Initial sync\r\n\r\n    target.addEventListener('input', updateToUrl);\r\n    target.addEventListener('change', updateToUrl);\r\n    window.addEventListener('popstate', updateFromUrl);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      target.removeEventListener('input', updateToUrl);\r\n      target.removeEventListener('change', updateToUrl);\r\n      window.removeEventListener('popstate', updateFromUrl);\r\n    };\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// 0.1 FUNCTIONAL COMBINATORS\r\n// =============================================================================\r\n\r\nexport const Fn = {\r\n  /**\r\n   * Standard Left-to-Right composition.\r\n   * Passes the output of one function as the input to the next.\r\n   * @example pipe(getName, toUpper, log)(user);\r\n   */\r\n  pipe: <T>(...fns: Function[]) => (x: T) => fns.reduce((v, f) => f(v), x),\r\n\r\n  /**\r\n   * Curries a binary function.\r\n   * Turns `fn(a, b)` into `fn(a)(b)`.\r\n   * @example const add = curry((a, b) => a + b); add(1)(2);\r\n   */\r\n  curry: <A, B, R>(fn: (a: A, b: B) => R) => (a: A) => (b: B): R => fn(a, b),\r\n\r\n  /**\r\n   * Swaps the arguments of a curried function.\r\n   * Turns `fn(a)(b)` into `fn(b)(a)`.\r\n   * Useful for converting \"Config-First\" to \"Target-First\" or vice versa.\r\n   * \r\n   * @example \r\n   * // Suppose style(prop)(el)\r\n   * const styleEl = swap(style)(el);\r\n   * styleEl('color');\r\n   */\r\n  swap: <A, B, R>(fn: (a: A) => (b: B) => R) => (b: B) => (a: A): R => fn(a)(b),\r\n\r\n  /**\r\n   * Flips the arguments of a standard binary function.\r\n   * Turns `fn(a, b)` into `fn(b, a)`.\r\n   */\r\n  flip: <A, B, R>(fn: (a: A, b: B) => R) => (b: B, a: A): R => fn(a, b),\r\n\r\n  /**\r\n   * Executes a side-effect function and returns the original value.\r\n   * Essential for logging or debugging inside a `pipe` chain without breaking it.\r\n   * \r\n   * @example pipe(modify({...}), tap(console.log), addClass('active'))(el);\r\n   */\r\n  tap: <T>(fn: (x: T) => void) => (x: T): T => {\r\n    fn(x);\r\n    return x;\r\n  },\r\n\r\n  /**\r\n   * Executes a function only if the value is not null/undefined.\r\n   * Useful wrapper for standard API functions that might crash on null.\r\n   * \r\n   * @example const safeParse = maybe(JSON.parse);\r\n   */\r\n  maybe: <T, R>(fn: (x: T) => R) => (x: T | null | undefined): R | null => {\r\n    return (x === null || x === undefined) ? null : fn(x);\r\n  },\r\n\r\n  /**\r\n   * Creates a function that accepts data as the *first* argument, \r\n   * but applies it to a curried function expecting data *last*.\r\n   * \r\n   * Adapts `fn(config)(data)` to `fn(data, config)`.\r\n   */\r\n  unbind: <D, C, R>(fn: (config: C) => (data: D) => R) => (data: D, config: C): R => {\r\n    return fn(config)(data);\r\n  },\r\n\r\n  /**\r\n   * \"Thunks\" a function. Returns a function that accepts no arguments \r\n   * and returns the result of the original call.\r\n   * Useful for event handlers that don't need the event object.\r\n   * \r\n   * @example on(btn)('click', thunk(count, increment));\r\n   */\r\n  thunk: <T>(fn: (...args: any[]) => T, ...args: any[]) => () => fn(...args),\r\n\r\n  /**\r\n   * Returns the value unchanged.\r\n   * Useful as a default no-op callback.\r\n   */\r\n  identity: <T>(x: T): T => x,\r\n\r\n  /**\r\n   * A function that does nothing.\r\n   */\r\n  noop: () => { }\r\n};\r\n\r\n// =============================================================================\r\n// 37. ERROR HANDLING (RESULT & OPTION)\r\n// =============================================================================\r\n\r\n/**\r\n * Represents a successful computation.\r\n */\r\nexport type Ok<T> = { ok: true; val: T; err: null };\r\n\r\n/**\r\n * Represents a failed computation.\r\n */\r\nexport type Err<E> = { ok: false; val: null; err: E };\r\n\r\n/**\r\n * A Result type (inspired by Rust) that is either Ok or Err.\r\n * Forces you to check `.ok` before accessing the value.\r\n */\r\nexport type Result<T, E = Error> = Ok<T> | Err<E>;\r\n\r\nexport const Result = {\r\n  /** Creates a success result. */\r\n  ok: <T>(val: T): Ok<T> => ({ ok: true, val, err: null }),\r\n\r\n  /** Creates a failure result. */\r\n  err: <E>(err: E): Err<E> => ({ ok: false, val: null, err }),\r\n\r\n  /**\r\n   * Wraps a synchronous function that might throw.\r\n   * Returns a Result object instead of throwing.\r\n   * \r\n   * @example\r\n   * const res = Result.try(() => JSON.parse(badString));\r\n   * if (!res.ok) console.error(res.err);\r\n   */\r\n  try: <T>(fn: () => T): Result<T, Error> => {\r\n    try {\r\n      return Result.ok(fn());\r\n    } catch (e) {\r\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Wraps a Promise that might reject.\r\n   * Returns a Promise<Result>.\r\n   * \r\n   * @example\r\n   * const { ok, val, err } = await Result.async(() => fetch('/api'));\r\n   */\r\n  async: async <T>(fn: () => Promise<T>): Promise<Result<T, Error>> => {\r\n    try {\r\n      const val = await fn();\r\n      return Result.ok(val);\r\n    } catch (e) {\r\n      return Result.err(e instanceof Error ? e : new Error(String(e)));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Unwraps a Result. Returns value if Ok, throws if Err.\r\n   */\r\n  unwrap: <T, E>(res: Result<T, E>): T => {\r\n    if (res.ok) return res.val;\r\n    throw res.err;\r\n  },\r\n\r\n  /**\r\n   * Unwraps a Result with a fallback value.\r\n   */\r\n  unwrapOr: <T, E>(res: Result<T, E>, fallback: T): T => {\r\n    return res.ok ? res.val : fallback;\r\n  },\r\n\r\n  /**\r\n   * Maps the value if Ok, ignores if Err.\r\n   */\r\n  map: <T, U, E>(res: Result<T, E>, fn: (v: T) => U): Result<U, E> => {\r\n    return res.ok ? Result.ok(fn(res.val)) : res as unknown as Err<E>;\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 38. OPTION (NULLABLE HANDLING)\r\n// =============================================================================\r\n\r\n/**\r\n * Functional wrapper for nullable values.\r\n */\r\nexport const Option = {\r\n  /**\r\n   * Creates an Option from a nullable value.\r\n   */\r\n  from: <T>(val: T | null | undefined) => ({\r\n    val,\r\n    isSome: val !== null && val !== undefined,\r\n    isNone: val === null || val === undefined\r\n  }),\r\n\r\n  /**\r\n   * Returns the value or a fallback.\r\n   * @example Option.unwrapOr(input, 'default');\r\n   */\r\n  unwrapOr: <T>(val: T | null | undefined, fallback: T): T => {\r\n    return (val !== null && val !== undefined) ? val : fallback;\r\n  },\r\n\r\n  /**\r\n   * Maps the value if it exists, returns null otherwise.\r\n   * @example const len = Option.map(str, s => s.length);\r\n   */\r\n  map: <T, R>(val: T | null | undefined, fn: (v: T) => R): R | null => {\r\n    return (val !== null && val !== undefined) ? fn(val) : null;\r\n  },\r\n\r\n  /**\r\n   * Executes side-effect if value exists.\r\n   * @example Option.then(element, el => el.remove());\r\n   */\r\n  then: <T>(val: T | null | undefined, fn: (v: T) => void): void => {\r\n    if (val !== null && val !== undefined) fn(val);\r\n  }\r\n};\r\n\r\n// =============================================================================\r\n// 39. REACTIVE BINDINGS (\"THE HARD WAY\" HELPERS)\r\n// =============================================================================\r\n\r\n/**\r\n * A Setter function that updates the DOM only if the value has changed.\r\n */\r\nexport type Setter<T> = (newValue: T) => void;\r\n\r\nexport const bind = {\r\n  /**\r\n   * Generic value binder with diffing.\r\n   * \r\n   * @example\r\n   * const setScore = bind.val(0, (n) => div.innerText = n);\r\n   */\r\n  val: <T>(initial: T, effect: (val: T) => void): Setter<T> => {\r\n    let current = initial;\r\n    return (next: T) => {\r\n      if (!Object.is(current, next)) {\r\n        current = next;\r\n        effect(next);\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds textContent.\r\n   * @example const setText = bind.text(h1); setText('Hello');\r\n   */\r\n  text: (el: HTMLElement | null): Setter<string> => {\r\n    let current: string | undefined;\r\n    return (text: string) => {\r\n      if (el && current !== text) {\r\n        current = text;\r\n        el.textContent = text;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds innerHTML.\r\n   */\r\n  html: (el: HTMLElement | null): Setter<string> => {\r\n    let current: string | undefined;\r\n    return (html: string) => {\r\n      if (el && current !== html) {\r\n        current = html;\r\n        el.innerHTML = html;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Binds an attribute.\r\n   * Supports optional currying: `attr(name, el)` or `attr(name)(el)`.\r\n   * \r\n   * @example\r\n   * const setId = bind.attr('id', div); \r\n   * setId(123);\r\n   */\r\n  attr: (name: string, el?: HTMLElement | null) => {\r\n    const createSetter = (target: HTMLElement | null): Setter<string | number | boolean | null> => {\r\n      let current: any;\r\n      return (val) => {\r\n        if (!target || current === val) return;\r\n        current = val;\r\n        if (val === null || val === false) target.removeAttribute(name);\r\n        else target.setAttribute(name, String(val));\r\n      };\r\n    };\r\n    // Handle optional currying\r\n    return el !== undefined ? createSetter(el) : createSetter;\r\n  },\r\n\r\n  /**\r\n   * Binds a class toggle.\r\n   * Supports optional currying.\r\n   * \r\n   * @example const toggleActive = bind.toggle('active', div);\r\n   */\r\n  toggle: (className: string, el?: HTMLElement | null) => {\r\n    const createSetter = (target: HTMLElement | null): Setter<boolean> => {\r\n      let current: boolean | undefined;\r\n      return (active) => {\r\n        if (!target || current === active) return;\r\n        current = active;\r\n        target.classList.toggle(className, active);\r\n      };\r\n    };\r\n    return el !== undefined ? createSetter(el) : createSetter;\r\n  },\r\n\r\n  /**\r\n   * Binds a list to a container.\r\n   * Replaces children only if array reference changes.\r\n   * \r\n   * @example \r\n   * const updateList = bind.list(ul, (user, i) => el('li')({ text: user.name })());\r\n   * updateList(users);\r\n   */\r\n  list: <T>(container: HTMLElement | null, renderItem: (item: T, index: number) => Node) => {\r\n    let currentData: T[] | undefined;\r\n\r\n    return (data: T[]) => {\r\n      if (!container) return;\r\n      if (data === currentData) return; // Ref check\r\n\r\n      currentData = data;\r\n\r\n      // Optimization: fast clear if empty\r\n      if (data.length === 0) {\r\n        if (container.firstChild) container.replaceChildren();\r\n        return;\r\n      }\r\n\r\n      const fragment = document.createDocumentFragment();\r\n      data.forEach((item, i) => fragment.appendChild(renderItem(item, i)));\r\n      container.replaceChildren(fragment);\r\n    };\r\n  }\r\n};\r\n\r\n\r\n// =============================================================================\r\n// 40. VIEW FACTORY & BINDER GENERATOR\r\n// =============================================================================\r\n/**\r\n * Helper to bind multiple events to refs in one go.\r\n * \r\n * @example\r\n * bindEvents(refs, {\r\n *   btn: { click: handleClick },\r\n *   input: { input: handleInput, keydown: handleKey }\r\n * })\r\n */\r\nexport const bindEvents = <K extends string>(\r\n  refs: Record<K, HTMLElement>,\r\n  map: Partial<Record<K, Record<string, (e: Event, el: HTMLElement) => void>>>\r\n) => {\r\n  Object.entries(map).forEach(([refKey, events]) => {\r\n    const el = refs[refKey as K];\r\n    if (!el) return;\r\n\r\n    Object.entries(events as Record<string, any>).forEach(([evtName, handler]) => {\r\n      // Uses our standard 'on' function\r\n      on(el)(evtName as any, (e) => handler(e, el));\r\n    });\r\n  });\r\n};\r\n/**\r\n * Defines the shape of the Refs object returned by `view()`.\r\n * Use a generic to specify keys: `view<'title' | 'button'>`\r\n */\r\nexport type Refs<K extends string> = Record<K, HTMLElement>;\r\n\r\n/**\r\n * A factory for creating maintainable \"Hard Way\" views.\r\n * \r\n * @template K - The names of the data-ref attributes in the HTML.\r\n * @param htmlString - The HTML template string.\r\n */\r\nexport const view = <K extends string = string>(htmlString: string) => {\r\n  const tpl = document.createElement('template');\r\n  tpl.innerHTML = htmlString.trim();\r\n\r\n  /**\r\n   * Instantiates the view.\r\n   * @returns {{ root: HTMLElement | DocumentFragment, refs: Refs<K> }}\r\n   */\r\n  return () => {\r\n    const root = document.importNode(tpl.content, true);\r\n    const refs = {} as Refs<K>;\r\n\r\n    root.querySelectorAll('[data-ref]').forEach(el => {\r\n      const key = (el as HTMLElement).dataset.ref;\r\n      if (key) refs[key as K] = el as HTMLElement;\r\n    });\r\n\r\n    // Determine if we return a single root element or the fragment\r\n    const rootEl = (root.children.length === 1 ? root.firstElementChild : root) as HTMLElement | DocumentFragment;\r\n\r\n    return { root: rootEl, refs };\r\n  };\r\n};\r\n\r\n/**\r\n * A helper to generate a typed object of Setters from a Refs object.\r\n * This reduces the boilerplate of creating individual binders manually.\r\n * \r\n * @example\r\n * const { refs } = createCard();\r\n * const ui = binder(refs, {\r\n *   title: bind.text,\r\n *   image: bind.attr('src'),\r\n *   active: bind.toggle('is-active')\r\n * });\r\n * \r\n * // Usage\r\n * ui.title('Hello');\r\n * ui.active(true);\r\n */\r\nexport const binder = <\r\n  R extends Record<string, HTMLElement>,\r\n  Schema extends { [Key in keyof R]?: (el: HTMLElement) => Setter<any> }\r\n>(\r\n  refs: R,\r\n  schema: Schema\r\n): { [Key in keyof Schema]: Schema[Key] extends (el: any) => infer S ? S : never } => {\r\n  const binders = {} as any;\r\n  for (const key in schema) {\r\n    if (refs[key]) {\r\n      // @ts-ignore\r\n      binders[key] = schema[key](refs[key]);\r\n    }\r\n  }\r\n  return binders;\r\n};\r\n\r\n// =============================================================================\r\n// 41. HTTP FACTORY (TYPE-SAFE, FLEXIBLE, WITH DEFAULTS)\r\n// =============================================================================\r\n\r\n/**\r\n * HTTP request method type.\r\n */\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\r\n\r\n/**\r\n * HTTP response status code.\r\n */\r\nexport type HttpStatus = 200 | 201 | 204 | 400 | 401 | 403 | 404 | 405 | 409 | 422 | 429 | 500 | 502 | 503 | (number & {});\r\n\r\n/**\r\n * Flexible request init configuration.\r\n * Supports any standard Fetch API options plus custom extensions.\r\n * \r\n * @template T - Custom header type overrides\r\n */\r\nexport interface HttpRequestInit extends Omit<RequestInit, 'body'> {\r\n  /** Request body - auto-stringified if object */\r\n  body?: BodyInit | Record<string, any> | null;\r\n  /** Base URL to prepend (overrides Http defaults) */\r\n  baseURL?: string;\r\n  /** Query parameters to append */\r\n  params?: Record<string, string | number | boolean | null | undefined>;\r\n  /** Custom timeout in ms (0 = no timeout) */\r\n  timeout?: number;\r\n  /** Retry count on network failure (default: 0) */\r\n  retries?: number;\r\n  /** Delay between retries in ms (default: 1000) */\r\n  retryDelay?: number;\r\n  /** Transform response before returning */\r\n  transform?: (data: any) => any;\r\n}\r\n\r\n/**\r\n * HTTP response wrapper with metadata.\r\n * \r\n * @template T - The response data type\r\n * \r\n * @example\r\n * ```typescript\r\n * const res: HttpResponse<User> = await http.get('/users/1')({});\r\n * if (res.ok) console.log(res.data); // User\r\n * else console.error(res.statusText, res.error);\r\n * ```\r\n */\r\nexport interface HttpResponse<T = any> {\r\n  /** True if status is 2xx */\r\n  ok: boolean;\r\n  /** HTTP status code */\r\n  status: HttpStatus;\r\n  /** Status text (e.g., \"OK\", \"Not Found\") */\r\n  statusText: string;\r\n  /** Response data (parsed JSON, text, blob, etc.) */\r\n  data: T | null;\r\n  /** Error object if request failed */\r\n  error: Error | null;\r\n  /** Raw Fetch Response object */\r\n  response: globalThis.Response;\r\n}\r\n\r\n/**\r\n * HTTP client configuration.\r\n * Defines defaults for all requests made by this client.\r\n * \r\n * @template H - Custom header keys type\r\n */\r\nexport interface HttpConfig<H extends string = string> {\r\n  /** Base URL for all requests (e.g., \"https://api.example.com\") */\r\n  baseURL?: string;\r\n  /** Default headers for all requests */\r\n  headers?: Record<H | string, string>;\r\n  /** Default timeout in ms (0 = no timeout) */\r\n  timeout?: number;\r\n  /** Retry policy for network failures */\r\n  retries?: number;\r\n  /** Delay between retries */\r\n  retryDelay?: number;\r\n  /** Request interceptor (runs before fetch) */\r\n  interceptRequest?: (init: HttpRequestInit) => HttpRequestInit | Promise<HttpRequestInit>;\r\n  /** Response interceptor (runs after fetch) */\r\n  interceptResponse?: <T = any>(res: HttpResponse<T>) => HttpResponse<T> | Promise<HttpResponse<T>>;\r\n}\r\n\r\n/**\r\n * Merges two header objects with type safety.\r\n * @internal\r\n */\r\nconst _mergeHeaders = (\r\n  base: Record<string, string> | undefined,\r\n  override: Record<string, string> | undefined\r\n): Record<string, string> => {\r\n  return { ...base, ...override };\r\n};\r\n\r\n/**\r\n * Builds a full URL with optional base and params.\r\n * @internal\r\n */\r\nconst _buildUrl = (path: string, baseURL?: string, params?: Record<string, any>): string => {\r\n  let url = baseURL ? `${baseURL}${path}` : path;\r\n\r\n  if (params) {\r\n    const search = new URLSearchParams();\r\n    for (const [key, val] of Object.entries(params)) {\r\n      if (val !== null && val !== undefined) {\r\n        search.set(key, String(val));\r\n      }\r\n    }\r\n    const qs = search.toString();\r\n    if (qs) url += `${url.includes('?') ? '&' : '?'}${qs}`;\r\n  }\r\n\r\n  return url;\r\n};\r\n\r\n/**\r\n * Converts body to RequestInit.body format.\r\n * @internal\r\n */\r\nconst _encodeBody = (body: any): BodyInit | null => {\r\n  if (body === null || body === undefined) return null;\r\n  if (typeof body === 'string') return body;\r\n  if (body instanceof Blob) return body;\r\n  if (body instanceof FormData) return body;\r\n  if (body instanceof ArrayBuffer) return body;\r\n  // Object: serialize to JSON\r\n  return JSON.stringify(body);\r\n};\r\n\r\n/**\r\n * Parses response based on content-type.\r\n * @internal\r\n */\r\nconst _parseResponse = async (response: globalThis.Response, transform?: (data: any) => any): Promise<any> => {\r\n  const contentType = response.headers.get('content-type') || '';\r\n\r\n  let data: any;\r\n  if (contentType.includes('application/json')) {\r\n    try {\r\n      data = await response.json();\r\n    } catch {\r\n      data = await response.text();\r\n    }\r\n  } else if (contentType.includes('text')) {\r\n    data = await response.text();\r\n  } else if (contentType.includes('image') || contentType.includes('video') || contentType.includes('audio')) {\r\n    data = await response.blob();\r\n  } else {\r\n    data = await response.arrayBuffer();\r\n  }\r\n\r\n  return transform ? transform(data) : data;\r\n};\r\n\r\n/**\r\n * Executes a fetch request with retry logic.\r\n * @internal\r\n */\r\nconst _fetchWithRetry = async (\r\n  url: string,\r\n  init: RequestInit,\r\n  retries: number = 0,\r\n  retryDelay: number = 1000,\r\n  timeout: number = 0\r\n): Promise<globalThis.Response> => {\r\n  const controller = new AbortController();\r\n  const timeoutId = timeout > 0 ? setTimeout(() => controller.abort(), timeout) : undefined;\r\n\r\n  try {\r\n    return await fetch(url, { ...init, signal: controller.signal });\r\n  } catch (error) {\r\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\r\n\r\n    // Retry on network error (not on HTTP error like 404)\r\n    if (retries > 0 && (error instanceof TypeError || error instanceof DOMException)) {\r\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\r\n      return _fetchWithRetry(url, init, retries - 1, retryDelay, timeout);\r\n    }\r\n\r\n    throw error;\r\n  } finally {\r\n    if (timeoutId !== undefined) clearTimeout(timeoutId);\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a type-safe HTTP client with flexible configuration.\r\n * \r\n * Advanced HTTP factory with full control: configure defaults per client,\r\n * override per-request, automatic retries, timeouts, interceptors, and more.\r\n * \r\n * Features:\r\n * - Fully type-safe with generics for request/response\r\n * - Automatic JSON serialization/deserialization\r\n * - Query parameter support with smart merging\r\n * - Configurable defaults (baseURL, headers, timeout, retries)\r\n * - Request/response interceptors (async support)\r\n * - Timeout support with AbortController\r\n * - Automatic retry on network failure\r\n * - Content-type detection (JSON, text, blob, etc.)\r\n * - Returns typed response object with metadata + helper methods\r\n * \r\n * @template H - Custom header keys (e.g., 'Authorization', 'X-Custom')\r\n * @param config - HTTP client configuration\r\n * @returns A configured Http client factory with GET, POST, PUT, DELETE, PATCH methods\r\n * \r\n * @example\r\n * ```typescript\r\n * // ===== BASIC SETUP =====\r\n * const api = HttpFactory.create({\r\n *   baseURL: 'https://api.example.com',\r\n *   headers: { 'X-API-Key': 'secret' },\r\n *   timeout: 5000,\r\n *   retries: 2\r\n * });\r\n * \r\n * // ===== TYPE-SAFE REQUESTS =====\r\n * interface User { id: number; name: string }\r\n * interface CreateUserPayload { name: string; email: string }\r\n * \r\n * // GET with automatic type inference\r\n * const res = await api.get<User>('/users/123')({});\r\n * if (res.ok) console.log(res.data.id); // data is User\r\n * \r\n * // POST with body and query params\r\n * const created = await api.post<User>('/users')({\r\n *   body: { name: 'Alice', email: 'alice@example.com' },\r\n *   params: { notify: true },\r\n *   timeout: 3000\r\n * });\r\n * \r\n * // ===== PER-REQUEST OVERRIDES =====\r\n * // Override baseURL for specific request\r\n * await api.get('/status')({\r\n *   baseURL: 'https://status.example.com'\r\n * });\r\n * \r\n * // Override timeout for slow endpoint\r\n * await api.get<Data>('/expensive-operation')({\r\n *   timeout: 30000,\r\n *   retries: 3\r\n * });\r\n * \r\n * // ===== INTERCEPTORS (AUTH, LOGGING, ERROR HANDLING) =====\r\n * const api = HttpFactory.create({\r\n *   baseURL: 'https://api.example.com',\r\n *   interceptRequest: async (init) => {\r\n *     // Add auth token dynamically\r\n *     const token = await getAuthToken();\r\n *     return {\r\n *       ...init,\r\n *       headers: {\r\n *         ...init.headers,\r\n *         'Authorization': `Bearer ${token}`\r\n *       }\r\n *     };\r\n *   },\r\n *   interceptResponse: async (res) => {\r\n *     // Global error handling\r\n *     if (res.status === 401) {\r\n *       await refreshAuth();\r\n *       // Retry logic would go here\r\n *     }\r\n *     return res;\r\n *   }\r\n * });\r\n * \r\n * // ===== RESPONSE HELPERS =====\r\n * const res = await api.get<User[]>('/users')({});\r\n * \r\n * // Check success\r\n * if (api.isOk(res)) {\r\n *   console.log(res.data); // Narrowed to User[]\r\n * }\r\n * \r\n * // Unwrap or throw\r\n * const users = api.unwrap(res); // throws if not ok\r\n * \r\n * // Unwrap with fallback\r\n * const users = api.unwrapOr(res, []); // returns [] if error\r\n * \r\n * // ===== TRANSFORMATION =====\r\n * await api.get<string[]>('/tags')({\r\n *   transform: (data) => data.map((t: any) => t.name) // Transform JSON before returning\r\n * });\r\n * ```\r\n */\r\nexport const Http = {\r\n  /**\r\n   * Creates a configured HTTP client with defaults.\r\n   * \r\n   * Use this for applications that need centralized configuration, interceptors,\r\n   * or per-client defaults (baseURL, timeout, retries, custom headers).\r\n   * \r\n   * For simple one-off requests, use the static methods: Http.get, Http.post, etc.\r\n   * \r\n   * @template H - Custom header keys type\r\n   * @param config - Client configuration\r\n   * @returns An Http client factory\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const api = Http.create({\r\n   *   baseURL: 'https://api.example.com',\r\n   *   headers: { 'X-API-Key': 'secret' },\r\n   *   timeout: 5000,\r\n   *   retries: 2,\r\n   *   interceptRequest: async (init) => {\r\n   *     const token = await getAuthToken();\r\n   *     return {\r\n   *       ...init,\r\n   *       headers: { ...init.headers, 'Authorization': `Bearer ${token}` }\r\n   *     };\r\n   *   }\r\n   * });\r\n   * \r\n   * const user = await api.get<User>('/users/123')({});\r\n   * ```\r\n   */\r\n  create: <H extends string = string>(config: HttpConfig<H> = {}) => {\r\n    const {\r\n      baseURL: defaultBaseURL,\r\n      headers: defaultHeaders,\r\n      timeout: defaultTimeout = 0,\r\n      retries: defaultRetries = 0,\r\n      retryDelay: defaultRetryDelay = 1000,\r\n      interceptRequest,\r\n      interceptResponse\r\n    } = config;\r\n\r\n    /**\r\n     * Executes an HTTP request.\r\n     * @internal\r\n     */\r\n    const _request = async <T = any>(\r\n      method: HttpMethod,\r\n      path: string,\r\n      init: HttpRequestInit = {}\r\n    ): Promise<HttpResponse<T>> => {\r\n      const {\r\n        body,\r\n        baseURL = defaultBaseURL,\r\n        params,\r\n        timeout = defaultTimeout,\r\n        retries = defaultRetries,\r\n        retryDelay = defaultRetryDelay,\r\n        transform,\r\n        ...restInit\r\n      } = init;\r\n\r\n      // Merge headers (default + request-specific)\r\n      const headers = _mergeHeaders(\r\n        defaultHeaders as Record<string, string> | undefined,\r\n        restInit.headers as Record<string, string> | undefined\r\n      );\r\n\r\n      // Auto-set Content-Type for JSON bodies\r\n      if (body && typeof body === 'object' && !Array.isArray(body) && !(body instanceof FormData)) {\r\n        headers['Content-Type'] = 'application/json';\r\n      }\r\n\r\n      // Build fetch init\r\n      let fetchInit: any = {\r\n        ...restInit,\r\n        method,\r\n        headers\r\n      };\r\n\r\n      // Encode body\r\n      if (body !== undefined && body !== null) {\r\n        fetchInit.body = _encodeBody(body);\r\n      }\r\n\r\n      // Run request interceptor\r\n      if (interceptRequest) {\r\n        const intercepted = await interceptRequest(init);\r\n        fetchInit = { ...fetchInit, ...intercepted } as any;\r\n      }\r\n\r\n      // Build full URL with params\r\n      const url = _buildUrl(path, baseURL, params);\r\n\r\n      // Execute fetch with retry logic\r\n      let response: globalThis.Response;\r\n      try {\r\n        response = await _fetchWithRetry(url, fetchInit, retries, retryDelay, timeout);\r\n      } catch (error) {\r\n        const httpRes: HttpResponse<T> = {\r\n          ok: false,\r\n          status: 0,\r\n          statusText: 'Network Error',\r\n          data: null,\r\n          error: error instanceof Error ? error : new Error(String(error)),\r\n          response: null as any\r\n        };\r\n        return interceptResponse ? await interceptResponse(httpRes) : httpRes;\r\n      }\r\n\r\n      // Parse response data\r\n      let data: T | null = null;\r\n      try {\r\n        data = await _parseResponse(response, transform);\r\n      } catch (error) {\r\n        console.error('Failed to parse response:', error);\r\n      }\r\n\r\n      // Build response wrapper\r\n      const httpRes: HttpResponse<T> = {\r\n        ok: response.ok,\r\n        status: response.status as HttpStatus,\r\n        statusText: response.statusText,\r\n        data,\r\n        error: null,\r\n        response\r\n      };\r\n\r\n      // Run response interceptor\r\n      return interceptResponse ? await interceptResponse(httpRes) : httpRes;\r\n    };\r\n\r\n    return {\r\n      /**\r\n       * Performs a GET request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path (e.g., '/users/123')\r\n       * @returns A curried function that accepts request config\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.get<User>('/users/123')({});\r\n       * ```\r\n       */\r\n      get: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('GET', path, init),\r\n\r\n      /**\r\n       * Performs a POST request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.post<Created>('/users')({\r\n       *   body: { name: 'John' }\r\n       * });\r\n       * ```\r\n       */\r\n      post: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('POST', path, init),\r\n\r\n      /**\r\n       * Performs a PUT request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       */\r\n      put: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('PUT', path, init),\r\n\r\n      /**\r\n       * Performs a DELETE request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config\r\n       */\r\n      delete: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('DELETE', path, init),\r\n\r\n      /**\r\n       * Performs a PATCH request.\r\n       * \r\n       * @template T - Response data type\r\n       * @param path - Endpoint path\r\n       * @returns A curried function that accepts request config with body\r\n       */\r\n      patch: <T = any>(path: string) => (init: HttpRequestInit = {}) => _request<T>('PATCH', path, init),\r\n\r\n      /**\r\n       * Checks if an HTTP response is successful (2xx).\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const res = await http.get('/users')({});\r\n       * if (http.isOk(res)) {\r\n       *   // res.data is guaranteed to be of the generic type\r\n       * }\r\n       * ```\r\n       */\r\n      isOk: <T = any>(res: HttpResponse<T>): res is HttpResponse<T> & { data: T } => res.ok,\r\n\r\n      /**\r\n       * Unwraps response data or throws on error.\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const users = http.unwrap(await http.get<User[]>('/users')({}));\r\n       * ```\r\n       */\r\n      unwrap: <T = any>(res: HttpResponse<T>): T => {\r\n        if (!res.ok) throw res.error || new Error(`HTTP ${res.status}: ${res.statusText}`);\r\n        return res.data as T;\r\n      },\r\n\r\n      /**\r\n       * Unwraps response data or returns fallback on error.\r\n       * \r\n       * @example\r\n       * ```typescript\r\n       * const users = http.unwrapOr(\r\n       *   await http.get<User[]>('/users')({}),\r\n       *   []\r\n       * );\r\n       * ```\r\n       */\r\n      unwrapOr: <T = any>(res: HttpResponse<T>, fallback: T): T => {\r\n        return res.ok ? (res.data as T) : fallback;\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Performs a simple GET request without client configuration.\r\n   * \r\n   * Throws an error if the response is not ok (non-2xx status).\r\n   * \r\n   * **Error Handling**: Error message includes status code and text.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to fetch from\r\n   * @param headers - Optional request headers\r\n   * @returns Promise resolving to parsed JSON response\r\n   * @throws Error if response is not ok\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic GET\r\n   * const users = await Http.get<User[]>('/api/users');\r\n   * \r\n   * // With custom headers\r\n   * const data = await Http.get<Data>('/api/data', {\r\n   *   'Authorization': 'Bearer token',\r\n   *   'Accept-Language': 'en-US'\r\n   * });\r\n   * \r\n   * // Error handling\r\n   * try {\r\n   *   const user = await Http.get<User>('/api/user/999');\r\n   * } catch (error) {\r\n   *   // Error message: \"Http.get 404: Not Found\"\r\n   *   console.error(error);\r\n   * }\r\n   * ```\r\n   */\r\n  get: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, { headers });\r\n    if (!res.ok) throw new Error(`Http.get ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple POST request without client configuration.\r\n   * \r\n   * **Curried API**: url -> body -> headers for composition and reusability.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to post to\r\n   * @returns A curried function accepting body then headers\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Basic POST\r\n   * const user = await Http.post('/api/users')\r\n   *   ({ name: 'John', email: 'john@example.com' })\r\n   *   ();\r\n   * \r\n   * // With auth headers\r\n   * const response = await Http.post('/api/login')\r\n   *   ({ username: 'admin', password: 'secret' })\r\n   *   ({ 'X-CSRF-Token': csrfToken });\r\n   * \r\n   * // Partial application\r\n   * const createUser = Http.post('/api/users');\r\n   * const user1 = await createUser({ name: 'Alice' })();\r\n   * const user2 = await createUser({ name: 'Bob' })();\r\n   * ```\r\n   */\r\n  post: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json', ...headers },\r\n      body: JSON.stringify(body)\r\n    });\r\n    if (!res.ok) throw new Error(`Http.post ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple PUT request without client configuration.\r\n   * \r\n   * **Curried API**: url -> body -> headers for composition and reusability.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type\r\n   * @param url - The URL to put to\r\n   * @returns A curried function accepting body then headers\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Update resource\r\n   * const updated = await Http.put('/api/users/123')\r\n   *   ({ name: 'John Updated', email: 'new@example.com' })\r\n   *   ({ 'Authorization': `Bearer ${token}` });\r\n   * \r\n   * // Partial application\r\n   * const updateUser = (id: number) => Http.put(`/api/users/${id}`);\r\n   * await updateUser(123)({ name: 'Alice' })();\r\n   * ```\r\n   */\r\n  put: (url: string) => <T>(body: any) => async (headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, {\r\n      method: 'PUT',\r\n      headers: { 'Content-Type': 'application/json', ...headers },\r\n      body: JSON.stringify(body)\r\n    });\r\n    if (!res.ok) throw new Error(`Http.put ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  },\r\n\r\n  /**\r\n   * Performs a simple DELETE request without client configuration.\r\n   * \r\n   * Throws an error if the response is not ok.\r\n   * \r\n   * @template T - The expected response type (often void or { success: boolean })\r\n   * @param url - The URL to delete\r\n   * @param headers - Optional request headers\r\n   * @returns Promise resolving to parsed JSON response\r\n   * @throws Error if response is not ok\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * // Delete resource\r\n   * await Http.delete('/api/users/123', {\r\n   *   'Authorization': `Bearer ${token}`\r\n   * });\r\n   * \r\n   * // With confirmation\r\n   * const result = await Http.delete<{ success: boolean }>(\r\n   *   '/api/posts/456',\r\n   *   { 'Authorization': `Bearer ${token}` }\r\n   * );\r\n   * if (result.success) {\r\n   *   remove(postElement);\r\n   * }\r\n   * ```\r\n   */\r\n  delete: async <T>(url: string, headers: Record<string, string> = {}): Promise<T> => {\r\n    const res = await fetch(url, { method: 'DELETE', headers });\r\n    if (!res.ok) throw new Error(`Http.delete ${res.status}: ${res.statusText}`);\r\n    return res.json();\r\n  }\r\n};"],
  "mappings": "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",
  "names": ["el", "html", "refs", "httpRes"]
}
